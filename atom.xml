<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeijieZhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leijiezhang001.github.io/"/>
  <updated>2020-06-22T09:00:45.632Z</updated>
  <id>https://leijiezhang001.github.io/</id>
  
  <author>
    <name>Leijie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[paper_reading]-&quot;PointPainting: Sequential Fusion for 3D Object Detection&quot;</title>
    <link href="https://leijiezhang001.github.io/PointPainting/"/>
    <id>https://leijiezhang001.github.io/PointPainting/</id>
    <published>2020-06-17T03:27:38.000Z</published>
    <updated>2020-06-22T09:00:45.632Z</updated>
    
    <content type="html"><![CDATA[<p>　　相机能很好的捕捉场景的语义信息，激光雷达则能很好的捕捉场景的三维信息，所以图像与点云的融合，对检测，分割等任务有非常大的帮助。融合可分为，<strong>数据级或特征级的前融合</strong>，以及<strong>任务级的后融合</strong>。本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种将图像分割结果的语义信息映射到点云，进而作 3D 检测的方法。这种串行方式的融合，既有点前融合的意思，也有点后融合的意思，暂且可归为前融合吧。本方法可认为是个框架，该框架下，基于图像的语义分割，以及基于点云的 3D 检测，均为独立模块。实验表明，融合了图像的语义信息后，点云针对行人等小目标的检测有较大的性能提升。</p><h2 id="framework">1. Framework</h2><p><img src="/PointPainting/framework.png" width="100%" height="100%" title="图 1. Framework"> 　　如图 1. 所示，算法框架非常简单，一句话能说明白：1). 首先经过图像语义分割获得语义图；2). 然后将点云投影到图像上，查询点云的语义信息，并连接到坐标信息中；3). 最后用点云 3D 检测的方法作 3D 检测。</p><h2 id="experiments">2. Experiments</h2><p><img src="/PointPainting/sota.png" width="90%" height="90%" title="图 2. PointPainting Applied to SOTA"> 　　采用 DeepLabv3+ 作为语义分割模块，应用到不同的点云 3D 检测后，结果如图 2. 所示，均有不同程度的提升，尤其是行人这种小目标。 <img src="/PointPainting/pointrcnn.png" width="90%" height="90%" title="图 3. Painted PointRCNN"> 　　图 3. 显示了 Painted PointRCNN 与各个方法的对比结果，mAP 是最高的。 <img src="/PointPainting/per-class.png" width="90%" height="90%" title="图 4. 不同类别的提升程度"> 　　由图 4. 可知，对行人，自行车，雪糕筒等小目标(俯视图下来说)，本方法提升非常显著。这也比较好理解，因为前视图下，这些目标所占的像素会比较多，所以更容易在前视相机图像下提取有效信息，辅助俯视图下作更准确的检测。</p><h2 id="rethinking-of-early-fusion">3. Rethinking of Early Fusion</h2><p>　　这里将本方法归为前融合，但是并不是真正意义上的前融合。如果是前融合，那么一般是 concate 语义分割网络的中低层特征到点云信息中，然而本文是直接取语义分割网络的最高层特征(即分类结果)。<strong>所以问题来了，所谓的前融合，一定比后融合更好吗？</strong>我想，这篇文章可能给了一些答案(不知道作者有没有做过取其它特征的实验，姑且认为做过，然后选择了本方法的策略)，虽然理论上前融合信息最完整，但是，如果这种完整的信息无法有效学出来或者对标定外参比较敏感，那么这种前融合也提升不了后续任务的性能，更有甚者，由于信息空间的变大或紊乱，导致后续任务性能下降。相反，对于不是那么“前”的后融合，我们能极大得保证各个任务学习结果的有效性，基于此，融合后学习的有效性也会比较确定。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Vora, Sourabh, et al. &quot;Pointpainting: Sequential fusion for 3d object detection.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　相机能很好的捕捉场景的语义信息，激光雷达则能很好的捕捉场景的三维信息，所以图像与点云的融合，对检测，分割等任务有非常大的帮助。融合可分为，&lt;strong&gt;数据级或特征级的前融合&lt;/strong&gt;，以及&lt;strong&gt;任务级的后融合&lt;/strong&gt;。本文&lt;a href=
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Joint 3D Instance Segmentation and Objection Detection for Autonomous Driving&quot;</title>
    <link href="https://leijiezhang001.github.io/Instance-Seg-and-Obj-Det/"/>
    <id>https://leijiezhang001.github.io/Instance-Seg-and-Obj-Det/</id>
    <published>2020-05-22T03:27:38.000Z</published>
    <updated>2020-06-17T02:16:44.008Z</updated>
    
    <content type="html"><![CDATA[<p>　　检测的发展基本上是从 Anchor-based 这种稀疏的方式到 Anchor-free 这种密集检测方案演进的。相比于 Anchor-free 这种特征层像素级别的回归与分类来检测，更密集的方式，是直接作 Instance Segmentation，然后经过聚类等后处理来得到目标框属性。越密集的检测方案，因为样本较多(一定程度增大了样本空间)，所以学习越困难，但是理论上有极高的召回率。随着一系列技术的发展，如 Focal-loss 等，密集检测性能得以超过二阶段的 Anchor-based 方案，具体描述可参考 <a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a>。<br>　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>借鉴 2D Instance Segmentation 思路，提出了一种同时作 3D Instance Segmentation 与 Detection 的方法。百度 Apollo 中的点云分割方法就是俯视图下 Instance Segmentation 然后后处理得到目标 Polygon 与 BBox 的思路，这种方法虽然后处理较为复杂，但是有超参数较少且召回率高的特点。本文算是该方法的 3D 版本(想法很自然，被人捷足先登。。)。</p><h2 id="framework">1. Framework</h2><p><img src="/Instance-Seg-and-Obj-Det/framework.png" width="100%" height="100%" title="图 1. Framework"> 　　如图 1. 所示，本方法由三部分构成：点级别的分类及回归，候选目标聚类，目标框优化。</p><ul><li><strong>点级别的分类与回归</strong><br>原始点云经过 Backbone 网络提取局部及全局特征，这里的 Backbone 网络可以是任意能提取点级别特征的网络。基于 Backbone 网络提取的特征，可进行点级别的 Semantic Segmentation 以及 Instance-aware SE(Spatial Embedding)。SE 回归的是每个点距离目标中心点的 offset，该目标的 size，以及该目标的朝向。</li><li><strong>候选目标聚类</strong><br>基于预测的 SE，将每个点的位置加上距离目标中心点的 offset，然后可通过简单的聚类算法(如 K-means)即可得到各个目标的点云集合，取 top k 个该点云集合回归的目标框属性，作下一步的目标框进一步优化。</li><li><strong>目标框优化</strong><br>基于候选目标聚类得到的目标框，提取目标点集，将其转换到该目标 Local 坐标系下，作进一步的目标框优化。</li></ul><h2 id="instance-aware-se">2. Instance-aware SE</h2><p>　　该框架的关键是 Instance-aware SE 的回归，回归量有：距离目标中心点的 offset，目标 size，目标 orientation。传统的 Instance Segmentation 做法是 Feature Embedding，将相同 Instance 的特征拉近，不同的 Instance 的特征推远，这种方法很难构造有效的 Loss 函数，而且同为车的不同 Instance，其特征已经非常接近。而本文 Spatial Embedding 中 offset 的回归量，经过聚类后处理，可以很容易的得到 Instance Segmentation 结果。<br>　　Apollo 点云分割的方案中，是在俯视图的 2D 栅格下做的，主要回归量也是这三种，不同的是，2D 栅格是离散的，所以根据 offset 找某一点的中心点时，可以迭代的进行，然后投票出中心点位置，后处理可以做的更细致。这里不做展开，有机会以后写一篇详解。</p><h2 id="loss">3. Loss</h2><p>　　Loss 项由 Semantic Segmentation，SE，3D BBox regression 组成： <span class="math display">\[ L = L _ {seg-cls}+L _ {SE}+L _ {reg} \tag{1}\]</span> Semantic Segmentation Loss 为： <span class="math display">\[ L _ {seg-cls}=-\sum _ {i=1}^C (y _ i\mathrm{log}(p _ i)(1-p _ i)^{\gamma}\alpha _ i+(1- y _ i)\mathrm{log}(1-p _ i)(p _ i)^{\gamma}(1-\alpha _ i)) \tag{2}\]</span> 其中 \(C\) 表示类别数；如果某点属于某类，那么 \(y _ i=1\)；\(p _ i\) 表示预测为第 \(i\) 类的概率；\(\gamma,\alpha\) 为超参数。<br>SE Loss 为： <span class="math display">\[ L _ {SE} = \frac{1}{N}\sum _ {i=1}^N\frac{1}{N _ c}\sum _ {i\in ins _ c}^{N _ c}(\mathcal{l} _ {offset}^i+\mathcal{l} _ {size}^i+\mathcal{l} _ {\theta}^i) \tag{3}\]</span> 其中 \(N\) 为 Instance 个数，\(N _ c\) 为内部点数，\(\mathcal{l}\) 为 L1 Smooth Loss。<br>BBox regression Loss 为 rotated 3D IOU Loss： <span class="math display">\[ L _ {reg} = 1-\mathbf{IoU}(B _ g,B _ d)\tag{4}\]</span></p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Zhou, Dingfu, et al. &quot;Joint 3D Instance Segmentation and Object Detection for Autonomous Driving.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　检测的发展基本上是从 Anchor-based 这种稀疏的方式到 Anchor-free 这种密集检测方案演进的。相比于 Anchor-free 这种特征层像素级别的回归与分类来检测，更密集的方式，是直接作 Instance Segmentation，然后经过聚类等后处
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
      <category term="Semantic Segmentation" scheme="https://leijiezhang001.github.io/tags/Semantic-Segmentation/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;SA-SSD: Structure Aware Single-stage 3D Object Detection from Point Cloud&quot;</title>
    <link href="https://leijiezhang001.github.io/SA-SSD/"/>
    <id>https://leijiezhang001.github.io/SA-SSD/</id>
    <published>2020-05-22T03:27:38.000Z</published>
    <updated>2020-05-22T10:04:17.044Z</updated>
    
    <content type="html"><![CDATA[<p>　　Voxel-based 3D Detection 相比 <a href="/Point-based-3D-Det/" title="Point-based 3D Detection">Point-based 3D Detection</a> 的缺点是特征提取不仅在 Voxel 阶段损失了一定的点云信息，而且 Voxel 化后丢失了点云之间的拓扑关系。<a href="/Point-based-3D-Det/" title="Point-based 3D Detection">Point-based 3D Detection</a> 中详细描述了几种 Point-based 方法，这种方法目前比较棘手的地方是，即使作 Inference 时，也需要作 kd-tree 搜索与采样等运算量较大的操作。那么如何榨干 Voxel-based 的性能对工业界落地就显得比较重要了，本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种单阶段的 Voxel-based 3D 检测方法，并借助了 Point 级别特征提取的相关策略，使得检测性能有较大提升。</p><h2 id="framework">1. Framework</h2><p><img src="/SA-SSD/framework.png" width="100%" height="100%" title="图 1. Framework of SA-SSD"> 　　如图 1. 所示，SA-SSD 由三部分组成：Backbone，Detection Head，Auxiliary Network。<br>　　Backbone 的输入是栅格化后的点云表示方式，文中栅格大小设定为 \(0.05m,0.05m,0.1m\)。Backbone 由一系列的 3D convolution 组成，因为需要保留空间三维位置信息，作 Voxel-to-Point 的映射。这里如果用 2D convolution 代替，那么 Auxiliary Network 估计也只能作 BridView 的分割了。<br>　　Detection Head 主体就是传统 Anchor-Free 结构，一个分支用于预测每个特征层像素点的 Confidence，另一个分支用于预测基于每个特征层像素点的 BBox 属性，如，以该点为 &quot;Anchor&quot; 的四个顶点坐标。此外，为了消除 One-Stage 方法中目标框与置信度不对齐的问题，本文引入 Part-sensitive Warping 来实现与 PSRoiAlign 类似的作用，实现两者的对齐。<br>　　Auxiliary Network 只在训练的阶段起作用，Inference 阶段不需要计算。该模块的作用是训练时通过 Voxel-to-Point 特征映射来反向传播监督 Backbone 中的 Voxel 特征学习 Point 级别的特征，包括点云的空间拓扑关系。<strong>当然 Inference 时也可以保留该分割模块，那么还可以增加点级别的特征反映射到 Voxel 的模块(Point-to-Voxel)，进一步作特征增强。</strong></p><h2 id="detachable-auxiliary-network">2. Detachable Auxiliary Network</h2><p><img src="/SA-SSD/sa.png" width="60%" height="60%" title="图 2. Structured Aware Feature Learning"> 　　如图 2. 所示，随着 Backbone 特征提取的感受野增大(特征分辨率下降)，背景点会接近目标的边缘，使得目标框大小不容易预测准确。本文提出的 Auxiliary Network，通过增加点级别分割及目标中心坐标预测任务，来监督 Backbone 特征层捕捉这种结构信息，从而达到更准确的目标检测的目的。<br>　　Auxiliary Network 的输入来自 Backbone 各个分辨率的特征层。将特征层上不为零的特征点，通过 Voxel-to-Point 反栅格化映射到三维空间，设该特征点表示为 \(\{(f _ j,p _ j):j=1,...,M\}\)，其中 \(f\) 为特征向量，\(p\) 为坐标向量。有了栅格对应的伪三维坐标点下的特征表示后，即可插值出实际点云中每个点的特征向量。设点云中点的插值特征为：\(\{(\hat{f} _ i,p _ i):i=1,...,N\}\)，采用 Inverse Distance Weighted 方法进行插值： <span class="math display">\[ \hat{f} _ i = \frac{\sum _ {j=1}^Mw _ j(p _ i)f _ j}{\sum _ {j=1}^Mw _ j(p _ i)} \tag{1}\]</span> 其中： <span class="math display">\[w _ j(p _ i)=\left\{\begin{array}{l}\frac{1}{\Vert p _ i-p _ j\Vert _ 2} &amp; \mathrm{if} p _ j\in\mathcal{N}(p _ i)\\0 &amp; \mathrm{otherwise}\end{array}\tag{2}\right.\]</span> \(\mathcal{N}(p _ i)\) 为球状区域，本文在四个分辨率下分别设定为：0.05m，0.1m，0.2m，0.4m。然后通过 cross-stage link 对各个分辨率下的点特征进行 concatenate 融合。最后通过感知机进行点云分割及目标中心点预测任务的构建。<br>　　对于点级别前景分割的任务，经过 sigmoid 函数后，应用二分类的 Focal Loss： <span class="math display">\[ \mathcal{L} _ {seg} = \frac{1}{N _ {pos}}\sum _ i^N -\alpha(1-\hat{s} _ i)^{\gamma}\mathrm{log}(\hat{s} _ i) \tag{3}\]</span> 该分割任务使得目标检测的框更加准确，如图 2.c 所示。但是还得优化其尺度与形状。<br>　　中心点的预测任务则能有效约束目标框的尺度与形状，具体的，预测的是每个属于目标的点云与中心点的相对位置(残差)。可用 Smooth-l1 来构建预测的中心点与实际中心点的 Loss。</p><h2 id="part-sensitive-warping">3. Part-sensitive Warping</h2><p><img src="/SA-SSD/psw.png" width="60%" height="60%" title="图 3. Part-sensitive Warping"> 　　One-Stage 方法都会有 Confidence 和 BBox 错位的现象，本文提出一种类似 PSROIAlign 但更有高效的 PSW 方法，具体步骤为：</p><ol type="1"><li>对于分类分支，修改为 \(K\) 个 Part-sensitive 的 cls maps，每个 map 包含目标的部分信息，比如当 \(K=4\) 时，可以理解为将目标切分为 \(2\times 2\) 部分；</li><li>对于回归分支，将每个目标框的 Feature map 划分为 \(K\) 个子区域，每个区域的中心点作为采样点；</li><li>如图 3. 所示，通过采样得到最终 cls map 的平均值。</li></ol><h2 id="experiment">4. Experiment</h2><p><img src="/SA-SSD/ablation.png" width="60%" height="60%" title="图 4. Ablation Study"> 　　如图 4. 所示，Auxiliary Network 能有效提升网络的定位精度，PSWarp 也能有效消除 Confidence 与 BBox 的错位影响。</p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> henhang, et al. &quot;Structure Aware Single-stage 3D Object Detection from Point Cloud.&quot;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Voxel-based 3D Detection 相比 &lt;a href=&quot;/Point-based-3D-Det/&quot; title=&quot;Point-based 3D Detection&quot;&gt;Point-based 3D Detection&lt;/a&gt; 的缺点是特征提取不仅在 Vo
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Boundary-Aware Dense Feature Indicator for Single-Stage 3D Object Detection from Point Clouds&quot;</title>
    <link href="https://leijiezhang001.github.io/DENFIDet/"/>
    <id>https://leijiezhang001.github.io/DENFIDet/</id>
    <published>2020-05-22T03:27:38.000Z</published>
    <updated>2020-06-12T02:22:23.113Z</updated>
    
    <content type="html"><![CDATA[<p>　　俯视图下 Voxel-based 点云 3D 目标检测一般会使用 2D 检测网络及相关策略。但是不同于图像的 2D 目标检测，俯视图下目标的点云信息基本在边缘处，所以如何准确得捕捉目标的边缘信息对特征提取的有效性非常关键。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提出了一种能捕捉目标边缘信息的网络结构，从而作更准确的目标检测。</p><h2 id="framework">1. Framework</h2><p><img src="/DENFIDet/framework.png" width="80%" height="80%" title="图 1. Framework of DENFIDet"> 　　如图 1. 所示，在传统的 One-Stage 2D/3D 检测框架下，嵌入了 DENFI 模块，该模块首先通过 DBPM 生成稠密的目标边缘 proposals，然后指导 DENFIConv 去提取更准确的目标特征，输出到检测头作 3D 目标框属性的分类与回归。</p><h2 id="denfidense-feature-indicator">2. DENFI(Dense Feature Indicator)</h2><h3 id="dbpmdense-boundary-proposal-module">2.1. DBPM(Dense Boundary Proposal Module)</h3><p><img src="/DENFIDet/DBPM.png" width="60%" height="60%" title="图 2. DBPM"> 　　DBPM 的输入为 Backbone 输出的 \(H\times W\times C\) 特征图，其由分类和回归两个分支构成：</p><ul><li>分类分支<br>分类分支经过 \(1\times 1\) 卷积输出 \(H\times W\times K\) 大小的 pixel 级别的 Score Map，其中 \(K\) 为类别数；</li><li>回归分支<br>回归分支也经过 \(1\times 1\) 卷积，输出 \(H\times W\times (4+n\times 2)\) 大小的回归量。回归量包括 \((l,t,r,b)\) 以及角度 \((\theta ^{bin}, \theta ^{res})\)(角度回归分解成了 n 个 bin 分类与 bin 内残差回归两个问题)。最终解码为描述目标边缘的信息：\((l,t,r,b,\theta)\)。</li></ul><p>　　Loss 的计算首先得区分正负样本。正负样本的划分思想与传统的差不多，主要思想是正负样本过渡区域引入 Ignore。如图 4. 所示，设 3D 真值框属性表示为 \((x,y,w,l,\theta)\)，正样本区域设计为 \((x,y,\sigma _ 1w,\sigma _ 1l,\theta)\)，定义另一缩小框 \((x,y,\sigma _ 2w,\sigma _ 2l,\theta)\)，其中 \(\sigma _ 1 &lt; \sigma _ 2\)。由此可得，灰色为正样本区域，黄色为 Ignore 区域，其它为负样本区域。<br>　　对于分类的 Loss，直接对正负样本进行 Focal Loss 计算。对于回归分支，则采用正样本的平均 Loss。回归 Loss 由目标框的 IoU Loss 以及角度 Loss 组成，角度 Loss 又由 bin 分类 Loss 加 bin 残差回归 Loss 组成。这里不做展开。<br>　　需要注意的是，分类分支只在训练的时候计算，Inference 时候只作回归分支的计算，从而得到每个像素感知到的目标边缘的信息。</p><h3 id="denficonv">2.2. DENFIConv</h3><p><img src="/DENFIDet/dconv.png" width="80%" height="80%" title="图 3. dconv"> 　　如图 3. 所示，Deformable Convolution 的思想是自动去寻找感兴趣的卷积区域。DBPM 获得每个像素点的目标边缘信息以后，自然的，接下来对像素点的卷积运算，运用可变形卷积可以捕捉更准确的目标区域信息。 <img src="/DENFIDet/DSDC.png" width="60%" height="60%" title="图 4. DSDC"> 　　如图 4. 所示，结合 Deformable Convolution 与 depth-wise separable Convolution，本文提出了 Depth-wise Separable Deformable Convolution。即将 \(3\times 3\) 的可变形卷积拆解成 \(3\times 3\) 的 Depth-wise 卷积以及 \(1\times 1\) 的可变形卷积，极大减少参数量。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Xu, Guodong, et al. &quot;Boundary-Aware Dense Feature Indicator for Single-Stage 3D Object Detection from Point Clouds.&quot; arXiv (2020): arXiv-2004.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　俯视图下 Voxel-based 点云 3D 目标检测一般会使用 2D 检测网络及相关策略。但是不同于图像的 2D 目标检测，俯视图下目标的点云信息基本在边缘处，所以如何准确得捕捉目标的边缘信息对特征提取的有效性非常关键。本文&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>非线性最小二乘</title>
    <link href="https://leijiezhang001.github.io/Non-linear-Least-Squares/"/>
    <id>https://leijiezhang001.github.io/Non-linear-Least-Squares/</id>
    <published>2020-05-18T01:19:54.000Z</published>
    <updated>2020-05-24T04:47:24.293Z</updated>
    
    <content type="html"><![CDATA[<p>　　非线性最小二乘(Non-linear Least Squares)问题应用非常广泛，尤其是在 SLAM 领域。<a href="/LOAM/" title="LOAM">LOAM</a>，，<a href="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/" title="Stereo-RCNN">Stereo-RCNN</a>，<a href="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/" title="Stereo Vision-based Semantic and Ego-motion Tracking for Autonomous Driving">Stereo Vision-based Semantic and Ego-motion Tracking for Autonomous Driving</a> 等均需要求解非线性最小二乘问题。其中 <a href="/LOAM/" title="LOAM">LOAM</a> 作为非常流行的激光 SLAM 框架，其后端是一个典型的非线性最优化问题，本文会作为实践进行代码级讲解。</p><h2 id="问题描述">1. 问题描述</h2><p>　　在前端观测-后端优化框架下，设观测数据对集合为：\(\{y _ i,z _ i\} _ {i=1}^m\)，待求解的变量参数 \(x\in\mathbb{R}^n\) 定义了观测数据对的映射关系，即 \(z _ i=h(y _ i;x)\)，由此得到有 \(m\) 个参数方程 \(F(x)=[f _ 1(x),...,f _ m(x)]^T\)，其中 \(f _ i(x) = z _ i-h(y _ i;x)\)。我们要找到最优的参数 \(x\) 来描述观测数据对之间的关系，即求解的最优化问题为： <span class="math display">\[\begin{align}\mathop{\arg\min}\limits _ x \frac{1}{2}\Vert F(x)\Vert ^2 \iff \mathop{\arg\min}\limits _ x\frac{1}{2}\sum _ i \rho _ i\left(\Vert f _ i(x)\Vert ^ 2\right)\\L\leq x \leq U\end{align}\tag{1}\]</span> 其中 \(f _ i(\cdot)\) 为 Cost Function，\(\rho _ i(\cdot)\) 为 Loss Function，即核函数，用来减少离群点对非线性最小二乘优化的影响；\(L,U\) 分别为参数 \(x\) 的上下界。当核函数 \(\rho _ i(x)=x\) 时，就是常见的非线性最小二乘问题。<br>　　《视觉 SLAM 十四讲》<a href="#1" id="1ref"><sup>[1]</sup></a>在 SLAM 的状态估计问题中，从概率学角度导出了最大似然估计求解状态的方法，并进一步引出了最小二乘问题。回过头来看，本文很多内容在《视觉 SLAM 十四讲》中已经有非常清晰的描述，可作进一步参考。</p><h2 id="问题求解">2. 问题求解</h2><p>　　根据 \(F(x)\) 求得雅克比矩阵(Jacobian)：\(J(x) \in\mathbb{R}^{m\times n}\)，即 \(J _ {ij}(x)=\frac{\partial f _ i(x)}{\partial x _ j}\)。目标函数的梯度向量为 \(g(x) = \nabla\frac{1}{2}\Vert F(x)\Vert ^ 2=J(x)^TF(x)\)。在 \(x\) 处将目标函数线性化：\(F(x+\Delta x)\approx F(x)+J(x)\Delta x\)。由此非线性最小二乘问题可转换为线性最小二乘求解残差量 \(\Delta x\) 来近似求解： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x}\frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^ 2\tag{2}\]</span> 根据如何控制 \(\Delta x\) 的大小，非线性优化算法可分为两大类：</p><ul><li>Line Search<ul><li>Gradient Descent</li><li>Gaussian-Newton</li></ul></li><li>Trust Region<ul><li>Levenberg-Marquardt</li><li>Dogleg</li><li>Inner Iterations</li><li>Non-monotonic Steps</li></ul></li></ul><p>Line Search 首先确定迭代方向，然后最小化 \(\Vert f(x+\alpha \Delta x)\Vert ^2\) 确定迭代步长；Trust Region 则划分一个局部区域，在该区域内求解最优值，然后根据近似程度，扩大或缩减该局部区域范围。Trust Region 相比 Linear Search，数值迭代会更加稳定。这里介绍几种有代表性的方法：属于 Line Search 的梯度下降法，高斯牛顿法，以及属于 Trust Region 的 LM 法。</p><h3 id="梯度下降法">2.1. 梯度下降法</h3><p>　　将目标函数式(1)在 \(x\) 附近泰勒展开： <span class="math display">\[ \Vert F(x+\Delta x)\Vert ^2 \approx \Vert F(x)\Vert ^2 + J(x)\Delta x+\frac{1}{2}\Delta x^TH\Delta x \tag{3}\]</span> 其中 \(H\) 是二阶导数(Hessian 矩阵)。<br>　　如果保留一阶导数，那么增量的解就为： <span class="math display">\[\Delta x = -\lambda J^T(x) \tag{4}\]</span> 其中 \(\lambda\) 为步长，可预先由相关策略设定。<br>　　如果保留二阶导数，那么增量方程为： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x} \Vert F(x)\Vert ^2+J(x)\Delta x+\frac{1}{2}\Delta x^TH\Delta x\tag{5}\]</span> 对 \(\Delta x\) 求导即可求解增量的解为： <span class="math display">\[\Delta x = -H^{-1}J^T \tag{6}\]</span> 　　一阶梯度法又称为最速下降法，二阶梯度法又称为牛顿法。一阶和二阶法都是将函数在当前值下泰勒展开，然后线性得求解增量值。最速下降法过于贪心，容易走出锯齿路线，反而增加迭代步骤。牛顿法需要计算 \(H\) 矩阵，计算量较大且困难。</p><h3 id="高斯牛顿法">2.2. 高斯牛顿法</h3><p>　　 将式(2)对 \(\Delta x\) 求导并令其为零，可得： <span class="math display">\[\begin{align}&amp;J(x)^TJ(x)\Delta x=-J(x)^TF(x)\\\iff &amp; H\Delta x=g\end{align}\tag{7}\]</span> 相比牛顿法，高斯牛顿法不用计算 \(H\) 矩阵，直接用 \(J^TJ\) 来近似，所以节省了计算量。但是高斯牛顿法要求 \(H\) 矩阵是可逆且正定的，而实际计算的 \(J^TJ\) 是半正定的，所以 \(J^TJ\) 会出现奇异或病态的情况，此时增量的稳定性就会变差，导致迭代发散。另一方面，增量较大时，目标近似函数式(2)就会产生较大的误差，也会导致迭代发散。这是高斯牛顿法的缺陷。高斯牛顿法的步骤为：</p><ol type="1"><li>根据式 (7) 求解迭代步长 \(\Delta x\)；</li><li>变量迭代：\(x ^ * \leftarrow x+\Delta x\)；</li><li>如果 \(\Vert F(x ^ * )-F(x)\Vert &lt; \epsilon\)，则收敛，退出迭代，否则重复步骤 1.；</li></ol><p>高斯牛顿法简单的将 \(\alpha\) 置为 1，而其它 Line Search 方法会最小化 \(\Vert f(x+\alpha \Delta x)\Vert ^2\) 来确定 \(\alpha\) 值。</p><h3 id="lm-法">2.3. LM 法</h3><p>　　Line Search 依赖线性化近似有较高的拟合度，但是有时候线性近似效果较差，导致迭代不稳定；Region Trust 就是解决了这种问题。高斯牛顿法中采用的近似二阶泰勒展开只在该点附近有较好的近似结果，对 \(\Delta x\) 添加一个信赖域区域，就变为 Trust Region 方法。其最优化问题转换为： <span class="math display">\[\begin{align}\mathop{\arg\min}\limits _ x \frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^2 \\\Vert D(x)\Delta x\Vert ^2 \leq \mu\\L\leq x \leq U\\\end{align}\tag{8}\]</span> 用 Lagrange 乘子将其转换为无约束优化问题： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x}\frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^ 2+\frac{1}{\mu}\Vert D(x)\Delta x\Vert ^2 \tag{9}\]</span> 其中 Levenberg 提出的方法中 \(D=I\)，相当于把 \(\Delta x\) 约束在球中；Marquart 提出的方法中将 \(D\) 取为非负数对角阵，通常为 \(J(x)^TJ(x)\) 的对角元素平方根。<br>　　对于信赖域区域 \(\mu\) 的定义，一个比较好的方式是根据近似模型与实际函数之间的差异来确定这个范围：如果差异小，那么增大信赖域；反之减小信赖域。因此，考虑： <span class="math display">\[\rho = \frac{\Vert F(x+\Delta x)\Vert ^2-\Vert F(x)\Vert ^2}{\Vert J(x)\Delta x+F(x)\Vert ^2-\Vert F(x)\Vert ^2} \tag{10}\]</span> 　　 将式(9)对 \(\Delta x\) 求导并令其为零，可得： <span class="math display">\[\begin{align}&amp;\left(J(x)^TJ(x)+\frac{2}{\mu}D^T(x)D(x)\right)\Delta x=-J(x)^TF(x)\\\iff &amp; (H+\lambda D^TD)\Delta x=g\end{align}\tag{11}\]</span> 当 \(\lambda\) 较小时，接近于高斯牛顿法；当 \(\lambda\) 较大时，接近于最速下降法。LM 法的步骤为：</p><ol type="1"><li>根据式(11)求解迭代步长 \(\Delta x\);</li><li>根据式(10)求解 \(\rho\);</li><li>若 \(\rho &gt; \eta _ 1\)，则 \(\mu = 2\mu\);</li><li>若 \(\rho &lt; \eta _ 2\)，则 \(\mu = 0.5\mu\);</li><li>若 \(\rho &gt; \epsilon\)，则 \(x ^ * \leftarrow x+\Delta x\)；</li><li>如果满足收敛条件，则结束，否则继续步骤1.；</li></ol><h2 id="ceres-实践">3. Ceres 实践</h2><p>　　Ceres 是谷歌开发的一个用于非线性优化的库，使用 Ceres 库有以下几个步骤：</p><ul><li>构建 Cost Function，式(1)中的 \(\rho _ i\left(\Vert f _ i(x)\Vert ^ 2\right)\) 即为代码中需要增加的 ResidualBlock；</li><li>累加的 Cost Function 构成最终的 Loss Function 目标函数；</li><li>配置求解器参数并求解问题；</li></ul><h3 id="例子-曲线拟合">3.1. 例子-曲线拟合</h3><p>　　以下代码为拟合曲线参数的简单例子：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy from http://zhaoxuhui.top/blog/2018/04/04/ceres&amp;ls.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ceres;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector,用于存放x、y的观测数据</span></span><br><span class="line"><span class="comment">//待估计函数为y=3.5x^3+1.6x^2+0.3x+7.8</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; xs;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义CostFunctor结构体用于描述代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span>&#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">double</span> x_guan,y_guan;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数，用已知的x、y数据对其赋值</span></span><br><span class="line">  CostFunctor(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span><br><span class="line">  &#123;</span><br><span class="line">    x_guan = x;</span><br><span class="line">    y_guan = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载括号运算符，两个参数分别是估计的参数和由该参数计算得到的残差</span></span><br><span class="line">  <span class="comment">//注意这里的const，一个都不能省略，否则就会报错</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> params,T* residual)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>]=y_guan-(params[<span class="number">0</span>]*x_guan*x_guan*x_guan+params[<span class="number">1</span>]*x_guan*x_guan+params[<span class="number">2</span>]*x_guan+params[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成实验数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  RNG rng;</span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">3.5</span>*x*x*x+<span class="number">1.6</span>*x*x+<span class="number">0.3</span>*x+<span class="number">7.8</span>;</span><br><span class="line">    xs.push_back(x);</span><br><span class="line">    ys.push_back(y+rng.gaussian(w_sigma));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xs.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;xs[i]&lt;&lt;<span class="string">" y:"</span>&lt;&lt;ys[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单描述我们优化的目的就是为了使我们估计参数算出的y'和实际观测的y的差值之和最小</span></span><br><span class="line"><span class="comment">//所以代价函数(CostFunction)就是y'-y，其对应每一组观测值与估计值的残差。</span></span><br><span class="line"><span class="comment">//由于我们优化的是残差之和，因此需要把代价函数全部加起来，使这个函数最小，而不是单独的使某一个残差最小</span></span><br><span class="line"><span class="comment">//默认情况下，我们认为各组的残差是等权的，也就是核函数系数为1。</span></span><br><span class="line"><span class="comment">//但有时可能会出现粗差等情况，有可能不等权，但这里不考虑。</span></span><br><span class="line"><span class="comment">//这个求和以后的函数便是我们优化的目标函数</span></span><br><span class="line"><span class="comment">//通过不断调整我们的参数值，使这个目标函数最终达到最小，即认为优化完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  generateData();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建一个长度为4的double数组用于存放参数</span></span><br><span class="line">  <span class="keyword">double</span> params[<span class="number">4</span>]=&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一步，创建Problem对象，并对每一组观测数据添加ResidualBlock</span></span><br><span class="line">  <span class="comment">//由于每一组观测点都会得到一个残差，而我们的目的是最小化所有残差的和</span></span><br><span class="line">  <span class="comment">//所以采用for循环依次把每个残差都添加进来</span></span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xs.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//利用我们之前写的结构体、仿函数，创建代价函数对象，注意初始化的方式</span></span><br><span class="line">    <span class="comment">//尖括号中的参数分别为误差类型，输出维度(因变量个数)，输入维度(待估计参数的个数)</span></span><br><span class="line">    CostFunction* cost_function = <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor,<span class="number">1</span>,<span class="number">4</span>&gt;(<span class="keyword">new</span> CostFunctor(xs[i],ys[i]));</span><br><span class="line">    <span class="comment">//三个参数分别为代价函数、核函数和待估参数</span></span><br><span class="line">    problem.AddResidualBlock(cost_function,<span class="literal">NULL</span>,params);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二步，配置Solver</span></span><br><span class="line">  Solver::Options options;</span><br><span class="line">  <span class="comment">//配置增量方程的解法</span></span><br><span class="line">  options.linear_solver_type=ceres::DENSE_QR;</span><br><span class="line">  <span class="comment">//是否输出到cout</span></span><br><span class="line">  options.minimizer_progress_to_stdout=<span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第三步，创建Summary对象用于输出迭代结果</span></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第四步，执行求解</span></span><br><span class="line">  Solve(options,&amp;problem,&amp;summary);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第五步，输出求解结果</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;summary.BriefReport()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p0:"</span>&lt;&lt;params[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1:"</span>&lt;&lt;params[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2:"</span>&lt;&lt;params[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p3:"</span>&lt;&lt;params[<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例子-loam">3.2. 例子-LOAM</h3><p>　　<a href="/LOAM/" title="LOAM">LOAM</a> 前端提取线和面特征，后端最小化线和面的匹配误差。其源码实现了整个最优化过程，ALOAM<a href="#2" id="2ref"><sup>[2]</sup></a> 将后端代码用 Ceres 实现，这里对其作理解与分析。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LidarEdgeFactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LidarEdgeFactor(Eigen::Vector3d curr_point_, Eigen::Vector3d last_point_a_,</span><br><span class="line">Eigen::Vector3d last_point_b_, <span class="keyword">double</span> s_)</span><br><span class="line">: curr_point(curr_point_), last_point_a(last_point_a_), last_point_b(last_point_b_), s(s_) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *q, <span class="keyword">const</span> T *t, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; cp&#123;T(curr_point.x()), T(curr_point.y()), T(curr_point.z())&#125;;</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpa&#123;T(last_point_a.x()), T(last_point_a.y()), T(last_point_a.z())&#125;;</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpb&#123;T(last_point_b.x()), T(last_point_b.y()), T(last_point_b.z())&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[3], T(s) * q[0], T(s) * q[1], T(s) * q[2]&#125;;</span></span><br><span class="line">Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[<span class="number">3</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], q[<span class="number">2</span>]&#125;;</span><br><span class="line">Eigen::Quaternion&lt;T&gt; q_identity&#123;T(<span class="number">1</span>), T(<span class="number">0</span>), T(<span class="number">0</span>), T(<span class="number">0</span>)&#125;;</span><br><span class="line">q_last_curr = q_identity.slerp(T(s), q_last_curr);</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; t_last_curr&#123;T(s) * t[<span class="number">0</span>], T(s) * t[<span class="number">1</span>], T(s) * t[<span class="number">2</span>]&#125;;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lp;</span><br><span class="line">lp = q_last_curr * cp + t_last_curr;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; nu = (lp - lpa).cross(lp - lpb);</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; de = lpa - lpb;</span><br><span class="line"></span><br><span class="line">residual[<span class="number">0</span>] = nu.x() / de.norm();</span><br><span class="line">residual[<span class="number">1</span>] = nu.y() / de.norm();</span><br><span class="line">residual[<span class="number">2</span>] = nu.z() / de.norm();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ceres::<span class="function">CostFunction *<span class="title">Create</span><span class="params">(<span class="keyword">const</span> Eigen::Vector3d curr_point_, <span class="keyword">const</span> Eigen::Vector3d last_point_a_,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> Eigen::Vector3d last_point_b_, <span class="keyword">const</span> <span class="keyword">double</span> s_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;</span><br><span class="line">LidarEdgeFactor, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>&gt;(</span><br><span class="line"><span class="keyword">new</span> LidarEdgeFactor(curr_point_, last_point_a_, last_point_b_, s_)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Eigen::Vector3d curr_point, last_point_a, last_point_b;</span><br><span class="line"><span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>　　对于 Point2Line 误差，为了衡量该线特征上的点是否在地图对应的线特征上，在地图线特征上采样两个点，加上该点，组成两个向量，向量叉乘即可描述匹配误差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LidarPlaneFactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LidarPlaneFactor(Eigen::Vector3d curr_point_, Eigen::Vector3d last_point_j_,</span><br><span class="line"> Eigen::Vector3d last_point_l_, Eigen::Vector3d last_point_m_, <span class="keyword">double</span> s_)</span><br><span class="line">: curr_point(curr_point_), last_point_j(last_point_j_), last_point_l(last_point_l_),</span><br><span class="line">  last_point_m(last_point_m_), s(s_)</span><br><span class="line">&#123;</span><br><span class="line">ljm_norm = (last_point_j - last_point_l).cross(last_point_j - last_point_m);</span><br><span class="line">ljm_norm.normalize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *q, <span class="keyword">const</span> T *t, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; cp&#123;T(curr_point.x()), T(curr_point.y()), T(curr_point.z())&#125;;</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpj&#123;T(last_point_j.x()), T(last_point_j.y()), T(last_point_j.z())&#125;;</span><br><span class="line"><span class="comment">//Eigen::Matrix&lt;T, 3, 1&gt; lpl&#123;T(last_point_l.x()), T(last_point_l.y()), T(last_point_l.z())&#125;;</span></span><br><span class="line"><span class="comment">//Eigen::Matrix&lt;T, 3, 1&gt; lpm&#123;T(last_point_m.x()), T(last_point_m.y()), T(last_point_m.z())&#125;;</span></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; ljm&#123;T(ljm_norm.x()), T(ljm_norm.y()), T(ljm_norm.z())&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[3], T(s) * q[0], T(s) * q[1], T(s) * q[2]&#125;;</span></span><br><span class="line">Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[<span class="number">3</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], q[<span class="number">2</span>]&#125;;</span><br><span class="line">Eigen::Quaternion&lt;T&gt; q_identity&#123;T(<span class="number">1</span>), T(<span class="number">0</span>), T(<span class="number">0</span>), T(<span class="number">0</span>)&#125;;</span><br><span class="line">q_last_curr = q_identity.slerp(T(s), q_last_curr);</span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; t_last_curr&#123;T(s) * t[<span class="number">0</span>], T(s) * t[<span class="number">1</span>], T(s) * t[<span class="number">2</span>]&#125;;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lp;</span><br><span class="line">lp = q_last_curr * cp + t_last_curr;</span><br><span class="line"></span><br><span class="line">residual[<span class="number">0</span>] = (lp - lpj).dot(ljm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ceres::<span class="function">CostFunction *<span class="title">Create</span><span class="params">(<span class="keyword">const</span> Eigen::Vector3d curr_point_, <span class="keyword">const</span> Eigen::Vector3d last_point_j_,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> Eigen::Vector3d last_point_l_, <span class="keyword">const</span> Eigen::Vector3d last_point_m_,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">const</span> <span class="keyword">double</span> s_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;</span><br><span class="line">LidarPlaneFactor, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&gt;(</span><br><span class="line"><span class="keyword">new</span> LidarPlaneFactor(curr_point_, last_point_j_, last_point_l_, last_point_m_, s_)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Eigen::Vector3d curr_point, last_point_j, last_point_l, last_point_m;</span><br><span class="line">Eigen::Vector3d ljm_norm;</span><br><span class="line"><span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　对于 Point2Plane 误差，为了衡量该面特征上的点是否在地图对应的面特征上，在地图面特征上采样一个点，加上该点，组成向量，然后点乘面的法向量即可衡量匹配误差。</p><h3 id="例子-ba">3.3. 例子-BA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy from https://www.jianshu.com/p/3df0c2e02b4c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/rotation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read a Bundle Adjustment in the Large dataset.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BALProblem</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~BALProblem() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] point_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] camera_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] observations_;</span><br><span class="line">    <span class="keyword">delete</span>[] parameters_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">num_observations</span><span class="params">()</span>       <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_observations_;               &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">double</span>* <span class="title">observations</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> observations_;                   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_cameras</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> parameters_;                     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_points</span><span class="params">()</span>           </span>&#123; <span class="keyword">return</span> parameters_  + <span class="number">9</span> * num_cameras_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_camera_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_cameras() + camera_index_[i] * <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_point_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_points() + point_index_[i] * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fptr = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_cameras_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_points_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_observations_);</span><br><span class="line"></span><br><span class="line">    point_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    camera_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    observations_ = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">2</span> * num_observations_];</span><br><span class="line"></span><br><span class="line">    num_parameters_ = <span class="number">9</span> * num_cameras_ + <span class="number">3</span> * num_points_;</span><br><span class="line">    parameters_ = <span class="keyword">new</span> <span class="keyword">double</span>[num_parameters_];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_observations_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, camera_index_ + i);</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, point_index_ + i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        FscanfOrDie(fptr, <span class="string">"%lf"</span>, observations_ + <span class="number">2</span>*i + j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_parameters_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%lf"</span>, parameters_ + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FscanfOrDie</span><span class="params">(FILE *fptr, <span class="keyword">const</span> <span class="keyword">char</span> *format, T *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_scanned = <span class="built_in">fscanf</span>(fptr, format, value);</span><br><span class="line">    <span class="keyword">if</span> (num_scanned != <span class="number">1</span>) &#123;</span><br><span class="line">      LOG(FATAL) &lt;&lt; <span class="string">"Invalid UW data file."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num_cameras_;</span><br><span class="line">  <span class="keyword">int</span> num_points_;</span><br><span class="line">  <span class="keyword">int</span> num_observations_;</span><br><span class="line">  <span class="keyword">int</span> num_parameters_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* point_index_;</span><br><span class="line">  <span class="keyword">int</span>* camera_index_;</span><br><span class="line">  <span class="keyword">double</span>* observations_;</span><br><span class="line">  <span class="keyword">double</span>* parameters_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Templated pinhole camera model for used with Ceres.  The camera is</span></span><br><span class="line"><span class="comment">// parameterized using 9 parameters: 3 for rotation, 3 for translation, 1 for</span></span><br><span class="line"><span class="comment">// focal length and 2 for radial distortion. The principal point is not modeled</span></span><br><span class="line"><span class="comment">// (i.e. it is assumed be located at the image center).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnavelyReprojectionError</span> &#123;</span></span><br><span class="line">  SnavelyReprojectionError(<span class="keyword">double</span> observed_x, <span class="keyword">double</span> observed_y)</span><br><span class="line">      : observed_x(observed_x), observed_y(observed_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> point,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// camera[0,1,2] are the angle-axis rotation.</span></span><br><span class="line">    T p[<span class="number">3</span>];</span><br><span class="line">    ceres::AngleAxisRotatePoint(camera, point, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera[3,4,5] are the translation.</span></span><br><span class="line">    p[<span class="number">0</span>] += camera[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">1</span>] += camera[<span class="number">4</span>];</span><br><span class="line">    p[<span class="number">2</span>] += camera[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the center of distortion. The sign change comes from</span></span><br><span class="line">    <span class="comment">// the camera model that Noah Snavely's Bundler assumes, whereby</span></span><br><span class="line">    <span class="comment">// the camera coordinate system has a negative z axis.</span></span><br><span class="line">    T xp = - p[<span class="number">0</span>] / p[<span class="number">2</span>];</span><br><span class="line">    T yp = - p[<span class="number">1</span>] / p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply second and fourth order radial distortion.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; l1 = camera[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">const</span> T&amp; l2 = camera[<span class="number">8</span>];</span><br><span class="line">    T r2 = xp*xp + yp*yp;</span><br><span class="line">    T distortion = <span class="number">1.0</span> + r2  * (l1 + l2  * r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute final projected point position.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; focal = camera[<span class="number">6</span>];</span><br><span class="line">    T predicted_x = focal * distortion * xp;</span><br><span class="line">    T predicted_y = focal * distortion * yp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The error is the difference between the predicted and observed position.</span></span><br><span class="line">    residuals[<span class="number">0</span>] = predicted_x - observed_x;</span><br><span class="line">    residuals[<span class="number">1</span>] = predicted_y - observed_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factory to hide the construction of the CostFunction object from</span></span><br><span class="line">  <span class="comment">// the client code.</span></span><br><span class="line">  <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> observed_x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> <span class="keyword">double</span> observed_y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;SnavelyReprojectionError, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                <span class="keyword">new</span> SnavelyReprojectionError(observed_x, observed_y)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> observed_x;</span><br><span class="line">  <span class="keyword">double</span> observed_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"usage: simple_bundle_adjuster &lt;bal_problem&gt;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BALProblem bal_problem;</span><br><span class="line">  <span class="keyword">if</span> (!bal_problem.LoadFile(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: unable to open file "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem.observations();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create residuals for each observation in the bundle adjustment problem. The</span></span><br><span class="line">  <span class="comment">// parameters for cameras and points are added automatically.</span></span><br><span class="line">  ceres::Problem problem;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem.num_observations(); ++i) &#123;</span><br><span class="line">    <span class="comment">// Each Residual block takes a point and a camera as input and outputs a 2</span></span><br><span class="line">    <span class="comment">// dimensional residual. Internally, the cost function stores the observed</span></span><br><span class="line">    <span class="comment">// image location and compares the reprojection against the observation.</span></span><br><span class="line"></span><br><span class="line">    ceres::CostFunction* cost_function =</span><br><span class="line">        SnavelyReprojectionError::Create(observations[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">                                         observations[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    problem.AddResidualBlock(cost_function,</span><br><span class="line">                             <span class="literal">NULL</span> <span class="comment">/* squared loss */</span>,</span><br><span class="line">                             bal_problem.mutable_camera_for_observation(i),</span><br><span class="line">                             bal_problem.mutable_point_for_observation(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make Ceres automatically detect the bundle structure. Note that the</span></span><br><span class="line">  <span class="comment">// standard solver, SPARSE_NORMAL_CHOLESKY, also works fine but it is slower</span></span><br><span class="line">  <span class="comment">// for standard bundle adjustment problems.</span></span><br><span class="line">  ceres::Solver::Options options;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ceres::Solver::Summary summary;</span><br><span class="line">  ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里使用了 Bundle Adjustment in the Large<a href="#3" id="3ref"><sup>[3]</sup></a> 数据集，观测量为图像坐标系下路标(特征)的像素坐标系，待优化的参数为各路标的 3D 坐标以及相机内外参，这里相机内外参有 9 个，其中位置及姿态 6 个，畸变系数 2 个，焦距 1 个。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> 高翔. 视觉 SLAM 十四讲: 从理论到实践. 电子工业出版社, 2017.<br><a id="2" href="#2ref">[2]</a> https://github.com/HKUST-Aerial-Robotics/A-LOAM<br><a id="3" href="#3ref">[3]</a> http://grail.cs.washington.edu/projects/bal/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　非线性最小二乘(Non-linear Least Squares)问题应用非常广泛，尤其是在 SLAM 领域。&lt;a href=&quot;/LOAM/&quot; title=&quot;LOAM&quot;&gt;LOAM&lt;/a&gt;，，&lt;a href=&quot;/[paper_reading]-Stereo-RCNN-ba
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="Optimization" scheme="https://leijiezhang001.github.io/tags/Optimization/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建一个 ADAS 产品</title>
    <link href="https://leijiezhang001.github.io/How-to-Build-An-ADAS/"/>
    <id>https://leijiezhang001.github.io/How-to-Build-An-ADAS/</id>
    <published>2020-05-07T01:36:23.000Z</published>
    <updated>2020-05-29T01:34:19.233Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文介绍了基于视觉的 ADAS 产品构建方法，全文 6K 字 12 图，请输入密码查看：" />    <label for="pass">本文介绍了基于视觉的 ADAS 产品构建方法，全文 6K 字 12 图，请输入密码查看：</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      从零到一构建视觉 ADAS 产品。
    
    </summary>
    
      <category term="Autonomous Driving System" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/"/>
    
      <category term="ADAS" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/ADAS/"/>
    
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="ADAS" scheme="https://leijiezhang001.github.io/tags/ADAS/"/>
    
  </entry>
  
  <entry>
    <title>OctoMap</title>
    <link href="https://leijiezhang001.github.io/OctoMap/"/>
    <id>https://leijiezhang001.github.io/OctoMap/</id>
    <published>2020-04-23T02:23:05.000Z</published>
    <updated>2020-04-27T02:31:31.376Z</updated>
    
    <content type="html"><![CDATA[<p>　　地图是机器人领域非常重要的模块，也可以认为是自动驾驶保障安全的基础模块。根据存储建模类型，地图可分为拓扑地图，栅格地图，点云地图等。<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 就是一种能在线检测静态障碍物的栅格地图。自动驾驶领域，地图的用处有：</p><ul><li><strong>高精度定位</strong>，一般是 3D 栅格地图，但是栅格中近似存储点云原始信息；</li><li><strong>路径规划</strong>，不同规划算法依赖不同地图，自动驾驶中比较靠谱又简单的规划算法一般依赖拓扑地图，俗称高精度语义地图，描述一些车道线等路面拓扑关系；而在室内或低速无道路信息场景，则会用如 \(A ^ * \) 算法在栅格地图上进行路径规划；</li><li><strong>辅助感知检测未定义类别的障碍物</strong>，有人称之为静态地图，一般是 2.5D 栅格地图，图层可以自定义一些语义信息；</li></ul><p>下游不同模块对不同存储方式的利用效率是不同的，所以需要针对不同下游任务设计不同地图建模方式。本文<a href="#1" id="1ref"><sup>[1]</sup></a>介绍了一种基于八叉树的栅格地图建模方法。<br>　　对于机器人而言，类似 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 能建模 FREE，OCCUPIED，UNMAPPED AREAS 的地图是信息量比较丰富的，但是 Grid-Mapping 是 2D 的。这里对 3D 地图有以下要求：</p><ul><li><strong>Probabilistic Representation</strong><br>测量都会有不确定性，这种不确定性需要用概率表征出来；另外多传感器融合也需要基于概率的表示；</li><li><strong>Modeling of Unmapped Areas</strong><br>对机器人导航而言，显式得表示哪些区域是观测未知的也非常重要；</li><li><strong>Efficiency</strong><br>地图构建与存储需要非常高效，一般而言，地图的内存消耗会是瓶颈；</li></ul><p><img src="/OctoMap/maps.png" width="90%" height="90%" title="图 1. Different Representations of Maps"> 　　如图 1. 所示，原始点云地图信息量丰富，但是不能结构化存储；Elevation Maps 与 Multi-level Surface Maps 虽然高效，但是不能表征未观测的区域信息。OctoMap 可以认为是 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 的 3D 版本，信息量丰富且高效。</p><h2 id="octomap-mapping-framework">1. OctoMap Mapping Framework</h2><h3 id="octrees">1.1. Octrees</h3><p><img src="/OctoMap/OctoMap.png" width="40%" height="40%" title="图 2. 八叉树地图存储"> 　　如图 2. 所示，八叉树是将空间递归得等分成八份(QuadTree 四叉树则等分为四份)，每个节点可以存储 Occupied，Free，Unknown 信息(Occupied 概率即可)。此外，如果子节点的状态都一样，那么可以进行剪枝，只保留大节点低分辨率的 Voxel，达到紧凑存储的目的。<br>　　时间复杂度上，对于有 \(n\) 个节点，深度为 \(d\) 的八叉树，那么单次查询的时间复杂度为 \(\mathcal{O}(d)=\mathcal{O}(\mathrm{log}\,n)\)；遍历节点的时间复杂度为 \(\mathcal{O}(n)\)。\(d = 16, r = 1cm\)，可以覆盖 \((655.36m)^3\)的区域。</p><h3 id="probabilistic-sensor-fusion">1.2. Probabilistic Sensor Fusion</h3><p>　　时序概率融合也是基于贝叶斯滤波，详见 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a>，只不过这里是 3D Mapping，作 Raycasting 的时候采用 <a href="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/" title="What You See is What You Get">What You See is What You Get</a> 中提到的 Fast Voxel Traversal 算法。实际应用中，一般都会采用上下界限制概率值，这种限制也能提高八叉树的剪枝率。</p><h3 id="multi-resolution-queries">1.3. Multi-Resolution Queries</h3><p>　　由于八叉树的特性，OctoMap 支持低于最高分辨率的 Voxel 概率查询，即父节点是子节点的平均概率，或是子节点的最大概率: <span class="math display">\[\bar{l}(n)=\frac{1}{8}\sum _ {i=1}^8 L (n _ i)\\\hat{l}(n)=\max\limits _ iL(n _ i)\tag{1}\]</span> 其中 \(l\) 是测量模型下概率的 log-odds 值。</p><h2 id="implementation-details-statics">2. Implementation Details &amp; Statics</h2><h3 id="memory-efficient-node-map-file-generation">2.1. Memory-Efficient Node &amp; Map File Generation</h3><p><img src="/OctoMap/save.png" width="60%" height="60%" title="图 3. Node Memory Consumption and Serialization"> 　　如图 3. 左图所示，每个节点只分配一个 float 型的数据存储以及指向子节点地址数组的地址指针(而不是直接包含子节点地址的指针)，只有存在子节点时，才会分配子节点的地址数组空间。由此在 32-bit 系统中(4 字节对齐)，每个父节点需要 40B，子节点需要 8B；在 64-bit 系统中(8 字节对齐)，每个父节点需要 80B(\(4+9\times 8\))，子节点需要 16B(\(4+8)\)。<br>　　地图存储需要在信息量损失最小的情况下进行压缩。如图 3. 右图所示，存储序列化时，每个叶子节点总共需要 4B 概率值，不需要状态量；每个父节点总共需要 2B，表示 8 个子节点的 2bit 状态量(貌似与论文有出入，其不是最优的压缩)。在这种压缩方式下，大范围地图的存储大小一般也能接受。根据存储的地图重建地图时，只需要知道坐标原点即可。</p><h3 id="accessing-data-memory-consumption">2.2. Accessing Data &amp; Memory Consumption</h3><p><img src="/OctoMap/memusage1.png" width="60%" height="60%" title="图 4. Memory Usage VS. Scan Num."> 　　Freiburg 建图大小为 \((202\times 167\times 28) m^3\)，如图 4. 所示，随着点云扫描区域扩大，OctoMap 表示方式能有效降低建图大小。 <img src="/OctoMap/memusage2.png" width="60%" height="60%" title="图 5. Memory Usage VS. Resolution"> 　　图 5. 则说明建图大小与分辨率的关系。 <img src="/OctoMap/inserttime.png" width="60%" height="60%" title="图 6. Insert Date Time VS. Resolution"> <img src="/OctoMap/traversetime.png" width="60%" height="60%" title="图 7. Traverse Data Time VS. Depth"> 　　图 6. 显示了往图中插入一个节点所需时间，1000 个节点在毫秒级；图 7. 显示了遍历所有节点所需的时间，基本也在毫秒级。 <img src="/OctoMap/compress.png" width="60%" height="60%" title="图 8. Compression Ratio"> 　　通过限制概率上下界，可以剪枝压缩图，用 KL-diverge 来评估压缩前后图的分布相似性，图 8. 显示了压缩比与网络大小及相似性的关系。</p><h3 id="some-strategies">2.3. Some Strategies</h3><p><img src="/OctoMap/case.png" width="60%" height="60%" title="图 9. Corner Case Handle"> 　　如图 9. 所示，前后帧位姿的抖动，会导致 Occupied 持续观测的不稳定，所以需要一些领域约束策略来保证 Occupied 的稳定观测。这种类似的策略在 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 工程实现中也需要采用，因为实际的 Pose 肯定会有噪声，导致同一目标的栅格前后有一定概率不能完全命中。</p><h2 id="rethinking">3. ReThinking</h2><p>　　对于自动驾驶来说，高度方向的范围不需要很大，甚至四叉树足矣，如果采用八叉树，那么需要将高度方向的分辨率降低，从而更加紧凑的构建地图。<br>　　此外自动驾驶肯定是需要大范围建图的，如平方千公里级别。所以切片式的地图存储与查询就显得尤为重要，换句话说，需要动态得载入局部地图，这就有两种思路：</p><ul><li>动态载入完全局部地图<br>要求前后局部地图有一定的重叠，通过索引式的存储可以不存储重叠区域的地图信息；</li><li>动态载入部分局部地图<br>随着机器人本体的运动，实时动态载入前方更远处的地图，丢掉后方远处的历史地图。这对在线地图结构的灵活性要求比较高，如果基于八叉树，那么需要作片区域剪枝及插入的操作，效率不一定高；</li></ul><p>　　在自动驾驶领域，目前用于高精度定位的栅格地图与用于 PNC 规划控制的拓扑地图(高精地图)已经比较成熟；而用于环境感知的静态语义地图还没形成大范围的共识。不管从工程实现效果及效率上，还是语义信息描述定义上，还需作很多探索与实践。比如，可以定义最底层的语义信息：地面高度，此外也可以把车道线信息打到栅格图层中去(但是可能加大对 PNC 的搜索计算量)，等等。所以可能最优的存储查询方式并不是八叉树，<strong>可能还是栅格化后并对每个栅格哈希化，牺牲一定的内存空间，然后作 \(O(1)\) 的快速插入与查询</strong>。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Hornung, Armin, et al. &quot;OctoMap: An efficient probabilistic 3D mapping framework based on octrees.&quot; Autonomous robots 34.3 (2013): 189-206.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　地图是机器人领域非常重要的模块，也可以认为是自动驾驶保障安全的基础模块。根据存储建模类型，地图可分为拓扑地图，栅格地图，点云地图等。&lt;a href=&quot;/Grid-Mapping/&quot; title=&quot;Grid-Mapping&quot;&gt;Grid-Mapping&lt;/a&gt; 就是一种能在
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Mapping" scheme="https://leijiezhang001.github.io/tags/Mapping/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;What You See is What You Get, Exploiting Visibility for 3D Object Detection&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/"/>
    <id>https://leijiezhang001.github.io/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/</id>
    <published>2020-04-22T01:19:59.000Z</published>
    <updated>2020-04-23T02:34:12.937Z</updated>
    
    <content type="html"><![CDATA[<p>　　Bird-View 3D Detection 都是将点云离散化到 Voxel，有点的 Voxel 提取区域特征，无点的 Voxel 则置为空。而 LiDAR 的测量特性其实还包含更多的信息，<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 中较详细的阐述了 LiDAR 的测量模型，每个栅格可以标记为三个状态：UNKNOWN，FREE，OCCUPIED。传统的 Bird-View 3D Detection 没有显式得提取 UNKNOW 与 FREE 的信息(即没有提取 Visibility 信息)，而 UNKNOW 与 FREE 对数据增广及检测效果非常重要。 <img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/visibility.png" width="90%" height="90%" title="图 1. Visibility or Freespace from LiDAR"> 　　如图 1. 所示，左图是传统的点云表示方式，无法区分红色区域是否有车，而右图则非常容易得区分哪个区域不可能有车，哪个区域可能有车。所以本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了显式提取点云 UNKNOWN 与 FREE 信息来辅助数据增广与提高目标检测精度的方法。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/framework.png" width="90%" height="90%" title="图 2. Framework"> 　　如图 2. 所示，本文的 3D 检测框架与传统的差不多，是 Anchor-Based 方法，主要不同点是输入网络的特征，即点云栅格化后提取出的特征不一样以及融合时序信息。并且，训练过程中，对数据增广做了精心的设计。 <img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/fusion.png" width="90%" height="90%" title="图 3. Frusion Strategy"> 　　如图 3. 所示，点云栅格化后提取的特征不一样是指增加了 Visibility 图层。有两种融合方式，前融合是与点云栅格化后提取的特征作 Concate，然后输入到主干网络；后融合则是二者分别通过主干网络，然后再作 Concate。实验表明前融合效果较好。</p><h3 id="object-augmentation">1.1. Object Augmentation</h3><p>　　传统的数据增广关注在全帧点云的平移，旋转，翻转变换。本文则采用目标级别的数据增广。首先生成目标的点云集合，可以用 CAD 模型，也可以直接扣实际的目标点云(扣出来的点云增广能力有限)；然后将目标点云集合随机得放到全帧点云中。在放置的过程中需要模拟 LiDAR 的测量模型，也就是 Visibility 计算过程，这在第 2. 节中详细描述。实验表面能提升 ~9 个点。</p><h3 id="temporal-aggregation">1.2. Temporal Aggregation</h3><p>　　时序点云信息的利用可以有以下几种方法：</p><ul><li>将每帧点云栅格化，然后直接在 Chanel 层作 Concate，之后作 3D 卷积，或者先在 Chanel 维度作 1D 卷积，然后作 2D 卷积；</li><li>将点云中的点增加相对时间戳属性，然后作整体的栅格化，之后直接作传统的 2D 卷积；</li></ul><p>本文采用第二种方法，实验表明能提升 ~8 个点。</p><h2 id="visibility-computing">2. Visibility Computing</h2><p>　　<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 中已经应用了 Raycasting 来计算 Visibility/Free。对于点云中的每一个点，我们不仅能获得该点探测到障碍物的这个信息，还能知道，传感器与该点之间的连线上是 Free 的。这就要求能高效得计算该连线相交 Voxel 的集合。该计算模型也用来修正 Object Augmentation 时的点云。</p><h3 id="efficient-voxel-traversal">2.1. Efficient Voxel traversal</h3><p>　　对每个点，都需要遍历传感器原点到该点所经过的 Voxel，采用 Fast Voxel Traversal<a href="#2" id="2ref"><sup>[2]</sup></a>方法来进行高效的 Voxel 遍历。</p><h3 id="raycasting-with-augmented-objects">2.2. Raycasting with Augmented Objects</h3><p><img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/augment.png" width="90%" height="90%" title="图 4. Rectify Object Augmentation"> 　　如图 4. 所示，本文设计了两种策略来修正物体增广：</p><ul><li>Culling，如果该物体是被遮挡的，那么直接去掉，这样会极大减少增广的物体；</li><li>Drilling，如果该物体是被遮挡的，那么将遮挡物去掉，即置为 Free；</li></ul><p>实验表明 Drilling 效果较好，在训练时采用该策略进行物体增广后的点云修正，作 Inference 时就直接计算 Freespace 即可。</p><h3 id="online-occupancy-mapping">2.3. Online Occupancy Mapping</h3><p>　　栅格内点云提取特征时融合了时序信息，Visibility 也需要融合时序信息，最直观的方式是将 3D Occupancy Map 进行时间维度的堆叠，获得 4D Map，这样对后续的计算量较大。本文采用 OctoMap<a href="#3" id="3ref"><sup>[3]</sup></a> 计算方式，作贝叶斯滤波，得到时序滤波的 3D Occupancy Map。原理与 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 一样，只不过这里是 3D 的。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Hu, Peiyun, et al. &quot;What You See is What You Get: Exploiting Visibility for 3D Object Detection.&quot; arXiv preprint arXiv:1912.04986 (2019).<br><a id="2" href="#2ref">[2]</a> Amanatides, John, and Andrew Woo. &quot;A fast voxel traversal algorithm for ray tracing.&quot; Eurographics. Vol. 87. No. 3. 1987.<br><a id="3" href="#3ref">[3]</a> Hornung, Armin, et al. &quot;OctoMap: An efficient probabilistic 3D mapping framework based on octrees.&quot; Autonomous robots 34.3 (2013): 189-206.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Bird-View 3D Detection 都是将点云离散化到 Voxel，有点的 Voxel 提取区域特征，无点的 Voxel 则置为空。而 LiDAR 的测量特性其实还包含更多的信息，&lt;a href=&quot;/Grid-Mapping/&quot; title=&quot;Grid-Map
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Reconfigurable Voxels, A New Representation for LiDAR-Based Point Clouds&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Reconfigurable-Voxels/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Reconfigurable-Voxels/</id>
    <published>2020-04-20T01:54:31.000Z</published>
    <updated>2020-04-21T03:38:54.663Z</updated>
    
    <content type="html"><![CDATA[<p>　　Voxel-based 点云特征提取虽然损失了一定的信息，但是计算高效。Voxel-based 方法一个比较大的问题是，由于<strong>点云分布的不均匀性</strong>，作卷积时会导致可能计算的区域没有点，从而不能有效提取局部信息。为了解决栅格化后栅格中点云分布的不均匀问题，目前看到的有以下几种方法：</p><ol type="1"><li>Deformable Convolution，采用可变形卷积方法，自动学习卷积核的连接范围，理论上应该能更有效得使卷积核连接到点密度较高的栅格；</li><li><a href="/paper-reading-PolarNet/" title="PolarNet">PolarNet</a>提出了一种极坐标栅格化方式，因为点云获取的特性，这种方法获得的栅格中点数较为均匀;</li><li>手动设计不同分辨率的栅格，作特征提取，然后融合。比如近处分辨率较高，远处较低的方式；</li><li>本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提出了一种自动选择栅格领域及分辨率，从而最大化卷积区域点数的方法；</li></ol><p><img src="/paper-reading-Reconfigurable-Voxels/reconfig.png" width="80%" height="80%" title="图 1. Reconfig Voxels"> 　　如图 1. 所示，本文提出的 Reconfigurable Voxel 方法，能自动选择领域内点数较多的栅格特征提取，进而作卷积运算，避免点数较少，从而信息量较少的栅格作特征提取操作；此外还可根据点数自动调整分辨率以获得合适的栅格点数。通过这种方法，每个栅格输入到网络前都能有效提取周围点数较多区域的特征信息。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-Reconfigurable-Voxels/pipeline.png" width="80%" height="80%" title="图 2. Framework"> 　　如图 2. 所示，本文以检测任务为例，分三部分：Voxel/Pillar Feature Extraction，Backbone，RPN/Detection Head。后两个采用传统的方法，本文主要是改进 Voxel/Pillar Feature Extraction，这是输入到网络前的特征提取阶段。</p><h2 id="voxelpillar-feature-extraction">2. Voxel/Pillar Feature Extraction</h2><p>　　传统的输入到 2D 卷积网络的特征要么是手工提取的，要么是用 <a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a> 网络去学习每个 Voxel 的特征。由此输入到网络的特征不是最优的，因为点云的稀疏性会导致后面的 2D 卷积网络作特征提取时遇到很多“空”的 Voxel。本文提出的方法就能显式得搜索每个 Voxel 周围有点的区域作特征提取，使得之后 2D 卷积特征提取更加有效。其步骤为：</p><ul><li>点云栅格化，并存储每个 Voxel 周围 Voxel 的索引；</li><li>每个 Voxel 周围 Voxel 作 Biased Random Walk，去搜索有更稠密点云的 Voxel；</li><li>将每个 Voxel 与新搜索到的周围 Voxel 作特征提取与融合，得到该 Voxel 特征；</li></ul><h3 id="biased-random-walking-neighbors">2.1. Biased Random Walking Neighbors</h3><p>　　邻域 Voxel 搜索目标是：<strong>在距离较近的情况下寻找较稠密的 Voxel</strong>。由此设计几种策略：</p><ul><li>点数越少的 Voxel，有更高概率作 Random Walk，以及更多 Step 去周围相邻的 Voxel；</li><li>点数越多的 Voxel，有更高概率被其它 Voxel Random Walk 到；</li></ul><p>　　将以上策略数学化。设第 \(j\) 个 Voxel 有 \(N(j)\) 个点，最大点数为 \(n\)，其作 Random Walk 的概率为 \(P _ w(j)\)，步数 Step 为 \(S(j)\)，第 \(i\) 步到达的 Voxel 为 \(w _ j(i)\)，其四领域 Voxel 集合为 \(V(w _ j(i))\)，从该 Voxel 走到下一个 Voxel 的概率为 \(P(w _ j(i+1)|w _ j(i))\)。由此得到以上策略的数学描述： <span class="math display">\[P _ w(j)=\frac{1}{N(j)} \tag{1}\]</span> <span class="math display">\[S(j)=n-N(j)\tag{2}\]</span> <span class="math display">\[P\left(w _ j(i+1)|w _ j(i)\right) = \frac{N\left(w _ j(i+1)\right)}{\sum _ {v\in V(w _ j(i))}N(v)}\tag{3}\]</span> 需要注意的是，\(S(j)\) 是在开始时计算的，此后每走一步就减1。 <img src="/paper-reading-Reconfigurable-Voxels/random_walk.png" width="90%" height="90%" title="图 3. Random walk"> 　　如图 3. 所示，左边为单分辨率下 Voxel 搜索过程。</p><h3 id="reconfigurable-voxels-encoder">2.2. Reconfigurable Voxels Encoder</h3><p>　　每个 Voxel \(v _ i\) 搜索到最优的 4 领域 Voxel 集 \(V(v _ i)\) 后，需要融合得到该 Voxel 的特征： <span class="math display">\[\begin{align}F(v _ i) &amp;= \psi\left(f _ {v _ i}, f _ {V(v _ i)}\right)\\&amp;= \varphi _ 1\left[\varphi _ 2(f _ {v _ i}), \varphi _ 2\left(\sum _ {j=1}^4 W _ j(f _ {v _ i})f _ {V _ {j(v _ i)}}\right)\right] _ f\tag{4}\end{align}\]</span> 其中 \(\varphi _ 1\) 为 low-level 操作，如 average pooling，\(\varphi _ 2\) 为 high-level 操作，如 MLP。</p><h3 id="multi-resolution-reconfigurable-voxels">2.3. Multi-resolution Reconfigurable Voxels</h3><p>　　图 3. 左边是单分辨率情况，Random Walking 可以拓展到多分辨率情形。当点云非常稀疏的时候，就很有必要降低栅格的分辨率。如图 3. 所示，\(P _ w\) 计算时除以 4，以维持与高分辨率的一致性；高分辨率到低分辨率搜索概率为 \(0.25P _ w\)，低分辨率到高分辨率搜索概率为 \(0.5P _ w\)。其余准则与单分辨率一致。实验结果表面多分辨率有一定提升，但是相比单分辨率提升不明显。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Wang, Tai, Xinge Zhu, and Dahua Lin. &quot;Reconfigurable Voxels: A New Representation for LiDAR-Based Point Clouds.&quot; arXiv preprint arXiv:2004.02724 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Voxel-based 点云特征提取虽然损失了一定的信息，但是计算高效。Voxel-based 方法一个比较大的问题是，由于&lt;strong&gt;点云分布的不均匀性&lt;/strong&gt;，作卷积时会导致可能计算的区域没有点，从而不能有效提取局部信息。为了解决栅格化后栅格中点云分布
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;PolarNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-PolarNet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-PolarNet/</id>
    <published>2020-04-16T01:19:12.000Z</published>
    <updated>2020-04-17T02:09:42.539Z</updated>
    
    <content type="html"><![CDATA[<p>　　Point-wise 特征提取在 <a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 中已经有较为详细的描述，虽然 Point-wise 提取的特征更加精细，但是一般都有 KNN 构建及索引操作，计算量较大，而且实践中发现学习收敛较慢。Voxel-based 虽然理论上损失了一定的信息，但是能直接应用 2D 卷积网络，网络学习效率很高。本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种在极坐标下栅格化后进行点云 Semantic Segmentation 的方法，相比传统的笛卡尔坐标系下栅格化有一定的优势。</p><h2 id="voxelization">1. Voxelization</h2><p><img src="/paper-reading-PolarNet/pts.png" width="98%" height="98%" title="图 1. Cartesian VS. Polar"> 　　如图 1. 所示，传统的笛卡尔坐标系下栅格化的栅格是矩形，而极坐标系下栅格是饼状的。激光雷达是在极坐标方式下获取点云的，所以由图可知，<strong>极坐标栅格化下，每个栅格拥有的点数更加均匀</strong>，有利于网络学习并减少计算量。此外，本文统计后显示，相比笛卡尔坐标栅格，极坐标的栅格内点属于同一目标的概率更大。</p><h2 id="polarnet-framework">2. PolarNet Framework</h2><p><img src="/paper-reading-PolarNet/framework.png" width="98%" height="98%" title="图 2. PolarNet"> 　　如图 2. 所示，点云经过 Polar 栅格化后，对每个栅格首先进行 PointNet 特征提取，然后对所有栅格作 ring-convolution 操作。<br>　　ring-convolution 是指卷积在环形方向进行，没有边缘截断效应。实现上，将栅格从某处展开，然后边缘处用另一边对应的栅格进行 padding，即可用普通的卷积进行运算。<br>　　网络是作 Voxel-wise 的分割，然后直接将预测的类别应用到栅格内的点云中。统计上，同一栅格内的点云属于不同类别的概率很低，所以本文并没进一步作 Point-wise 的分割。</p><h2 id="rethinking">3. Rethinking</h2><p>　　PolarNet 作 Semantic Segmentation 比其它方法提升很多。但是实际应用时，PolarNet 不能指定各个方向的范围，所以计算效率较低。比如，自动驾驶中，我们可以设定前 100m，后 60m，左右各 30m 的检测范围，笛卡尔坐标系下很容易进行栅格化，而极坐标下则没法搞。所以为了解决点云的分布不均匀问题，另一种思路是在笛卡尔坐标系下，近处打高分辨率的栅格，远处打低分辨率的栅格。具体实现，可以先用低分辨率过一遍网络，然后再对感兴趣的特定区域作高分辨率检测。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Zhang, Yang, et al. &quot;PolarNet: An Improved Grid Representation for Online LiDAR Point Clouds Semantic Segmentation.&quot; arXiv preprint arXiv:2003.14032 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Point-wise 特征提取在 &lt;a href=&quot;/PointCloud-Feature-Extraction/&quot; title=&quot;PointCloud-Feature-Extraction&quot;&gt;PointCloud-Feature-Extraction&lt;/a&gt; 中已经有
      
    
    </summary>
    
      <category term="Semantic Segmentation" scheme="https://leijiezhang001.github.io/categories/Semantic-Segmentation/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Segmentation" scheme="https://leijiezhang001.github.io/tags/Segmentation/"/>
    
  </entry>
  
  <entry>
    <title>PointFlowNet</title>
    <link href="https://leijiezhang001.github.io/PointFlowNet/"/>
    <id>https://leijiezhang001.github.io/PointFlowNet/</id>
    <published>2020-04-13T01:54:59.000Z</published>
    <updated>2020-04-15T03:07:01.997Z</updated>
    
    <content type="html"><![CDATA[<p>　　点云的 Scene Flow 与 Semantic 一样是一个较低层的信息，通过 Point-Wise Semantic 信息可以作物体级别的检测，这种方式有很高的召回率，且超参数较少。同样，通过 Point-Wise Scene Flow 作目标级别的运动估计(当然也可作物体点级别聚类检测的线索)，也会非常鲁棒。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 将点级别/Voxel 级别的 Scene Flow 与 3D 目标检测融合在一起，作物体级别的运动估计，工作系统性较强。</p><h2 id="问题描述">1. 问题描述</h2><p>　　设 \(t\) 时刻点云 \(\mathbf{P} _ t\in\mathbb{R}^{M\times 3}\)，那么需要求解的未知量有：</p><ul><li>每个点的 Scene Flow: \(\mathbf{v} _ i\in\mathbb{R} ^3\);</li><li>每个点集的 Rigid Motion: \(\mathbf{R} _ i\in\mathbb{R}^{3\times 3}\)，\(\mathbf{t} _ i\in\mathbb{R}^{3}\);</li><li>每个物体的 3D 属性：Location，Orientation，Size，Rigid Motion;</li></ul><h2 id="算法框架">2. 算法框架</h2><p><img src="/PointFlowNet/framework.png" width="90%" height="90%" title="图 1. PoingFlowNet Framework"> 　　如图 1. 所示，PointFlowNet 由四部分组成，分别为：Feature Encoder，Scene Flow/Ego-motion Estimation and 3D Object Detection，Rigid Motion Estimation，Object Motion Decoder。Feature Encoder 将前后帧点云栅格化后作特征提取，然后 Context Encoder 作进一步的特征融合去提取；输出的特征第一个分支作 Voxel 级别的 Scene Flow 预测，进一步作每个点的 Rigid Motion 预测(<strong>每个点属于对应物体的 Motion 在该 Voxel 坐标系下的表示</strong>)；第二个分支作 Ego-Motion 的预测；第三个分支作 3D 目标检测，进一步作目标的 Motion Decoder。</p><h3 id="feature-encoder">2.1. Feature Encoder</h3><p>　　不同的点云特征提取方式都可采用，本文采用传统的 Bird-View Voxel 表示方式，然后作 2D/3D 卷积。同时还需要将前后帧的点云作特征融合，这里也完全可以采用 <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 的特征提取形式。</p><h3 id="scene-flowrigid-motion-decoder">2.2. Scene Flow/Rigid Motion Decoder</h3><p>　　Scene Flow 是作 Bird-View 下 Voxel 级别的场景流预测，然后再预测 Rigid Motion。 <img src="/PointFlowNet/rigid-motion.png" width="80%" height="80%" title="图 2. Rigid MOtion Estimation"> 　　如图 2. 所示，世界坐标系 \(\mathbf{W}\) 下点 \(\mathbf{p}\) 的 scene flow 表示为 \(\mathbf{v}\)，刚体物体的局部坐标系从 \(\mathbf{A}\) 经过 \((\mathbf{R _ A, t _ A})\) 运动到 \(\mathbf{B}\) ，那么其 scene flow 可表示为： <span class="math display">\[\mathbf{v=[R _ A(p-o _ A)+t _ A]-(p-o _ A)} \tag{1}\]</span> 本文论证了两个定理：</p><ol type="1"><li>scene flow 只能通过刚体局部坐标系的运动导出，不能直接通过世界坐标系下的刚体运动导出(除非运动无旋转量)。所以如图 1. 所示，通过 scene flow 预测出的 voxel motion 是局部坐标系下的，还需通过坐标变换到世界坐标系下。<strong>这里每个 Voxel 预测量的局部坐标系采用 Voxel 中心点</strong>。作目标运动估计时，&quot;世界坐标系&quot;其实可以定义为物体坐标系(Voxel 为局部坐标系)，最后再通过 Ego-motion 变换到世界坐标系。</li><li>不管是局部坐标系 \(\mathbf{A}\) 还是 \(\mathbf{B}\)，都能导出 scene flow。</li></ol><p>　　如图 2. 所示，实验也验证了 scene flow 不能直接学习到世界坐标系下的 translation 运动。</p><h3 id="ego-motion-regressor">2.3. Ego-motion Regressor</h3><p>　　根据前后帧的点云回归本车的运动(ego-motion)，ego-motion 建立局部坐标系与世界坐标系的联系。如果有更精准的外部模块估计的 ego-motion，则可以直接替换采用。</p><h3 id="d-object-detection-and-object-motion-decoder">2.4. 3D Object Detection and Object Motion Decoder</h3><p>　　Bird-view 下 Voxel 后的 3D 检测方法很多，可以是 Anchor-based，Anchor-free，Semantic Segmentation 等方法，其中如果采用 Semantic Segmentation + cluster 方法，那么 scene flow 的结果也可作为 cluster 的线索。<br>　　有了 3D 目标以及目标内 Voxel 的 Rigid Motion 后，取平均或中值即可得到目标的 Motion。<br>　　<strong>Voxel Rigid Motion 可以有两种回归方法：</strong></p><ol type="1"><li>translation 真值为实际该 Voxel 的位移，rotation 为对应刚体的旋转量；</li><li>translation 与 rotation 均为对应刚体的位移与旋转量；</li></ol><p>我理解的本文是采用方法 1. 这种形式，这种形式的好处是回归的就是真实 Voxel 的位移，与输入的特征是 Voxel 级别对应的，但是简单的对目标内的 Voxel 取平均或中值只是目标位移的近似，实际目标的真实位移应该为旋转中心 Voxel 的位移。而方法 2. 是物体级别的回归量，均值即可反应物体的运动，只要构建物体级别的 Loss，用 Voxel 去学习物体级别的运动应该问题不大，所以可能方法 2. 更合理。</p><h2 id="loss-functions">3. Loss Functions</h2><p>　　采用 Voxel 级别的 Loss，总的 Loss 为： <span class="math display">\[\mathcal{L}=\alpha\mathcal{L} _ {flow}+\beta\mathcal{L} _ {rigmo} + \gamma\mathcal{L} _ {ego}+\mathcal{L} _ {det}\tag{2}\]</span> 这四部分具体的形式为：</p><ol type="1"><li>Scene Flow Loss<br>对于有效的 Voxel，作预测值与真值的 \(\mathcal{l} _ 1\) 误差： <span class="math display">\[\mathcal{L} _ {flow}=\frac{1}{K}\sum _ j\Vert \mathbf{v} _ j-\mathbf{v} _ j ^ * \Vert \tag{3}\]</span></li><li>Rigid Motion Loss<br>对于有效的 Voxel，作预测值与真值(真值有两种形式，详见 2.4 讨论)的 \(\mathcal{l} _ 1\) 误差： <span class="math display">\[\mathcal{L} _ {rigmo} = \frac{1}{K}\sum _ j\Vert\mathbf{t} _ j-\mathbf{t} _ j^ * \Vert+\lambda\Vert\theta _ j-\theta _ j^ * \Vert\tag{4}\]</span></li><li>Ego-motion Loss<br>同样的对预测值与真值作 \(\mathcal{l} _ 1\) Loss: <span class="math display">\[\mathcal{L} _ {ego}=\Vert\mathbf{t} _ {BG}-\mathbf{t} _ {BG}^ * \Vert+\lambda\Vert\theta _ {BG}-\theta _ {BG}^ * \Vert \tag{5}\]</span></li><li>Detection Loss<br>不作赘述。</li></ol><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Behl, Aseem, et al. &quot;Pointflownet: Learning representations for rigid motion estimation from point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　点云的 Scene Flow 与 Semantic 一样是一个较低层的信息，通过 Point-Wise Semantic 信息可以作物体级别的检测，这种方式有很高的召回率，且超参数较少。同样，通过 Point-Wise Scene Flow 作目标级别的运动估计(当然也
      
    
    </summary>
    
      <category term="Scene Flow" scheme="https://leijiezhang001.github.io/categories/Scene-Flow/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Scene Flow" scheme="https://leijiezhang001.github.io/tags/Scene-Flow/"/>
    
  </entry>
  
  <entry>
    <title>The Normal Distributions Transform for Laser Scan Matching</title>
    <link href="https://leijiezhang001.github.io/paper-reading-The-Normal-Distributions-Transform/"/>
    <id>https://leijiezhang001.github.io/paper-reading-The-Normal-Distributions-Transform/</id>
    <published>2020-04-10T01:39:54.000Z</published>
    <updated>2020-04-11T11:29:19.873Z</updated>
    
    <content type="html"><![CDATA[<p>　　机器人系统中，定位是非常重要的模块。基于 SLAM/VO/VIO 技术的算法能实时作机器人的自定位，但是这种开环下的里程计方案很容易累积绝对误差，使得定位漂移。而离线建立的地图因为有闭环检测，精度很高，所以基于地图的定位方法有很高的绝对定位精度。<br>　　<a href="/LOAM/" title="LOAM">LOAM</a> 是一种基于点云的实时建图与定位方法，其中当前帧点云与前序建立的地图点云配准的方法，采用了提取线、面特征并建立点-线，点-面特征匹配误差函数，从而最小二乘非线性优化求解位姿。这种方案如果特征点噪声较大无匹配对，那么就会有较大的误差。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 将地图点云栅格化，每个栅格又统计点云的高斯分布，匹配的时候计算该帧点云在每个栅格的概率，从而迭代至最优匹配位姿。<br>　　<strong>有闭环检测</strong>的 SLAM 建立的地图即可作为离线定位地图，定位的过程就是当前时刻点云与地图配准的过程，当然后续可以融合其它传感器(GPS，IMU)输出最终的绝对位姿。<strong>点云与地图配准的过程与建图时点云与局部地图或上一时刻点云配准的过程非常相似</strong>。本文介绍一种区别于 <a href="/LOAM/" title="LOAM">LOAM</a> 特征匹配的基于概率统计优化的 NDT 配准方法。</p><h2 id="点云配准算法过程">1. 点云配准算法过程</h2><p>　　考虑二维情况，本文点云配准算法过程为：</p><ol type="1"><li>建立 \(t-1\) 帧点云的 NDT；</li><li>初始化待优化的相对位姿参数 \(T\);</li><li>用 \(T\) 将 \(t\) 帧点云变换到 \(t-1\) 坐标系；</li><li>找到变换每个变换点对应的 \(t-1\) 帧栅格的高斯分布；</li><li>该变换 \(T\) 的度量分数为变换点在高斯分布下的概率和；</li><li>用 Newton 法迭代优化 \(T\);</li><li>重复 3. 直到收敛；</li></ol><p>　　这里主要涉及 NDT，目标函数构建(即 \(T\) 的度量分数)，Newton 法优化三个内容。</p><h3 id="ndt">1.1. NDT</h3><p>　　NDT 是点云栅格化后一系列高斯分布的表示，其过程为：</p><ol type="1"><li>将点云进行栅格化；</li><li>统计每个栅格的点 \(\mathbf{x} _ {i=1..n}\)；</li><li>计算每个栅格高斯分布的 Mean: \(\mathbf{q} = \frac{1}{n}\sum _ i\mathbf{x} _ i\);</li><li>计算 Covariance Matrix: \(\Sigma = \frac{1}{n}\sum _ i(\mathbf{x} _ i -\mathbf{q})(\mathbf{x} _ i-\mathbf{q})^t\)；</li></ol><p>　　由此，<strong>NDT 描述了栅格内每个位置出现点的概率</strong>，即 \(\mathbf{x}\) 有点的概率为： <span class="math display">\[ p(\mathbf{x}) \sim \mathrm{exp}\left(-\frac{(\mathbf{x-q})^t\sum ^ {-1}(\mathbf{x-q})}{2}\right) \tag{1}\]</span> 需要注意的是 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 描述的是每个栅格有点的概率，NDT 描述的是每个栅格点云的概率分布。为了更准确的建模，采用重叠栅格化的设计以消除离散化的影响，以及限定 Covariance 矩阵的最小奇异值。</p><h3 id="目标函数构建">1.2. 目标函数构建</h3><p>　　考虑二维情况，需要优化的位姿参数为 \(\mathbf{p}=(t _ x, t _ y, \varphi)^t\)，第2个点云(待配准点云)中的点为 \(\mathbf{x} _ i\)，其变换到第1个点云坐标系后的表示为 \(\mathbf{x}' _ i\)，对应的第1个点云栅格的 NDT 表示为 \(\mathbf{\Sigma} _ i, \mathbf{q} _ i\)。由此可计算该变换位姿下，其度量分数为： <span class="math display">\[\mathrm{score}(\mathbf{p})=\sum _ i\mathrm{exp}\left(-\frac{(\mathbf{x}&#39; _ i-\mathbf{q} _ i)^t\sum _ i ^ {-1}(\mathbf{x}&#39; _ i-\mathbf{q} _ i)}{2}\right) \tag{2}\]</span> 最大化度量函数即可求解最优的位姿，优化过程一般都是最小化目标函数，所以设定目标函数为 \(-\mathrm{score}\)。</p><h3 id="newton-法优化迭代">1.3. Newton 法优化迭代</h3><p>　　设 \(\mathbf{q}=\mathbf{x}' _ i-\mathbf{q} _ i\)，那么目标函数为： <span class="math display">\[ s = -\mathrm{exp}\frac{-\mathbf{q^t\sum ^ {-1}q}}{2} \tag{3}\]</span> 每次迭代过程为： <span class="math display">\[\mathbf{p\gets p+\Delta p} \tag{4}\]</span> 而 \(\mathbf{\Delta p}\) 来自： <span class="math display">\[\mathbf{H\Delta p} = \mathbf{-g} \tag{5}\]</span> 其中 \(\mathbf{g}\) 是目标函数对优化参数的导数，\(\mathbf{H}\) 为目标函数的 Hessian 矩阵： <span class="math display">\[\left\{\begin{array}{l}g _ i=\frac{\partial s}{\partial p _ i}\\H _ {ij} = \frac{\partial s}{\partial p _ i\partial p _ j}\end{array}\tag{6}\right.\]</span></p><h2 id="建图与定位">2. 建图与定位</h2><p>　　本文的建图是通过<strong>关键帧集合与关键帧之间的位姿变化实现的</strong>，定位的时候去找重合度最高的关键帧作点云配准。此外，当找不到重合度较高的关键帧时，可以实时更新当前帧作为关键帧添加到地图中，还可以对地图作进一步的全局，半全局优化。</p><h2 id="一些思考">3. 一些思考</h2><p>　　本文建图是关键帧的形式，更鲁棒的做法是将点云配准到一起，在世界坐标系下获得场景的稠密点云，然后再 NDT 化，这样能更准确的建模点云分布。<br>　　<a href="/LOAM/" title="LOAM">LOAM</a> 维护的是栅格化的地图，每个栅格限制特征点的数量，所以本质上存储的是原始点云图(被选出是特征点的点云)。为了更好的描述栅格内的特征分布，可以对其作类似 NDT 近似，同时加入能描述该分布的特征，比如对于面特征，加入法向量。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Biber, Peter &amp; Straßer, Wolfgang. (2003). The Normal Distributions Transform: A New Approach to Laser Scan Matching. IEEE International Conference on Intelligent Robots and Systems. 3. 2743 - 2748 vol.3. 10.1109/IROS.2003.1249285.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　机器人系统中，定位是非常重要的模块。基于 SLAM/VO/VIO 技术的算法能实时作机器人的自定位，但是这种开环下的里程计方案很容易累积绝对误差，使得定位漂移。而离线建立的地图因为有闭环检测，精度很高，所以基于地图的定位方法有很高的绝对定位精度。&lt;br&gt;
　　&lt;a hr
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Localization" scheme="https://leijiezhang001.github.io/tags/Localization/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Probabilistic 3D Multi-Object Tracking for Autonomous Driving&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Probabilistic-3D-Multi-Object-Tracking-for-Autonomous-Driving/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Probabilistic-3D-Multi-Object-Tracking-for-Autonomous-Driving/</id>
    <published>2020-04-07T09:28:57.000Z</published>
    <updated>2020-05-06T06:32:45.376Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中已经较详细得阐述了 3D MOT 状态估计过程，文章末提到观测过程的协方差矩阵初始化问题可以用观测的不确定性解决，<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 就是通过贝叶斯深度神经网络来建模该不确定性。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提供了另一种简化的观测不确定性计算方法，同时估计运动模型与观测模型的不确定性，即过程噪声与测量噪声。</p><h2 id="kalman-filter">1. Kalman Filter</h2><p><img src="/paper-reading-Probabilistic-3D-Multi-Object-Tracking-for-Autonomous-Driving/framework.png" width="80%" height="80%" title="图 1. MOT Framework"> 　　如图 1. 所示，本文采用的卡尔曼滤波框架与传统的一样，分为预测与更新。预测阶段，根据上一时刻结果通过 Motion Model(Process Model) 预测当前时刻的状态(先验)；数据关联阶段，将预测的状态与观测的状态作目标数据关联，出 ID；更新阶段，融合预测与观测的状态，得到状态的后验估计。</p><h3 id="predict-step">1.1. Predict Step</h3><p>　　本文采用 CTRV(Constant Turn Rate and Velocity) 运动模型。不同与<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中描述的 CTRV，本文作了<strong>线性简化</strong>，其运动方程为： <span class="math display">\[\begin{align}&amp;\begin{bmatrix}\hat{x}\\\hat{y}\\\hat{z}\\\hat{a}\\\hat{l}\\\hat{w}\\\hat{h}\\\hat{d} _ x\\\hat{d} _ y\\\hat{d} _ z\\\hat{d} _ a\\\end{bmatrix} _ {t+1}=\begin{bmatrix}1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0\\0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0\\0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\\end{bmatrix}\begin{bmatrix}x\\y\\z\\a\\l\\w\\h\\d _ x\\d _ y\\d _ z\\d _ a\\\end{bmatrix} _ {t}  +\begin{bmatrix}q _ x\\q _ y\\q _ z\\q _ a\\0\\0\\0\\q _ {d _ x}\\q _ {d _ y}\\q _ {d _ z}\\q _ {d _ a}\\\end{bmatrix} _ {t}\\\Longleftrightarrow &amp; \\&amp;\hat{\mu} _ {t+1} = \mathbf{A}\mu _ t \\\end{align}\tag{1}\]</span> 其中未知的线加速度与角加速度 \((q _ x, q _ y, q _ z, q _ a)\)，\((q _ {d _ x},q _ {d _ y},q _ {d _ z},q _ {d _ a})\) 符合\((0,\mathbf{Q})\)高斯分布。<br>　　根据 Motion Model，卡尔曼的预测过程计算状态量的先验： <span class="math display">\[\begin{align}\hat{\mu} _ {t+1} &amp;= \mathbf{A}\mu _ t \\\hat{\Sigma} _ {t+1} &amp;= \mathbf{A}\Sigma _ t\mathbf{A}^T + \mathbf{Q}\\\end{align}\tag{2}\]</span> 　　观测模型为每一时刻检测的结果，包括位置，朝向，目标框尺寸，即观测矩阵 \(\mathbf{H} _ {7\times 11} = [\mathbf{I}, \mathbf{0}]\)。观测噪声也符合高斯分布，由此得到预测的观测量： <span class="math display">\[\begin{align}\hat{o} _ {t+1} &amp;= \mathbf{H}\hat{\mu} _ {t+1} \\\mathbf{S} _ {t+1} &amp;= \mathbf{H}\hat{\Sigma} _ {t+1}\mathbf{H}^T + \mathbf{R}\\\end{align}\tag{3}\]</span></p><h3 id="update-step">1.2. Update Step</h3><p>　　首先将预测的观测量与实际的观测量作数据关联。基本思想是将预测目标与观测目标作 Cost Matrix，然后用匈牙利/贪心算法求解最优匹配对。本文采用 Mahalanobis distance： <span class="math display">\[ m = \sqrt{(o _ {t+1}- \mathbf{H}\hat{\mu} _ {t+1})^T\mathbf{S} _ {t+1} ^{-1}(o _ {t+1}-\mathbf{H}\hat{\mu} _ {t+1})} \tag{4}\]</span> 需要注意的是，计算距离前先做角度矫正，如果两个目标框角度相差大于 90 度，那么作 180 度旋转。<br>　　得到预测与观测的匹配对后，计算后验概率更新该目标的状态： <span class="math display">\[\begin{align}\mathbf{K} _ {t+1} &amp;= \hat{\Sigma} _ {t+1}\mathbf{H} ^T\mathbf{S} _ {t+1}^{-1}\\\mu _ {t+1} &amp;= \hat{\mu} _ {t+1} + \mathbf{K} _ {t+1}(o _ {t+1}-\mathbf{H}\hat{\mu} _ {t+1})\\\Sigma _ {t+1} &amp;=(\mathbf{I}-\mathbf{K} _ {t+1}\mathbf{H})\hat{\Sigma} _ {t+1}\\\end{align}\tag{5}\]</span> 　　以上卡尔曼过程与<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>，以及<a href="/卡尔曼滤波详解/" title="卡尔曼滤波详解">卡尔曼滤波详解</a>完全一致。</p><h2 id="covariance-matrices-estimation">2. Covariance Matrices Estimation</h2><p>　　如何确定卡尔曼滤波过程中的 \(\Sigma _ 0, \mathbf{Q, R}\)？传统方法是直接用一个确定的经验矩阵赋值；理想的是用<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 建模处理，但是会相对较复杂；本文用更简单的基于统计方法来确定协方差矩阵。<br>　　<strong>观测量的方差(不确定性)与目标的属性有关</strong>，如距离，遮挡，类别等。本文没有区分这些属性，只统计了一种观测量的方差，<strong>更好的处理方式是按照不同属性，统计不同的方差</strong>。而 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 是 Instance 级别的方差预测。<strong>这种统计出来的方差虽然细粒度差一点，但是非常合理，因为只要模型训练好后，模型预测的分布是与训练集分布相似的(理想情况)</strong>，所以用训练集的方差来直接代替模型预测的方差也较为合理。<br>　　<span style="color:red"><strong>更准确的来说，不确定性与物体的属性以及标注误差有关，这里只统计了标注误差(标注误差在大多数情况下都是同分布的)，而实际上遮挡大的目标，是更难学习的(目标学习有难易之分，即预测分布与训练集分布会有偏差)，即预测结果会有额外量的不确定性，所以这种离线统计方法也有很大的局限性</strong>。</span><br>　　设训练集的真值标签：\(\left\{\left\{x _ t^m, y _ t^m, z _ t^m, a _ t^m\right\} _ {m=1}^M\right\} _ {t = 1}^T\)。</p><h2 id="motionprocess-noise-model">2.1. Motion/Process Noise Model</h2><p>　　假设各状态量的噪声独立同分布，那么对于位置与朝向噪声，有： <span class="math display">\[\begin{align}Q _ {xx} &amp;= \mathbf{Var}\left(\left(x _ {t+1}^m-x _ t^m\right)-\left(x _ t^m-x _ {t-1}^m\right)\right)\\Q _ {yy} &amp;= \mathbf{Var}\left(\left(y _ {t+1}^m-y _ t^m\right)-\left(y _ t^m-y _ {t-1}^m\right)\right)\\Q _ {zz} &amp;= \mathbf{Var}\left(\left(z _ {t+1}^m-z _ t^m\right)-\left(z _ t^m-z _ {t-1}^m\right)\right)\\Q _ {aa} &amp;= \mathbf{Var}\left(\left(a _ {t+1}^m-a _ t^m\right)-\left(a _ t^m-a _ {t-1}^m\right)\right)\\\end{align}\tag{6}\]</span> 　　对于线速度与角速度，因为： <span class="math display">\[\begin{align}q _ {x _ t} &amp;\approx x _ {x+1} - x _ t - d _ {x _ t}\\&amp; \approx (x _ {t+1}-x _ t) - (x _ t-x _ {t-1})\\q _ {d _ {x _ t}} &amp;\approx d _ {x _ {t+1}} - d _ {x _ t}\\&amp; \approx (x _ {t+1}-x _ t) - (x _ t-x _ {t-1})\\\end{align}\tag{7}\]</span> 所以： <span class="math display">\[ (Q _ {d _ xd _ x}, Q _ {d _ yd _ y}, Q _ {d _ zd _ z}, Q _ {d _ ad _ a}) = (Q _ {xx}, Q _ {yy}, Q _ {zz}, Q _ {aa})\tag{8}\]</span></p><h2 id="observation-noise-model">2.2. Observation Noise Model</h2><p>　　在训练集上，找到检测与真值的匹配对 \(\left\{\left\{(D _ t^k, G _ t^k)\right\} _ {k=1}^K\right\} _ {t=1}^T\)，从而计算观测噪声： <span class="math display">\[\begin{align}&amp;R _ {xx} = \mathbf{Var}\left(D _ {x _ t}^k-G _ {x _ t}^k\right)\\&amp;R _ {yy} = \mathbf{Var}\left(D _ {y _ t}^k-G _ {y _ t}^k\right)\\&amp;R _ {zz} = \mathbf{Var}\left(D _ {z _ t}^k-G _ {z _ t}^k\right)\\&amp;R _ {aa} = \mathbf{Var}\left(D _ {a _ t}^k-G _ {a _ t}^k\right)\\&amp;R _ {ll} = \mathbf{Var}\left(D _ {l _ t}^k-G _ {l _ t}^k\right)\\&amp;R _ {ww} = \mathbf{Var}\left(D _ {w _ t}^k-G _ {w _ t}^k\right)\\&amp;R _ {hh} = \mathbf{Var}\left(D _ {h _ t}^k-G _ {h _ t}^k\right)\\\end{align}\tag{8}\]</span> 初始的状态协方差 \(\Sigma _ 0 = \mathbf{R}\)。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Chiu, Hsu-kuang, et al. &quot;Probabilistic 3D Multi-Object Tracking for Autonomous Driving.&quot; arXiv preprint arXiv:2001.05673 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;/卡尔曼滤波器在三维目标状态估计中的应用/&quot; title=&quot;卡尔曼滤波器在三维目标状态估计中的应用&quot;&gt;卡尔曼滤波器在三维目标状态估计中的应用&lt;/a&gt;中已经较详细得阐述了 3D MOT 状态估计过程，文章末提到观测过程的协方差矩阵初始化问题可以用观测的不
      
    
    </summary>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/categories/MOT/"/>
    
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Uncertainty" scheme="https://leijiezhang001.github.io/tags/Uncertainty/"/>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/tags/MOT/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;LaserNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/"/>
    <id>https://leijiezhang001.github.io/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/</id>
    <published>2020-04-06T07:36:13.000Z</published>
    <updated>2020-04-07T09:22:24.202Z</updated>
    
    <content type="html"><![CDATA[<p>　　3D 目标检测中，目标定位的不确定性也很关键，<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中已经较为详细的描述了在 Bayesian Deep Networks 中如何建模异方差偶然不确定性(Aleatoric Uncertainty)。在贝叶斯深度神经网络框架下，网络不仅预测目标的位置(Mean)，还预测出该预测位置的方差(Variance)。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 延续了 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中预测 Corner 点位置方差的思路，提出了一种预测目标位置方差的方法。</p><h2 id="算法框架">1. 算法框架</h2><p><img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/framework.png" width="90%" height="90%" title="图 1. LaserNet Framework"> 　　如图 1. 所示，输入为激光点云的 Sensor Range View 表示方式，输出为点级别的目标框3D属性，框顶点位置方差，以及类别概率。最后在 Bird View 下作目标框的聚类与 NMS 等后处理。</p><h3 id="点云输入方式">1.1. 点云输入方式</h3><p>　　不同于目前主流的 Bird View 点云栅格化方式，本文将点云直接根据线束在 Sensor Range View 下进行表示，高为激光线数量，宽为 HFOV 除以角度分辨率。设计 5 个 channel：距离，高度，角度，反射值，以及是否有点的标志位。<br>　　本文认为这种点云表示方式的优点被忽视了，该视角下，点云的表达是紧促的，而且能高效得取得局部区域点，此外，能保留点云获取方式的信息。另一方面，该表达方式的缺点有，访问局部区域时，并不是空间一致的；以及需要处理物体的不同形状和遮挡问题。本文实验结果是，在 Kitti 上效果不如 Bird View 方法，但是在一个较大数据集上，能克服这些缺点。</p><h3 id="网络输出">1.2. 网络输出</h3><p>　　网络输出为点级别的预测，由三部分组成：</p><ol type="1"><li><strong>类别概率</strong><br>每个类别的概率；</li><li><strong>3D 框属性</strong><br>包括相对中心距离 \((d _ x, d _ y)\)；相对朝向 \((\omega _ x, \omega _ y)=(\mathrm{cos}\omega, \mathrm{sin}\omega)\)；以及尺寸 \((l,w)\)。最终目标框中心点位置及朝向表示为： <span class="math display">\[\left\{\begin{array}{l}\mathbf{b} _ c = [x,y]^T+\mathbf{R} _ \theta [d _ x,d _ y]^T \\\varphi = \theta + \mathrm{atan2}(\omega _ y,\omega _ x)\end{array}\tag{1}\right.\]</span> 其中 \(\theta\) 为该点的雷达扫描角度。由此可得到四个目标框角点坐标： <span class="math display">\[\left\{\begin{array}{l}\mathbf{b} _ 1 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [l,w]^T\\\mathbf{b} _ 2 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [l,-w]^T\\\mathbf{b} _ 3 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [-l,-w]^T\\\mathbf{b} _ 4 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [-l,w]^T\end{array}\tag{2}\right.\]</span></li><li><strong>顶点位置方差</strong><br>当观测不完全时(遮挡，远处)，目标框的概率分布是多模态的，所以如 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中所述，输出为混合高斯模型。对于每个点的每个类别，输出 \(K\) 个目标框属性：\(\{d _ {x,k}, d _ {y,k}, \omega _ {x,k}, \omega _ {y,k}, l _ k, w _ k\} _ {k=1}^K\)；对应的方差 \(\{s _ k\} _ {k=1}^K\)；以及模型权重 \(\{\alpha _ k\} _ {k=1}^K\)。</li></ol><h3 id="bird-view-后处理">1.3. Bird View 后处理</h3><p>　　网络其实就做了一个点级别的分割，接下来需要作聚类以得到目标框。本文采用 Mean-Shift 方法作聚类。由于是点级别的概率分布，得到目标点集后，需要用 BCN(详见 <a href="/MOT-Fusion/" title="MOT-Fusion">MOT-Fusion</a>) 转换为目标级别的概率分布： <span class="math display">\[\left\{\begin{array}{l}\hat{\mathbf{b}} _ i = \frac{\sum _ {j\in S _ i} w _ j\mathbf{b} _ j}{\sum _ {j\in S _ i}w _ j}\\\hat{\sigma} _ i^2 = \left(\sum _ {j\in S _ i}\frac{1}{\sigma ^2 _ j}\right)^{-1}\end{array}\tag{3}\right.\]</span> 其中 \(w=\frac{1}{\sigma ^ 2}\)。</p><h2 id="loss-形式">2. Loss 形式</h2><p>　　分类采用 Focal Loss。对于每个点 3D 属性的回归，首先找到最靠近真值的预测模型： <span class="math display">\[k ^ * = \mathrm{arg}\min \limits _ k\Vert\hat{\mathbf{b}} _ k-\mathbf{b} ^{gt}\Vert\tag{4}\]</span> 对该预测模型作 Loss： <span class="math display">\[\mathcal{L} _ {box}=\sum _ n\frac{1}{\hat{\sigma} _ {k ^ * }} \left\vert\hat{\mathbf{b}} _ {n,k^ * }-\mathbf{b} _ n^{gt}\right\vert + \mathrm{log}\hat{\sigma} _ {k ^ * }\tag{5}\]</span> 实际回归的是 \(s:=\mathrm{log} \sigma\)。然后对混合模型的权重 \(\{\alpha _ k\} _ {k=1}^K\) 作 cross entry loss \(\mathcal{L} _ {mix}\)。最终的回归 Loss 为： <span class="math display">\[\mathcal{L} _ {reg} = \frac{1}{N}\sum _ i \frac{\mathcal{L} _ {box, i} + \lambda \mathcal{L} _ {mix,i}}{n _ i} \tag{6}\]</span></p><h2 id="adaptive-nms">3. Adaptive NMS</h2><p>　　类别概率不能反应目标框的质量，所以本文采用预测的目标框方差作为 NMS 的参考量。将目标框方差转换为目标框的质量分数：\(\alpha _ k/2\hat{\sigma} _ k\)。<br><img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/nms.png" width="50%" height="50%" title="图 2. Adaptive NMS"> 　　此外不同目标在 Bird-View 下 IoU 最大值有一定的限制，如图 2. 所示，最坏的情况，Bird-View 下两个框的 IoU 最大限制为设计为： <span class="math display">\[t=\left\{\begin{array}{l}\frac{\sigma _ 1+\sigma _ 2}{2w-\sigma _ 1 - \sigma _ 2} &amp; \sigma _ 1+\sigma _ 2 &lt; w\\1 &amp; otherwise\end{array}\tag{7}\right.\]</span> 当两个目标框的 IoU 大于阈值时，可能的情况是：1. 目标框错误，则删除低分数的目标框；2. 方差估计错误，那么增大方差使最大阈值满足 IoU 条件。</p><h2 id="预测分布的分析">4. 预测分布的分析</h2><p><img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/calibration.png" width="80%" height="80%" title="图 3. Uncertainty(Variance) Calibration"> 　　评价 Variance(Uncertainty) 预测的好坏，可以画 Calibration 图。如图 3. 所示，横坐标为预测的 Mean 与真值形成的高斯概率分布下的 CDF，而纵坐标为预测的 Variance 统计出的高斯分布下的 CDF。理想情况下，两者是 \(y=x\) 的关系，如图所示，在 ATG4D 大数据集上，预测的 Variance 效果更好。</p><h2 id="一些思考">5. 一些思考</h2><p>　　不管是 2D 检测还是 3D 检测，这种先(语义)分割后聚类出目标的思想，有很强的优势：召回率高，超参数少，自带分割信息等。本文又应用 Aleatoric Uncertainty 来建模检测的不确定性--位置方差(不确定性干嘛用，怎么用，不多说了)，有很好的借鉴意义。</p><h2 id="reference">6. Reference</h2><p><a id="1" href="#1ref">[1]</a> Meyer, Gregory P., et al. &quot;Lasernet: An efficient probabilistic 3d object detector for autonomous driving.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　3D 目标检测中，目标定位的不确定性也很关键，&lt;a href=&quot;/Heteroscedastic-Aleatoric-Uncertainty/&quot; title=&quot;Heteroscedastic Aleatoric Uncertainty&quot;&gt;Heteroscedastic 
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Uncertainty" scheme="https://leijiezhang001.github.io/tags/Uncertainty/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Learning to See in the Dark&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Learning-to-See-in-the-Dark/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Learning-to-See-in-the-Dark/</id>
    <published>2020-04-03T03:03:20.000Z</published>
    <updated>2020-04-03T05:57:54.579Z</updated>
    
    <content type="html"><![CDATA[<p>　　无监督低光照图像增强更有应用价值，<a href="/Unsupervised-Low-Light-Image-Enhancement/" title="Unsupervised Low Light Image Enhancement">Unsupervised Low Light Image Enhancement</a> 中介绍了几种无监督方法。本文则是有监督方法，但是值得一读。在 Sensor，曝光时间，光圈，ISO 等(在线调节通过 AE 完成)确定后，图像低光照下曝光不足主要是因为 ISP 过程对图像的亮度矫正不理想。本文直接重构 ISP 过程，对 Raw 图像进行一系列操作，以增强亮度。</p><h2 id="算法过程">1. 算法过程</h2><p><img src="/paper-reading-Learning-to-See-in-the-Dark/ISP.png" width="90%" height="90%" title="图 1. Raw Image Processing Pipeline 对比"> 　　如图 1. 所示，传统 ISP 过程包括：White Balance, Demosaic, Denoise/Sharpen, Color Space Conversion, Gamma Correction(与亮度变化相关)等。L3 与 Burst 是其它 ISP pipeline 学习的方法，本文网络算法过程如图 1.b 所示，首先提取 RGB sensor 值并放大一定比例(该放大系数用来控制最终增强的曝光级别)，然后经过网络层，最终输出全尺寸的 RGB 图像。<br>　　训练数据采集自室内静态场景，每对数据由短曝光的低光照图像与长曝光的标签图像构成，由此可进行有监督训练。</p><h2 id="reference">2. Reference</h2><p><a id="1" href="#1ref">[1]</a> Chen, Chen, et al. &quot;Learning to see in the dark.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　无监督低光照图像增强更有应用价值，&lt;a href=&quot;/Unsupervised-Low-Light-Image-Enhancement/&quot; title=&quot;Unsupervised Low Light Image Enhancement&quot;&gt;Unsupervised Low
      
    
    </summary>
    
      <category term="Low-Light Image Enhancement" scheme="https://leijiezhang001.github.io/categories/Low-Light-Image-Enhancement/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Low-Light Image Enhancement" scheme="https://leijiezhang001.github.io/tags/Low-Light-Image-Enhancement/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Low-Light Image Enhancement</title>
    <link href="https://leijiezhang001.github.io/Unsupervised-Low-Light-Image-Enhancement/"/>
    <id>https://leijiezhang001.github.io/Unsupervised-Low-Light-Image-Enhancement/</id>
    <published>2020-03-28T04:21:55.000Z</published>
    <updated>2020-04-03T06:02:16.620Z</updated>
    
    <content type="html"><![CDATA[<p>　　在自动驾驶中，相机能捕捉丰富的纹理信息，是不可或缺的传感器。但是受限于相机 Sensor 及 ISP 性能，其动态范围有限，往往会出现过曝或欠曝的情况。过曝的情况还能通过 3A(AE, AF, AW) 中的 AE 调节，而欠曝的情况，AE 中要么提高增益或 ISO 但是会增加噪声，要么增加曝光时间但是撑死 50ms(按照 20Hz)，光圈则一般是固定的，不会调节。所以在低光照自动驾驶场景下，对欠曝的图像进行亮度增强则显得尤其重要（当然也可用夜视相机如红外相机等辅助)。<br>　　基于学习的图像增强方法，由于很难获得大量的欠爆图像与对应的增强图像。所以无监督的图像增强方法就更有应用价值，本文介绍几种无监督图像增强方法。</p><h2 id="zero-dce1">1. Zero-DCE<a href="#1" id="1ref"><sup>[1]</sup></a></h2><p>　　无监督图像增强方法主要是指基于 GAN 的方法，基于 GAN 的方法还是需要选择欠爆图像及正常图像两个分布的数据集，选择不当也会导致性能下降。而 Zero-DCE 则无需选择正常图像数据集，消除了数据分布下过拟合或欠拟合的风险。<br>　　Zero-DCE 基本思想是对每个像素作亮度变换，每个像素的变换方程为： <span class="math display">\[LE(I(\mathrm{x});\alpha) = I(\mathrm{x}) + \alpha I(\mathrm{x})(1-I(\mathrm{x})) \tag{1}\]</span> 其中 \(\alpha\in[-1,1]\) 是变换系数。对图像的每个通道每个像素分别作不同系数的迭代变换，可得： <span class="math display">\[LE _ n(\mathrm{x}) = LE _ {n-1}(\mathrm{x}) + \mathcal{A} _ n LE _ {n-1}(\mathrm{x})(1-LE _ {n-1}(\mathrm{x})) \tag{2}\]</span> 其中 \(\mathcal{A} _ n\) 是变换系数集，与图像大小一致。 <img src="/Unsupervised-Low-Light-Image-Enhancement/Zero-DCE.png" width="90%" height="90%" title="图 1. Zero-DCE Framework"> 　　如图 1. 所示，Zero-DCE 框架中，一个基本网络预测几组 \(\mathcal{A} _ n\) 集合，然后对原图每个通道进行迭代的亮度变换。LE-curves 不仅能增强暗处的曝光量，还能减弱过曝处的亮度值。<br>　　该方法最重要的是 Loss 函数的设计，一共有以下 Loss 组成：</p><ol type="1"><li><strong>Spatial Consisiency Loss</strong><br>增强后的图像要求其与原图具有空间一致性： <span class="math display">\[ L _ {spa} = \frac{1}{K}\sum _ {i=1}^K\sum _ {j\in\Omega (i)}\left(\Vert Y _ i-Y _ j\Vert-\Vert I _ i-I _ j\Vert\right)^2 \tag{3}\]</span> 其中 \(\Omega\) 为某像素的领域集，可为四领域；\(K\) 为局部区域数量，可设定为 \(4\times 4\) 大小；\(Y,I\) 分别为增强后与原始的像素亮度值。</li><li><strong>Exposure Control Loss</strong><br>曝光控制 Loss 相当于设定曝光量去监督训练每个像素亮度，实现“无监督”的效果： <span class="math display">\[ L _ {exp} = \frac{1}{M}\sum _ {k=1}^M\Vert Y _ k-E\Vert \tag{4}\]</span> 其中 \(M\) 为无重合的局部区域数量，可设定为 \(16\times 16\) 大小；\(Y _ k\) 为局部区域的平均亮度值。作者实验中，设定 \(E\in[0.4,0.7]\) 均能获得相似的较好的结果。</li><li><strong>Color Constancy Loss</strong><br>根据 Gray-World color constancy 假设：rgb 每个通道的平均亮度值与 gray 灰度值一致。所以为了保证颜色不失真，构造： <span class="math display">\[ L _ {col}=\sum _ {\forall (p,q)\in \epsilon}(J^p-J^q), \epsilon=\{R,G,B\} \tag{5}\]</span> 其中 \(p,q\) 表示一对不同的颜色通道，\(J\) 表示该通道的平均亮度值。</li><li><strong>Illumination Smoothness Loss</strong><br>增强的过程要求相邻亮度值是平滑的，对增强变换系数作约束： <span class="math display">\[ L _ {tv _ {\mathcal{A}}} = \frac{1}{N}\sum _ {n=1}^N\sum _ {c\in\epsilon}(\nabla _ x\mathcal{A} _ n^c+\nabla _ y\mathcal{A} _ n^c)^2, \epsilon = \{R,G,B\}\tag{6}\]</span> 其中 \(N\) 为增强迭代数；\(\nabla _ x,\nabla _ y\) 分别表示水平与垂直方向的求导操作。</li></ol><p>最终 Loss 构成为： <span class="math display">\[ L _ {total} = L _ {spa} + L _ {exp} + W _ {col}L _ {col} + W _ {tv _ {\mathcal{A}}}L _ {tv _ {\mathcal{A}}} \tag{7}\]</span></p><h2 id="enlightengan2">2. EnlightenGAN<a href="#2" id="2ref"><sup>[2]</sup></a></h2><p>　　图像增强本质上是作 domain transfer，所以能用 GAN 处理，实现无监督训练。 <img src="/Unsupervised-Low-Light-Image-Enhancement/EnlightenGAN.png" width="90%" height="90%" title="图 2. EnlightenGAN Framework"> 　　如图 2. 所示，EnlightenGAN 由 Generator 和 Discriminator 构成。Generator 是一个 attention-guided U-Net，因为我们期望欠曝的区域能增强，所以将亮度值归一化后，用 1 减去亮度值作为注意力图，与原图一起输入网络。Discriminator 由 Global Discriminator 与 Local Discriminator 组成，因为经常只需要局部区域的亮度，所以设计 Local Discriminator 就很有必要。<br>　　Loss 的设计非常关键，EnlightenGAN 一共有以下 Loss 组成：</p><ol type="1"><li><strong>Adversarial Loss</strong><br>用于直接训练 Generator 以及 Discriminator 的 Loss，与传统的 GAN Loss 类似；</li><li><strong>Self Feature Preserving Loss</strong><br>注意到，调整输入图像值的范围，对最终的高层任务影响不是很大，所以引入网络特征 Loss 来保证增强后图像的准确性。对原始图像与生成的图像，分别输入到在 ImageNet 上预训练的 VGG-16 模型，提取特征集合，将对应的特征对作 L1 Loss。</li></ol><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Guo, Chunle, et al. &quot;Zero-Reference Deep Curve Estimation for Low-Light Image Enhancement.&quot; arXiv preprint arXiv:2001.06826 (2020).<br><a id="2" href="#2ref">[2]</a> Jiang, Yifan, et al. &quot;Enlightengan: Deep light enhancement without paired supervision.&quot; arXiv preprint arXiv:1906.06972 (2019).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　在自动驾驶中，相机能捕捉丰富的纹理信息，是不可或缺的传感器。但是受限于相机 Sensor 及 ISP 性能，其动态范围有限，往往会出现过曝或欠曝的情况。过曝的情况还能通过 3A(AE, AF, AW) 中的 AE 调节，而欠曝的情况，AE 中要么提高增益或 ISO 但是
      
    
    </summary>
    
      <category term="Low-Light Image Enhancement" scheme="https://leijiezhang001.github.io/categories/Low-Light-Image-Enhancement/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Low-Light Image Enhancement" scheme="https://leijiezhang001.github.io/tags/Low-Light-Image-Enhancement/"/>
    
      <category term="GAN" scheme="https://leijiezhang001.github.io/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>GAN</title>
    <link href="https://leijiezhang001.github.io/GAN/"/>
    <id>https://leijiezhang001.github.io/GAN/</id>
    <published>2020-03-08T08:45:51.000Z</published>
    <updated>2020-04-03T06:15:25.726Z</updated>
    
    <content type="html"><![CDATA[<p>　　Generative Adversarial Nets(GAN) 能将某个分布的数据映射到另一组数据形成的分布空间内。这在某些领域非常有用，如：图像去噪，图像去雨雾，图像去模糊，图像低光照增强等。<strong>自动驾驶中，图像去雨雾与低光照增强非常关键，GAN 能在没有模拟器的情况下，根据有限的数据，自动生成某一分布的数据，为后续感知做准备</strong>。目前还没看到针对点云的 GAN，未来 3D GAN 可能会有大进展。<br>　　本文介绍几个 GAN 的基础性工作。</p><h2 id="gan-基础网络">1. GAN 基础网络</h2><h3 id="generative-adversarial-nets1">1.1. Generative Adversarial Nets<a href="#1" id="1ref"><sup>[1]</sup></a></h3><p>　　对抗网络由生成模型和判别模型构成。生成模型输入随机噪声，输出以假乱真的图像，判别模型则对图像作分类。其优化函数为： <span class="math display">\[ \min\limits _ G \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x))] + E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{1}\]</span> 该优化过程有两部分组成：</p><ol type="1"><li><strong>优化判别模型</strong><br><span class="math display">\[ \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x))] + E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{2}\]</span> 其中第一项表示输入为真样本时，那么判别模型输出越大越好，即越接近 1；而对于已经生成的假样本 \(G(z)\)，判别模型输出越小越好，即接近 0。</li><li><strong>优化生成模型</strong><br><span class="math display">\[ \min\limits _ GV(D,G) =E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{3}\]</span> 优化生成模型时，希望生成的假样本接近真样本，所以生成的假样本经过判别模型后越大越好，即\(D(G(z))\)要接近 1。由此统一成上式。</li></ol><p>　　对抗网络的优化由这两步迭代组成。</p><h3 id="conditional-generative-adversarial-nets2">1.2. Conditional Generative Adversarial Nets<a href="#2" id="2ref"><sup>[2]</sup></a></h3><p>　　条件对抗网络中的生成模型输入不在是随机噪声，而是特定的数据分布，如真值标签。其优化函数为： <span class="math display">\[ \min\limits _ G \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x|y))] + E _ {x\sim p _ z(z)}[log(1-D(G(z|y)))] \tag{4}\]</span> 　　其优化过程与 GAN 类似。</p><h3 id="cycle-consistent-adversarial-nets3">1.3. Cycle-Consistent Adversarial Nets<a href="#3" id="3ref"><sup>[3]</sup></a></h3><p>　　Cycle GAN 使得高分辨率图像的 domain-transfer 成为可能。对于两个图像分布 \(X,Y\)，设计两个映射函数(生成模型): \(G:X\to Y\) 和 \(F:Y\to X\)；设计两个判别模型: \(D _ X\) 和 \(D _ Y\)，\(D _ X\) 用于判别 \(x\) 与 \(F(y)\), \(D _ Y\) 用于判别 \(y\) 与 \(G(x)\)。为了还原高分辨率图像，设计两部分 Loss：</p><ol type="1"><li><strong>Adversarial Loss</strong><br>就是传统的对抗网络 Loss: <span class="math display">\[\begin{align}\mathcal{L} _ {GAN}&amp;=\mathcal{L} _ {GAN}(G, D _ Y,X,Y)+\mathcal{L} _ {GAN}(F, D _ X,Y,X)\\&amp;= E _ {y\sim p _ {data}(y)}[log(D _ Y(y))] + E _ {x\sim p _ {data}(x)}[log(1-D _ Y(G(x)))]\\&amp;+ E _ {x\sim p _ {data}(x)}[log(D _ X(x))] + E _ {y\sim p _ {data}(y)}[log(1-D _ X(F(Y)))]\end{align} \tag{5}\]</span></li><li><strong>Cycle Consistency Loss</strong><br>为了保证映射网络的映射准确性，考虑到 \(x\to G(x)\to F(G(x))\approx x \) 以及 \(y\to F(y)\to G(F(y))\approx y \)，设计 cycle loss： <span class="math display">\[\mathcal{L} _ {cyc}(G,F)= E _ {x\sim p _ {data}(x)}\Vert F(G(x))-x\Vert + E _ {y\sim p _ {data}(y)}\Vert G(F(y))-y\Vert \tag{6}\]</span></li></ol><p>总的 Loss 为： <span class="math display">\[\mathcal{L} _ (G,F,D _ X, D _ Y)=\mathcal{L} _ {GAN}(G, D _ Y,X,Y)+\mathcal{L} _ {GAN}(F, D _ X,Y,X)+\lambda \mathcal{L} _ {cyc}(G,F) \tag{7}\]</span></p><h2 id="其它资料">2. 其它资料</h2><p>　　上面介绍了三个 GAN 基本网络，尤其是 Cycle-GAN，是高分辨率图像无监督 domain-transfer 的基础，应用相当广泛。本文介绍相对较简单，<a href="#4" id="4ref">[4]</a> 详细介绍了 GAN 的来龙去脉。代码则可以参考 <a href="#5" id="5ref">[5]</a> ，收录的 GAN 网络非常详细。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Goodfellow, Ian, et al. &quot;Generative adversarial nets.&quot; Advances in neural information processing systems. 2014.<br><a id="2" href="#2ref">[2]</a> Mirza, Mehdi, and Simon Osindero. &quot;Conditional generative adversarial nets.&quot; arXiv preprint arXiv:1411.1784 (2014).<br><a id="3" href="#3ref">[3]</a> Zhu, Jun-Yan, et al. &quot;Unpaired image-to-image translation using cycle-consistent adversarial networks.&quot; Proceedings of the IEEE international conference on computer vision. 2017.<br><a id="4" href="#4ref">[4]</a> http://www.gwylab.com/note-gans.html<br><a id="5" href="#5ref">[5]</a> https://github.com/eriklindernoren/PyTorch-GAN</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Generative Adversarial Nets(GAN) 能将某个分布的数据映射到另一组数据形成的分布空间内。这在某些领域非常有用，如：图像去噪，图像去雨雾，图像去模糊，图像低光照增强等。&lt;strong&gt;自动驾驶中，图像去雨雾与低光照增强非常关键，GAN 能在没
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Point-based 3D Detetection</title>
    <link href="https://leijiezhang001.github.io/Point-based-3D-Det/"/>
    <id>https://leijiezhang001.github.io/Point-based-3D-Det/</id>
    <published>2020-02-29T04:30:15.000Z</published>
    <updated>2020-03-01T07:42:25.374Z</updated>
    
    <content type="html"><![CDATA[<p>　　基于激光点云的 3D 目标检测是自动驾驶系统中的核心感知模块。由于点云的稀疏性以及空间结构的无序性，一系列 Voxel-based 3D 检测方法得以发展：<a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a>，<a href="/paperreading-Fast-and-Furious/" title="FaF">FaF</a>，<a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 等。然而 Voxel-based 方法需要预定义空间栅格的分辨率，其特征提取的有效性依赖于空间分辨率。同时在点云语义分割领域，对点云的点级别特征提取方法研究较为广泛，<a href="/PointCloud-Feature-Extraction/" title="PointCloud Feature Extraction">PointCloud Feature Extraction</a> 中已经较详细的介绍了针对点云的点级别特征提取方法，<a href="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/" title="Grid-GCN">Grid-GCN</a> 提出了几种策略来加速特征提取。<br>　　由此高效的 Point-based 3D 检测方法成为可能，这种方法首先提取点级别的特征(相比 Voxel-based，理论上没有信息损失)，然后用点级别的 Anchor-based 或 Anchor-free 方法作 3D 检测。</p><h2 id="anchor-based">1. Anchor-based</h2><h3 id="ipod1">1.1. IPOD<a href="#1" id="1ref"><sup>[1]</sup></a></h3><p><img src="/Point-based-3D-Det/ipod.png" width="90%" height="90%" title="图 1. IPOD Framework"> 　　如图 1. 所示， IPOD 与 F-PointNet 类似，只不过 IPOD 在俯视图下生成 Proposal 取点，而 F-PointNet 是直接在锥形视野的点云中作分割。IPOD 由三部分组成：</p><ol type="1"><li><strong>Semantic Segmentation</strong><br>目的是将点云中的背景点过滤掉，只生成前景点的 Anchor。作者采用图像语义分割的方法，这里也可直接用点云分割来做；</li><li><strong>Point-based Proposal Generation</strong><br>生成点级别的候选框，去掉冗余的候选框；</li><li><strong>Head for Classification and Regression</strong><br>根据候选框，提取特征，作分类和回归；</li></ol><p>这里的前两步是要得到少量但又能保证召回率的 Proposal，其中 Anchor 是根据每个点来设置的，然后作 NMS 操作，这里不做展开。 <img src="/Point-based-3D-Det/proposal_feat.png" width="80%" height="80%" title="图 2. Proposal Feature Generation"> 　　如图 2. 所示，每个 Proposal 提取出点云信息，然后通过 PointNet++ 直接来预测该 Proposal 的 3D 属性。这里用到了 T-Net(Spatial Transformation Network 的一种) 将点云变换到规范坐标系(Canonical coordinates)，这个套路用的也比较多。其它细节就是正常的 3D 属性回归策略，不作展开。</p><h3 id="std2">1.2. STD<a href="#2" id="2ref"><sup>[2]</sup></a></h3><p><img src="/Point-based-3D-Det/STD.png" width="80%" height="80%" title="图 3. STD Framework"> 　　如图 3. 所示，STD 模块有：</p><ol type="1"><li><strong>Backbone</strong><br>用 PointNet++ 提取点级别特征以及作点级别的 Classification；</li><li><strong>PGM(Proposal Generation Module)</strong><br>根据点级别的分类结果，对目标点设计球状 Spherical Anchor；不同类别设计不同的球状 Anchor 半径。将球状 Anchor 里面的点收集起来，作坐标规范化并且 concate 点级别特征，然后用 PointNet 来预测实际的矩形 proposal：包括中心 Offsets 以及 size offsets。同时对角度进行预测，角度预测通过分类加预测 Offsets 实现。</li><li><strong>Proposal Feature Generation</strong><br>有了 proposal 后，其实可以直接通过 PointNet 作进一步的预测及分类，但是作者为了加速，这时候采用了 Voxel Feature Encoding。将 proposal 里面的点都转换到中心点坐标系，然后栅格化提取特征；</li><li><strong>Box Prediction</strong><br>除了通常的类别预测以及 3D Box 相关属性的 Offsets 预测，作者还加入了与真值的 IoU 预测，该 IoU 值与类别分数相乘作为最终的该预测分数(这个在 2D Detection 中已经有应用)。</li></ol><h2 id="anchor-free">2. Anchor-free</h2><h3 id="pointrcnn3">2.1. PointRCNN<a href="#3" id="3ref"><sup>[3]</sup></a></h3><p><img src="/Point-based-3D-Det/PointRCNN.png" width="80%" height="80%" title="图 4. PointRCNN Framework"> 　　如图 4. 所示，PointRCNN 是一个 two-stage 3D 检测方法，类似 Faster-RCNN，其由 Bottom-up 3D Proposal Generation 和 Canonical 3D Box Refinement 两个模块组成。</p><h4 id="bottom-up-3d-proposal-generation">2.1.1 Bottom-up 3D Proposal Generation</h4><p>　　Proposal 的生成要求是，数量少，召回率高。3D Anchor 由于要覆盖 3D 空间，所以数量会很大(如 AVOD)，本文采用目标点生成 Proposal 的方法。与 IPOD，STD 类似，首先对点云进行点级别的特征提取并作前景分割(或语义分割)，对前景的每个点用 Bin-based 方法生成 3D proposal。由此在生成尽量少的 Proposal 下，保证目标的高召回率。<br>　　点级别的特征提取及前景分割，可以采用任意的语义分割网络，这里前景的真值即为目标框内的点云，用 Focal Loss 来平衡正负样本。<br><img src="/Point-based-3D-Det/bin-based.png" width="60%" height="60%" title="图 5. Bin-based Localization"> 　　如图 5. 所示，对每个前景点用 Bin-based 方法生成 proposal。将平面的 \(x,z\) (与一般的雷达坐标系不同) 方向分成若干个 bin，然后对每个前景点，预测目标中心点属于哪个 bin，以及中心点与该 bin 的 Offsets(与角度处理的方式非常像)。针对尺寸，预测该类别平均尺寸的 Residual；针对角度，还是分解成分类加回归任务进行处理。最后再作 NMS 即可得到较少的 Proposal，给到下一模块作 refine。本模块的 Loss 设计为： <span class="math display">\[\begin{align}\mathcal{L} _ 1 &amp;= \mathcal{L} _ {seg} + \mathcal{L} _ {proposal} \\&amp;= \mathcal{L} _ {seg} + \frac{1}{N _ {pos}} \sum _ {p\in pos} \left(\mathcal{L} _ {bin} ^ {(p)} + \mathcal{L} _ {res} ^ {(p)}\right) \\&amp;= \mathcal{L} _ {seg} + \sum _ {u\in{\{x,z,\theta\}}} \left(\mathcal{F} _ {cls}(\widehat{bin} _ u^{(p)}, bin _ u^{(p)})+\mathcal{F} _ {reg}(\widehat{res} _ u^{(p)}, res _ u^{(p)})\right) + \sum _ {v\in\{y,h,w,l\}} \mathcal{F} _ {reg}(\widehat{res} _ v^{(p)}, res _ v^{(p)})\\\tag{1}\end{align}\]</span> 其中 \(\mathcal{F} _ {cls}, \mathcal{F} _ {reg}\) 分别为 cross-entropy Loss 和 smooth L1 Loss。</p><h4 id="canonical-3d-box-refinement">2.1.2 Canonical 3D Box Refinement</h4><p>　　有了 3D proposal 后，经过 Point Cloud Region Pooling 提取该 proposal 的点特征，步骤如下：先对 proposal 进行一定程度的扩大，然后提取内部点的 semantic features，foreground mask score，Point distance等。由此获得每个 proposal 的点及点特征，用来作 3D Box Refinement。<br><img src="/Point-based-3D-Det/canonical.png" width="60%" height="60%" title="图 6. Canonical Transformation"> 　　如图 4. 所示，为了更好的学习 proposal 的局部空间特征，增加每个 proposal 在自身 Canonical 坐标系下的空间点。Canonical 变换如图 6. 所示，因为这里每个 proposal 的位置及角度已经有了，所以直接对其内的点作变换。如果没有，那就需要 STN(T-Net) 来学习这个变换。<br>　　Loss 也是在 Canonical 坐标系下计算的，假设 proposal：\(\mathrm{b _ i} = (x _ i,y _ i,z _ i,h _ i,w _ i,l _ i,\theta _ i)\)，真值: \(\mathrm{b} _ i^{gt} = (x _ i^{gt}, y _ i^{gt},z _ i^{gt},h _ i^{gt},w _ i^{gt},l _ i^{gt},\theta _ i^{gt})\)。那么两者变换到 Canonical 坐标系后： <span class="math display">\[\begin{align}\mathrm{\tilde{b}} _ i &amp;=(0,0,0,h _ i,w _ i,l _ i,0) \\\mathrm{\tilde{b}} _ i^{gt} &amp;= (x _ i^{gt}-x _ i, y _ i^{gt}-y _ i,z _ i^{gt}-z _ i,h _ i^{gt},w _ i^{gt},l _ i^{gt},\theta _ i^{gt}-\theta _ i)\tag{2}\end{align}\]</span> 对于中心点，还是 bin 分类加 Residual 回归，但是可以减少 bin 的尺度；对于尺寸，还是回归 Residual；对于角度，由于限定 positive 与 gt 的 IoU&gt;0.55，所以可以将回归的角度限定为 \((-\frac{\pi}{4},\frac{\pi}{4})\) 的范围，由此进行 bin 分类及 Residual 回归。最终本阶段的 Loss 为： <span class="math display">\[ \mathcal{L} _ 2= \frac{1}{N _ {pos}+ N _ {neg}} \sum _ {p\in all} \mathcal{L} _ {label} ^{(p)}+ \frac{1}{N _ {pos}} \sum _ {p\in pos} \left(\mathcal{\tilde{L}} _ {bin} ^ {(p)} + \mathcal{\tilde{L}} _ {res} ^ {(p)}\right) \tag{3}\]</span></p><h3 id="dssd4">2.2. 3DSSD<a href="#4" id="4ref"><sup>[4]</sup></a></h3><p><img src="/Point-based-3D-Det/3DSSD.png" width="100%" height="100%" title="图 7. 3DSSD Framework"> 　　如图 7. 所示，3DSSD 是 one-stage 网络，由 Backbone，Candidate Generation Layer，Head 构成。Backbone 作者提出了 Fusion Sampling 以提升前景点在采样时候的召回率。Candidate Generation Layer 中根据前景点，生成 3D box 预测的 Candidate 锚点。最后 Head 根据锚点，作 Anchor-free 的 3D Box 预测。</p><h4 id="fusion-sampling">2.2.1 Fusion Sampling</h4><p>　　为了扩大感受野提取局部特征，点云通常需要作下采样处理，一般采用 D-FPS 方法(点空间距离作为采样度量)，但是这样会使前景点大量丢失。前面几种方法不管是用图像分割还是点云分割，都会去除背景点云，保留前景点云以提高生成 Proposal 的召回率。<br>　　这里作者提出了 Feature-FPS，加入特征间的距离作为采样的度量方式。对于地面等背景，其特征基本类似，所以很容易就去除了；而对于目标区域，其点特征都不太一样，又得以保留。如果只保留同一目标的点，也会产生冗余，所以融合点特征距离及空间距离，设计采样度量方式为： <span class="math display">\[ C(A,B) = \lambda L _ d(A,B) + L _ f(A,B) \tag{4}\]</span> 　　因为 F-FPS 去除了大量的背景点，虽然有利于回归，但是不利于分类，所以设计了融合 D-FPS 和 F-FPS 的 Fusion Sampling 方法。如图 7. 所示，最终分别输出 F-FPS 与 D-FPS 的特征点。</p><h4 id="candidate-generation-layer">2.2.2 Candidate Generation Layer</h4><p><img src="/Point-based-3D-Det/candidate_pts.png" width="60%" height="60%" title="图 8. Candidate Generation"> 　　如图 8. 所示，根据 F-FPS 采样的点，在真值框中心点的监督下，用一个 T-Net 去学习采样点与中心点的变换。变换后的点即作为 Candidate 锚点。对每个 Candidate 点提取周围一定距离的 F-FPS 与 D-FPS(大量背景点利于分类)中点集的特征(空间坐标作归一化或变换到 Candidate 坐标系，类似 Canonical 坐标系)，然后作 MaxPool 提取该 Candidate 对应区域的特征。</p><h4 id="prediction-head">2.2.3 Prediction Head</h4><p>　　对于每个 Candidate 特征，作 3D Box 属性的回归。本文采用 Anchor-free 的方法。对于中心点，直接回归 Candidate 坐标点与真值框中心点的 Offsets；对于尺寸，直接回归与该类别平均尺寸的 Residual；对于角度，还是采用 bin 分类加 Residual 回归的策略。<br>　　这里期望的是 Candidate 点能接近目标框中心点，所以作者借鉴 FCOS(详见 <a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a>)中的 Center-ness Loss 来选取靠近中心点的 Candidate，真值 Label 为: <span class="math display">\[l _ {ctrness}=\sqrt[3]{\frac{\mathrm{min}(f,b)}{\mathrm{max}(f,b)}+\frac{\mathrm{min}(l,r)}{\mathrm{max}(l,r)}+\frac{\mathrm{min}(t,d)}{\mathrm{max}(t,d)}} \tag{5}\]</span> 其中 \(f,b,l,r,t,d\) 分别表示前后左右上下与中心点的距离。FCOS 中，加了一个与分类平行的分支来预测 Center-ness，最终的预测 Score 是分类 Score 乘以 Center-ness 得到(与预测 IoU 套路一样，本质上都是引入与真值的距离度量)，该预测 Score 用于之后的 NMS 等处理。本文则没有显示的预测 Center-ness，其直接将真值 Center-ness 与真值类别相乘，作为类别真值，所以一个类别分支即得到最终的预测 Score。<br>　　最终的 Loss 为： <span class="math display">\[L = \frac{1}{N _ c}\sum _ iL _ c(s _ i, u _ i) + \lambda _ 1\frac{1}{N _ p}\sum _ i[u _ i&gt;0]L _ r + \lambda _ 2\frac{1}{N _ p}L _ s \tag{5}\]</span> 其中 \(s _ i\) 为预测的类别 Score，\(u _ i\) 为经过 Center-ness 处理后的类别真值；\(L _ c\) 表示类别预测 Loss；\(L _ r\) 表示 3D Box Loss，包括中心点距离，尺寸，角度，8个角点位置；\(L _ s\) 表示生成 Candidate 点的 shift 变换 Loss。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Yang, Zetong, et al. &quot;Ipod: Intensive point-based object detector for point cloud.&quot; arXiv preprint arXiv:1812.05276 (2018).<br><a id="2" href="#2ref">[2]</a> Yang, Zetong, et al. &quot;Std: Sparse-to-dense 3d object detector for point cloud.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2019.<br><a id="3" href="#3ref">[3]</a> Shi, Shaoshuai, Xiaogang Wang, and Hongsheng Li. &quot;Pointrcnn: 3d object proposal generation and detection from point cloud.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br><a id="4" href="#4ref">[4]</a> Yang, Zetong, et al. &quot;3DSSD: Point-based 3D Single Stage Object Detector.&quot; arXiv preprint arXiv:2002.10187 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　基于激光点云的 3D 目标检测是自动驾驶系统中的核心感知模块。由于点云的稀疏性以及空间结构的无序性，一系列 Voxel-based 3D 检测方法得以发展：&lt;a href=&quot;/paperreading-PointPillars/&quot; title=&quot;PointPillars
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
  </entry>
  
  <entry>
    <title>MOT Multimodal Fusion</title>
    <link href="https://leijiezhang001.github.io/MOT-Fusion/"/>
    <id>https://leijiezhang001.github.io/MOT-Fusion/</id>
    <published>2020-02-19T04:35:40.000Z</published>
    <updated>2020-02-23T09:24:02.959Z</updated>
    
    <content type="html"><![CDATA[<p>　　同一传感器的目标状态估计在<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中已经有较详细的介绍。不同传感器在不同光照不同天气情况下，有不同的表现，比如相机在低光照下可靠性较差，而激光雷达能弥补这个缺陷。所以在目标状态估计中，多传感器融合非常重要，可以是<strong>数据前融合，特征级融合，目标状态后融合</strong>。本文关注目标状态后融合过程。</p><h2 id="问题描述">1. 问题描述</h2><p>　　考虑两个传感器 \(A,B\) (传感器可为相机，激光雷达，毫米波雷达等)检测输出的(也可以是经过滤波的)多目标分别为：\(A=\{A _ i\in\mathbb{R}^D|i=1,...,M\}\)，\(B=\{B _ i\in\mathbb{R}^D|i=1,...,N\}\)，其中 \(\mathbb{R}^D\) 表示目标状态的维数，如位置，速度，朝向，类别等。MOT 的多模态后融合问题即由此求解融合后结果 \(C=\{C _ i\in\mathbb{R}^D|i=1,...,L\}\)，该过程主要有三步：</p><ol type="1"><li>目标匹配/数据关联：从 \(A,B\) 中找出同一目标的两个多模态观测量，设匹配数为 \(K\)；</li><li>目标状态的多模态融合：对匹配上的同一目标的两个多模态观测进行融合；</li><li>整合目标，经过滤波输出最终结果，目标数目为 \(L=M+N-K\)；</li></ol><h2 id="目标匹配">2. 目标匹配</h2><p>　　本质上与单传感器下目标状态估计中前后帧的数据关联问题一致，这里的关键步骤是：</p><ol type="1"><li>提取每个目标的特征向量：可以是位置，速度，角度，CNN特征层等；</li><li>构建 cost function：对两个目标集合建立 Cost 矩阵；</li><li>匈牙利算法找出最优匹配；</li></ol><p>　　传统的 cost function 基本是向量的 Euclidean 距离或是 cosine 距离，<a href="#1" id="1ref">[1]</a> 提出了一种 Deep Affinity Network 来一次性解决两个目标集合的匹配问题。 <img src="/MOT-Fusion/affinity.png" width="70%" height="70%" title="图 1. Affinity Network"> 　　如图 1. 所示，两个目标集 \(A\in\mathbb{R}^{M\times D}\)，\(B\in\mathbb{R}^{N\times D}\)，扩展到维度 \(\mathbb{R}^{M\times N\times D}\)，相减后输入到网络中，预测出 affinity matrix，\(C\in\mathbb{R}^{M\times N}\)，其中 \(C _ {ij}=1\) 表示匹配上同一目标，否则认为是两个目标。这里关键是 Loss 的设计，最简单的 Loss 为： <span class="math display">\[L(A,B)=\frac{1}{MN}\sum _ {i=1} ^ {M}\sum _ {j=1}^N |C _ {ij}-G _ {ij}| \tag{1}\]</span> 其中 \(G\) 为亲和度矩阵的 groundtruth。实际对亲和度矩阵并没有 0-1 要求，最终是通过匈牙利算法找出匹配的，所以只要将同一目标的分数增大，不同目标的分数减小，最终即可选出匹配。由此设计 Loss： <span class="math display">\[L(A,B)=\sum _ {i,\,j;\,G _ {ij}=1} \left(\sum _ {k;\,G _ {ik}\neq 1}\mathrm{max}(0,C _ {ik}-C _ {ij}+m)+\sum _ {p;\,G _ {pj}\neq 1}\mathrm{max}(0,C _ {pj}-C _ {ij}+m)\right)\tag{2}\]</span> 其中 \(m\) 控制正负样本的相对大小。式(2)更容易使网络收敛。</p><h2 id="多模态融合">3. 多模态融合</h2><p>　　当多传感器检测的同一目标匹配上后，需要融合出一个最终的观测。可以采用卡尔曼滤波的方法，<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中的式(1)~(6)是时序下状态估计的迭代过程。对于多模态融合，虽然是同时获取的观测，但是融合过程类似，令测量矩阵 \(H _ k\) 为单位阵，所以可得卡尔曼增益： <span class="math display">\[K _ k=\frac{\bar{P} _ k}{\bar{P} _ k+R _ k} \tag{3}\]</span> 由此计算后验概率<a href="#2" id="2ref"><sup>[2]</sup></a>： <span class="math display">\[\begin{align}\hat{x} _ k &amp;=\bar{x} _ k+K(z_k-\bar{x}) = \frac{\bar{P} _ kz _ k + \bar{x} _ kR _ k}{\bar{P} _ k+R _ k} \tag{4}\\\hat{P} _ k &amp;=(I-KH _ k)\bar{P} _ k =\frac{\bar{P} _ kR _ k}{\bar{P} _ k+R _ k}\tag{5}\end{align}\]</span> 对于多模态输入 \(A,B\)，令 \(A = \bar{x} _ k,\sigma _ A^2 = \bar{P} _ k\)，\(B=z _ k,\sigma _ B^2 =R _ k\)，可得多模态融合结果为： <span class="math display">\[\begin{align}C &amp;= \frac{\sigma _ A^2B+\sigma _ B^2A}{\sigma _ A^2+\sigma _ B^2}\\\sigma _ C^2 &amp;= \frac{\sigma _ A^2\sigma _ B^2}{\sigma _ A^2+\sigma _ B^2}\\\tag{6}\end{align}\]</span> 式(6)等价于： <span class="math display">\[\begin{align}\sigma _ C^2 &amp;= \frac{\sigma _ A^2\sigma _ B^2}{\sigma _ A^2+\sigma _ B^2}\\C &amp;= \sigma _ C^2\left(\frac{A}{\sigma _ A^2}+\frac{B}{\sigma _ B^2}\right)\\\tag{7}\end{align}\]</span> 这是 BCM<a href="#3" id="3ref"><sup>[3]</sup></a>！卡尔曼滤波器也是在贝叶斯概率模型下导出来的，可见两个高斯分布的同一状态的观测量，均可通过 BCM 进行融合。<br>　　得到当前时刻多模态融合后的目标状态后，即可进一步作时序卡尔曼平滑获得最终估计的目标状态。<br>　　另一种融合方法是在 JPDAF(Joint Probabilistic Data Association Filter)<a href="#4" id="4ref"><sup>[4]</sup></a>框架下作两次 PDA 融合<a href="#5" id="5ref"><sup>[5]</sup></a>，JPDAF 是另一种数据关联(目标匹配)的方法，这里不作展开。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Kuang, Hongwu, et al. &quot;Multi-Modality Cascaded Fusion Technology for Autonomous Driving.&quot; arXiv preprint arXiv:2002.03138 (2020).<br><a id="2" href="#2ref">[2]</a> Fankhauser, Péter, et al. &quot;Robot-centric elevation mapping with uncertainty estimates.&quot; Mobile Service Robotics. 2014. 433-440.<br><a id="3" href="#3ref">[3]</a> Tresp, Volker. &quot;A Bayesian committee machine.&quot; Neural computation 12.11 (2000): 2719-2741.<br><a id="4" href="#4ref">[4]</a> Arya Senna Abdul Rachman, Arya. &quot;3D-LIDAR Multi Object Tracking for Autonomous Driving: Multi-target Detection and Tracking under Urban Road Uncertainties.&quot; (2017).<br><a id="5" href="#5ref">[5]</a> JRMOT: A Real-Time 3D Multi-Object Tracker and a New Large-Scale Dataset</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　同一传感器的目标状态估计在&lt;a href=&quot;/卡尔曼滤波器在三维目标状态估计中的应用/&quot; title=&quot;卡尔曼滤波器在三维目标状态估计中的应用&quot;&gt;卡尔曼滤波器在三维目标状态估计中的应用&lt;/a&gt;中已经有较详细的介绍。不同传感器在不同光照不同天气情况下，有不同的表现，比如相
      
    
    </summary>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/categories/MOT/"/>
    
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/tags/MOT/"/>
    
      <category term="tracking" scheme="https://leijiezhang001.github.io/tags/tracking/"/>
    
  </entry>
  
  <entry>
    <title>Model Compression - &#39;Quantization&#39;</title>
    <link href="https://leijiezhang001.github.io/Quantization/"/>
    <id>https://leijiezhang001.github.io/Quantization/</id>
    <published>2020-02-11T08:25:15.000Z</published>
    <updated>2020-02-29T04:25:32.683Z</updated>
    
    <content type="html"><![CDATA[<p>　　量化(Quantization)是模型压缩主要技术之一。因为模型训练后的权重及特征图基本符合高斯分布(特征图可能是混合高斯分布)，所以将 32-bit 的张量量化到低比特后也能保持模型输出的准确度。如果只量化模型的权重，那么只是减少了模型的存储及传输大小；只有同时量化权重及特征图(Weight &amp; Activation)，才能同时减少计算量。本文来详细描述下模型量化的细节。</p><h2 id="quantization-scheme">1. Quantization Scheme</h2><h3 id="fixed-point-approximation">1.1. Fixed Point Approximation</h3><p>　　设 Fixed Point 近似法中表示整数与小数的比特数分别为 \(\mathrm{IL,FL}\)，那么其可表达的浮点数范围为<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a>：\([-2^{\mathrm{IL-1}}, 2 ^ {\mathrm{IL-1}}-2 ^ {-\mathrm{FL}}]\)。这种方法很明显，精度较差且表达的浮点数范围有限。更进一步，可以针对不同的张量，用不同的 \(\mathrm{IL,FL}\)，即 Dynamic Fixed Point 近似法<a href="#1" id="1ref"><sup>[1]</sup></a>。综上，Fixed Point 近似法将一个浮点数表示为： <span class="math display">\[(-1)^s\cdot 2^{-\mathrm{FL}}\sum _ {i=0}^{\mathrm{IL+FL-2}}2^i\cdot x _ i \tag{1}\]</span> 其中 \(x_i\) 为第 \(i\) 比特位的值。<br>　　对于 Dynamic Fixed Point，首先保证整数部分不溢出，所以量化张量 \(X\) 时设计： <span class="math display">\[\mathrm{IL}=\lceil\mathrm{lg} _ 2(\mathop{\max}\limits _ {S} X + 1)\rceil \tag{2}\]</span> 剩下的比特位即为符号位与小数位。<br>　　用这种定点方式量化后，由式(1)可知，两数相乘可以转换为 bits shifts &amp; add 操作，极大提升计算效率。<br>　　Fixed Point 近似法精度有限，尤其是当所要表示的值较大时，小数位 \(\mathrm{FL}\) 只能分到很小，所以精度必然有较大损失。</p><h3 id="range-based-linear-approximation">1.2. Range-Based Linear Approximation</h3><p>　　不同于 Fixed Point 近似中小数位有一定限制(导致精度较差)，Range-Based Linear 近似法直接将浮点数通过一个高精度的 Scale 值映射到对应量化位数中，所以能保持非常高的精度。</p><h4 id="asymmetric-mode">1.2.1. Asymmetric Mode</h4><p><img src="/Quantization/asymmetric.png" width="40%" height="40%" title="图 1. Asymmetric Quantization"> 　　如图 1. 所示，设浮点数为 \(r\)，那么 Asymmetric Linear Approximation 过程为<a href="#3" id="3ref"><sup>[3]</sup></a>： <span class="math display">\[q = round\left((r-r _ {min})\cdot\frac{2^n-1}{r _ {max}-r _ {min}}\right) = round(\frac{r}{S}-\frac{r _ {min}}{S}) \tag{3}\]</span> 等价于<a href="#4" id="4ref"><sup>[4]</sup></a>： <span class="math display">\[r = S(q-Z) \tag{4}\]</span> 其中 \(S\) 为映射的 Scale 参数，\(Z\) 表示零值被量化的值。 <img src="/Quantization/conv.png" width="40%" height="40%" title="图 2. Convolution Operator"> 　　如图 2. 所示，卷积操作可转化为矩阵相乘运算，接下来我们来推导量化后的矩阵相乘运算。假设两个 \(N\times N\) 矩阵相乘：\(r _ 3=r _ 1\cdot r _ 2\)。令 \(r _ \alpha ^{(i,j)}\) 表示矩阵 \(r _ \alpha\) 第 \((i,j)\) 个元素，\(1\leq i,j\leq N\)。矩阵张量对应的量化参数为 \(S _ \alpha,Z _ \alpha\)，对应的量化后的元素表示为 \(q _ \alpha ^{(i,j)}\)： <span class="math display">\[r _ \alpha ^{(i,j)} = S _ \alpha\left(q _ \alpha ^{(i,j)}-Z _ \alpha\right) \tag{5}\]</span> bias 量化参数设为 \(S _ b=S _ 1S _ 2,Z _ b=0\)，那么卷积运算(矩阵相乘)可表示为： <span class="math display">\[S _ 3\left(q _ 3 ^{(i,k)}-Z _ 3\right) = \sum _ {j=1} ^N S _ 1\left(q _ 1 ^{(i,j)}-Z _ 1\right)S _ 2\left(q _ 2 ^{(j,k)}-Z _ 2\right) + S _ b(q _ b^{(i)} - Z _ b)\tag{6}\]</span> 等价于： <span class="math display">\[\begin{align}q _ 3 ^{(i,k)} &amp;= Z _ 3+M\left(\sum _ {j=1} ^N \left(q _ 1 ^{(i,j)}-Z _ 1\right)\left(q _ 2 ^{(j,k)}-Z _ 2\right)+ \frac{S _ b}{S _ 1S _ 2}q _ b^{(i)}\right) \\&amp;= Z _ 3+M\left(NZ _ 1Z _ 2- Z _ 1\sum _ {j=1}^Nq _ 2^{(j,k)}-Z _ 2\sum _ {j=1}^Nq _ 1^{(i,j)}+\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ \frac{S _ b}{S _ 1S _ 2}q _ b^{(i)}\right)  \\&amp;= Z _ 3+M\left(NZ _ 1Z _ 2- Z _ 1\sum _ {j=1}^Nq _ 2^{(j,k)}-Z _ 2\sum _ {j=1}^Nq _ 1^{(i,j)}+\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ q _ b^{(i)}\right)\tag{7}\end{align}\]</span> 其中 \(M=\frac{S _ 1S _ 2}{S _ 3}\) 可以离线计算，为上式唯一的浮点数。经验上可知 \(M\in(0,1)\)，进一步可将其表示为： <span class="math display">\[M\approx 2^{-n}M _ 0 \tag{8}\]</span> 假设 \(m\) 是能表示 \(M _ 0\) 的位数( int32 硬件下，\(m\) 可为 32)，那么有 \(2 ^ {n} M \leq 2 ^m -1\)，故： <span class="math display">\[\left\{\begin{array}{l}n = \left\lfloor\mathrm{log} _ 2\frac{2 ^ m-1}{M}\right\rfloor \\M _ 0 = \left\lfloor 2 ^ nM\right\rfloor\end{array}\tag{9}\right.\]</span> 由此，乘以 \(M _ 0\) 可以用定点乘法实现，乘以 \(2 ^{-n}\) 可以用高效的位运算实现。式(7)中核心的计算为两个量化向量的乘加运算：\(\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}\)，其可通过传统的特定位数的 BLAS 库完成。<br>　　具体的，令矩阵张量(卷积滤波器权重及特征图)量化为 8-bit，那么 8-bit 乘法需要用 32-bit 的累加器，即： <span class="math display">\[\mathrm{int32 += uint8 * uint8} \tag{10}\]</span> 所以式(7)中每一项累加时都是 32-bit 的，bias 也是量化为 32-bit 或是 rescale 到 32-bit，即 \(S _ b=S _ 1S _ 2,Z _ b=0\)。</p><h4 id="symmetric-mode">1.2.2. Symmetric Mode</h4><p><img src="/Quantization/symmetric.png" width="40%" height="40%" title="图 3. Symmetric Quantization"> 　　这种模式下最大最小值绝对值取相同值 \(R\) (该值可为任意值)，那么量化表示为： <span class="math display">\[r = Sq \tag{11}\]</span> Full Range 下 \(S = \frac{R}{(2^n-1)/2}\)(8-bit 则量化范围为 [-128,127]，Range 范围为 255)，Restricted Range 则 \(S = \frac{R}{2^{n-1}-1}\)(8-bit 量化范围为[-127,127]，Range 范围为 254)。Full Range 精度更高，PyTorch，ONNX 采用这种方式；TensorFlow，TensorRT，MKL-DNN 则采用 Restricted Range 量化方式。<br>　　由此式(7)简化为： <span class="math display">\[q _ 3 ^{(i,k)} = M\left(\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ q _ b^{(i)}\right) \tag{12}\]</span> 实现更加简单。</p><h2 id="quantization-alogorithm">2. Quantization Alogorithm</h2><h3 id="post-training-quantization">2.1. Post-Training Quantization</h3><p>　　训练好的模型，可以直接对其权重进行量化，而对于特征的量化，则需要一个 Calibration 数据集来统计特征数值的分布，然后对其进行量化。<br>　　量化参数的搜索，可以根据量化后的模型好坏进行 Loss 构建：</p><ol type="1"><li><strong>任务级别损失函数</strong>：直接根据特定任务的指标来搜索及评价量化参数；</li><li><strong>张量级别损失函数</strong>：设计量化后的张量与原始张量的分布相似度，或者说信息损失度，如 KL-divergence 等度量方法；</li></ol><h3 id="quantization-aware-training">2.2. Quantization-Aware Training</h3><p>　　将训练好的模型直接进行量化，可能会导致对应的任务准确度下降，尤其对表达能力有限的小模型而言，以下情况会导致量化后模型准确度下降：</p><ol type="1"><li>权重张量中数值差异 100 倍以上，导致小数值的量化误差较大；</li><li>权重张量中有 outlier 值，导致其它值的量化误差较大；</li></ol><p>而直接在训练的时候进行量化，可以保证完成模型训练也就得到了对应的高准确率的量化模型。 <img src="/Quantization/quantization-aware.png" width="80%" height="80%" title="图 4. Quantization-Aware Training Framework"> 　　如图 4. 所示，<a href="#4" id="3ref">[4]</a> 提出了一种 Quantization-Aware Training 的框架，权重和特征图均维护 float32 及 int8 数值，前向传播采用 int8 伪量化运算，反向传播更新权重的 float32 值，并作量化。 <img src="/Quantization/quantized_alg.png" width="60%" height="60%" title="图 5. Quantization-Aware Training Pipline"> 　　如图 5. 所示，<a href="#4" id="3ref">[4]</a> 基于 TensorFlow 实现了一种 Quantization-Aware Training 的算法，其步骤为：</p><ol type="1"><li>建立一个浮点模型的 graph；</li><li>在 graph 中加入伪量化操作；</li><li>用伪量化的方式训练得到精度与浮点模型差不多的量化模型；</li><li>建立并优化量化的 Inference 模型 graph；</li><li>在量化引擎上作模型的 Inference；</li></ol><h4 id="simulated-quantization">2.2.1. Simulated Quantization</h4><p>　　这里采用 Asymmetric Linear Approximation 量化策略。对于权重，卷积运算时，先做伪量化操作，并且如果有 batch-normalization，则将其合并入卷积核权重中；对于特征图(Activations)，前向传播时都先做伪量化操作。伪量化操作如下<a href="#4" id="4ref"><sup>[4]</sup></a><a href="#5" id="5ref"><sup>[5]</sup></a>： <span class="math display">\[\begin{align}\mathrm{clamp}(r\;;a,b) &amp;:= \mathrm{min}(\mathrm{max}(r,a),b) \\s(a,b,n) &amp;:= \frac{b-a}{2 ^n-1} \\q(r\;;a,b,n) &amp;:= \left\lfloor\frac{\mathrm{clamp}(r\;;a,b)-a}{s(a,b,n)}\right\rceil s(a,b,n)+a\\\tag{13}\end{align}\]</span> 其中 \([a,b]\) 是 被量化的浮点范围(可以是 \([r _ {min}, r _ {max}]\))，\(q(r\;;a,b,n)\) 即为浮点数 \(r\) 的伪量化表示，也是浮点数。</p><h4 id="learning-quantization-ranges">2.2.2. Learning Quantization Ranges</h4><p>　　训练时，每次迭代，权重与特征图都要作伪量化处理，所以每次要确定量化参数。对于权重，因为其服从均值为零的高斯分布，所以 \([a,b]\) 直接设为其最大值与最小值即可；对于特征图，其数值与输入相关，所以策略为：刚开始训练的时候不对其作量化处理，之后用 EMA(Exponential Moving Averages) 对量化参数进行平滑，去除特征图输出突变的影响。</p><h4 id="batch-normalization-folding">2.2.3. Batch Normalization Folding</h4><p>　　作 Inference 或者说前向传播时，BN 可以合并入卷积核权重中，所以在量化前，先要将其合并，然后权重就仅限于卷积操作中。对于每个卷积 filter，其生成特征图以及 BN 过程如下： <span class="math display">\[\begin{align}\hat{x} _ i &amp;\gets wx _ i+b\\\mu _ B &amp;\gets \frac{1}{m}\sum _ {i=1}^m \hat{x} _ i\\\sigma^2 _ B &amp;\gets \frac{1}{m}\sum _ {i=1}^m(\hat{x} _ i-\mu _ B)^2\\y _ i &amp;\gets \gamma\frac{\hat{x} _ i-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\\tag{14}\end{align}\]</span> 由此可得： <span class="math display">\[\begin{align}y _ i &amp;\gets \gamma\frac{\hat{x} _ i-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\&amp;\gets \gamma\frac{wx _ i+b-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\&amp;\gets \frac{\gamma wx _ i}{\sqrt{\sigma^2 _ B+\epsilon}} +\frac{\gamma(b-\mu _ B)}{\sqrt{\sigma^2 _ B+\epsilon}}+ \beta\\\tag{15}\end{align}\]</span> 由此可知作 Inference 时，BN 参数 \(\mu _ B,\sigma^2 _ B,\gamma, \beta\) 可合并到卷积 Filter 参数中： <span class="math display">\[\left\{\begin{array}{l}\hat{w} = \frac{\gamma w}{\sqrt{\sigma^2 _ B+\epsilon}}\\\hat{b} = \frac{\gamma(b-\mu _ B)}{\sqrt{\sigma^2 _ B+\epsilon}}+ \beta\\\end{array}\tag{16}\right.\]</span></p><h3 id="trained-quantization-thresholds">2.3. Trained Quantization Thresholds</h3><p>　　Post-Training Quantization 以及 Quantization-Aware Training 都是直接对张量的分析来搜索或近似求解量化参数的，Trained Quantization Thresholds 则在训练的时候同时训练得到量化参数。</p><h4 id="pact">2.3.1. PACT</h4><p>　　PACT<a href="#13" id="13ref"><sup>[13]</sup></a> 定义了激活函数输出的最大值，该最大值就是 Symmetric 量化中的激活层量化参数 Scale。具体的，改进 Relu： <span class="math display">\[ y = \mathrm{PACT}(x) = 0.5(|x|-|x-\alpha|+\alpha)=\left\{\begin{array}{l}0, \;\;x\in(-\infty,0)\\x, \;\;x\in[0,\alpha]\\\alpha, \;\;x\in[\alpha, +\infty)\end{array}\tag{17}\right.\]</span> 对应的量化参数偏导为： <span class="math display">\[\frac{\partial y _ q(x;\,\alpha)}{\partial \alpha}=\left\{\begin{array}{l}0, \;\;x\in(-\infty, \alpha)\\1, \;\;x\in[\alpha,+\infty)\end{array}\tag{18}\right.\]</span></p><h4 id="tqt">2.3.2. TQT</h4><p>　　TQT(Trained Quantization Thresholds)<a href="#14" id="14ref"><sup>[14]</sup></a>则提出了一种同时学习权重和激活函数的量化参数的方法。为了简化，其采用 Linear Symmetric Approximation，且 Scale 参数限定为 \(s=2 ^ {-f}\)，由式(8,9)可知，消除了定点乘法运算。前向传播与式(13)并无差异，对每个权重即激活层作 scale，round，saturate，de-quant 操作。反向传播则需要对量化值 \(q(x;s)\) 求导，量化值表示为： <span class="math display">\[q(x;s)=\left\{\begin{array}{l}\left\lfloor\frac{x}{s}\right\rceil \cdot s, \;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\n\cdot s, \;\;\;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\p\cdot s, \;\;\;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\\end{array}\tag{19}\right.\]</span> 其中 \(n,p\) 分别为量化值域的最小最大值。定义 \(\frac{\partial \lfloor x\rceil}{\partial x} = 1\)，那么对 Scale 的偏导为： <span class="math display">\[\nabla _ sq(x;s)=\left\{\begin{array}{l}\left\lfloor\frac{x}{s}\right\rceil - \frac{x}{s}, &amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\n, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\p, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\\end{array}\tag{20}\right.\]</span> 为了稳定性，令 \(\nabla _ {(\mathrm{log} _ 2 t)} s = s\, \mathrm{In}(2)\)，则： <span class="math display">\[\nabla _ {(\mathrm{log} _ 2t)}q(x;s)= s\,\mathrm{In}(2)\cdot\left\{\begin{array}{l}\left\lfloor\frac{x}{s}\right\rceil - \frac{x}{s}, &amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\n, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\p, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\\end{array}\tag{21}\right.\]</span> 对应的，对输入 \(x\) 的偏导数为： <span class="math display">\[\nabla _ xq(x;s)=\left\{\begin{array}{l}1,&amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\0, &amp;\;otherwise\\\end{array}\tag{22}\right.\]</span></p><p>　　由此可与网络权重一起训练得到量化参数。Graffitist<a href="#15" id="15ref"><sup>[15]</sup></a>基于 TensorFlow 实现了上述算法；NNCF<a href="#16" id="16ref"><sup>[16]</sup></a>基于 Pytorch 实现了类似算法。</p><h2 id="quantized-framework">3. Quantized Framework</h2><p>　　不管是 Post-Training Quantization 还是 Quantization-Aware Training，算法端都还是用伪量化操作实现的，部署时就必须用 INT8 引擎。据我所知目前 INT8 引擎有：</p><ol type="1"><li>DSP/加速芯片平台<br>目测没有开源的，大家自个玩自个的；</li><li>CPU 平台<br>Google 的 TensorFlow Lite<a href="#6" id="6ref"><sup>[6]</sup></a>，Facebook 的 QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>，Tencent 的 NCNN<a href="#9" id="9ref"><sup>[9]</sup></a>。</li><li>GPU 平台<br>NVIDIA 的 TensorRT<a href="#10" id="10ref"><sup>[10]</sup></a>，TVM<a href="#11" id="11ref"><sup>[11]</sup></a>。</li></ol><p>而伪量化框架则在深度学习框架(caffe，pytorch，tensorflow)中开源的较多，如基于 pytorch 的 distiller<a href="#3" id="3ref"><sup>[3]</sup></a>，NNCF<a href="#16" id="16ref"><sup>[16]</sup></a>。<br>　　对于 ARM 平台，INT8 引擎会通过 NEON 指令集加速；对于 x86 平台，INT8 引擎会通过 SSE 加速；对于 NVIDIA GPU 平台，则通过 dp4a<a href="#12" id="12ref"><sup>[12]</sup></a> 矩阵运算库加速。dp4a 实现了基础的 INT8 矩阵相乘操作，目前 cuDNN，cuBLAS，TensorRT 均采用该指令集。下面对 INT8 引擎作简要阐述。</p><h3 id="ristretto1">3.1. Ristretto<a href="#1" id="1ref"><sup>[1]</sup></a></h3><p>　　Ristretto 是一种基于 (Dynamix) Fixed Point Approximation, Post-Training Quantization 的量化框架，其精度有限，量化的 Inference 引擎可用 bits shifts &amp; add 操作实现，比较适合应用于 DSP 等嵌入式平台。</p><h3 id="tensorflow-lite6qnnpack8ncnn9">3.2. TensorFlow Lite<a href="#6" id="6ref"><sup>[6]</sup></a>/QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>/NCNN<a href="#9" id="9ref"><sup>[9]</sup></a></h3><p>　　TensorFlow Lite 是 Google 基于 TensorFlow 开发的针对移动嵌入式 CPU 平台的模型(量化)加速框架，其实现在 2.2 小节中已有详细的描述，有较高精度，<a href="#4" id="4ref">[4]</a> 实现了 Quantization-Aware Training。其中 INT8 矩阵运算采用了 gemmlowp<a href="#7" id="7ref"><sup>[7]</sup></a>。<br>　　移动端的 CPU 的量化计算引擎开源的也比较多，如 Facebook 的 QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>，腾讯的 ncnn-int8<a href="#9" id="9ref"><sup>[9]</sup></a>。</p><h3 id="tensorrt10">3.3. TensorRT<a href="#10" id="10ref"><sup>[10]</sup></a></h3><p>　　TensorRT 是 NVIDIA 基于 GPU 平台的模型(量化)加速框架，其基于 Symmetric Linear Approximation 量化策略，并且只支持 Post-Training Quantization，其内部可能直接调用 dp4a，也可能调用 cuDNN 或 cuBLAS。TVM<a href="#11" id="11ref"><sup>[11]</sup></a> 调用 dp4a 实现了基于 python 的 INT8 引擎，对于部署来讲没有 TensorRT 高效。<br>　　对于特征图的量化参数 \(S\) 的搜索，其使用张量级别的损失函数，最小化量化前后特征图值分布差异性的方式，KL-divergency，即两个分布的相对熵。假设连个分布 \(P,Q\)，那么两者的相对熵为： <span class="math display">\[E(P,Q) = \sum _ i P(i)\cdot\mathrm{log}\left(\frac{P(i)}{Q(i)}\right) \tag{23}\]</span> 熵越大，表示两个分布差异性越大，即量化后信息损失越大。这里也可以采用其它能描述两个分布差异性的方式，如 EMD。整个量化参数搜索过程为：</p><ol type="1"><li>准备训练好的 FP32 模型，以及一个作校正(Calibration)的数据集；</li><li>用 FP32 模型跑数据集，统计每个特征图的值分布；</li><li>对不同的量化参数，根据式(17)计算量化前后的相对熵；选择最优的量化参数；</li><li>根据最优的量化参数量化特征图得到量化模型(权重值分布比较集中，所以可以直接用最大值作为量化参数，具体还得看 TensorRT 怎么做的)；</li><li>保存量化参数为 Calibration Table，载入该值即可启动 INT8 引擎作量化 Inference；</li></ol><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Gysel, Philipp. &quot;Ristretto: Hardware-oriented approximation of convolutional neural networks.&quot; arXiv preprint arXiv:1605.06402 (2016).<br><a id="2" href="#2ref">[2]</a> Gupta, Suyog, et al. &quot;Deep learning with limited numerical precision.&quot; International Conference on Machine Learning. 2015.<br><a id="3" href="#3ref">[3]</a> https://nervanasystems.github.io/distiller/index.html<br><a id="4" href="#4ref">[4]</a> Jacob, Benoit, et al. &quot;Quantization and training of neural networks for efficient integer-arithmetic-only inference.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br><a id="5" href="#5ref">[5]</a> Krishnamoorthi, Raghuraman. &quot;Quantizing deep convolutional networks for efficient inference: A whitepaper.&quot; arXiv preprint arXiv:1806.08342 (2018).<br><a id="6" href="#6ref">[6]</a> https://www.tensorflow.org/mobile/tflite<br><a id="7" href="#7ref">[7]</a> https://github.com/google/gemmlowp<br><a id="8" href="#8ref">[8]</a> https://github.com/pytorch/QNNPACK<br><a id="9" href="#9ref">[9]</a> https://github.com/Tencent/ncnn/pull/487<br><a id="10" href="#10ref">[10]</a> Migacz, Szymon. &quot;8-bit inference with tensorrt.&quot; GPU technology conference. Vol. 2. No. 4. 2017.<br><a id="11" href="#11ref">[11]</a> https://tvm.apache.org/2019/04/29/opt-cuda-quantized<br><a id="12" href="#12ref">[12]</a> https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/<br><a id="13" href="#13ref">[13]</a> Choi, Jungwook, et al. &quot;Pact: Parameterized clipping activation for quantized neural networks.&quot; arXiv preprint arXiv:1805.06085 (2018).<br><a id="14" href="#14ref">[14]</a> Jain, Sambhav R., et al. &quot;Trained quantization thresholds for accurate and efficient neural network inference on fixed-point hardware.&quot; arXiv preprint arXiv:1903.08066 (2019).<br><a id="15" href="#15ref">[15]</a> https://github.com/Xilinx/graffitist<br><a id="16" href="#16ref">[16]</a> Kozlov, Alexander, et al. &quot;Neural Network Compression Framework for fast model inference.&quot; arXiv preprint arXiv:2002.08679 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　量化(Quantization)是模型压缩主要技术之一。因为模型训练后的权重及特征图基本符合高斯分布(特征图可能是混合高斯分布)，所以将 32-bit 的张量量化到低比特后也能保持模型输出的准确度。如果只量化模型的权重，那么只是减少了模型的存储及传输大小；只有同时量化权
      
    
    </summary>
    
      <category term="Model Compression" scheme="https://leijiezhang001.github.io/categories/Model-Compression/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Model Compression" scheme="https://leijiezhang001.github.io/tags/Model-Compression/"/>
    
  </entry>
  
</feed>
