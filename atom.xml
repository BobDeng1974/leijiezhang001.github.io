<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeijieZhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leijiezhang001.github.io/"/>
  <updated>2020-09-16T01:34:12.000Z</updated>
  <id>https://leijiezhang001.github.io/</id>
  
  <author>
    <name>Leijie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[paper_reading]-&quot;PnPNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-PnPNet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-PnPNet/</id>
    <published>2020-09-11T01:35:32.000Z</published>
    <updated>2020-09-16T01:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　自动驾驶的障碍物状态估计功能模块中，包含 perception/Detection，tracking，prediction 三个环节。传统的做法这三个环节是分步进行的，Detection 出目标框检测结果；Tracking 则作前后帧目标的数据关联然后用卡尔曼平滑并估计目标状态；Prediction 预测目标未来的运动轨迹。 <img src="/paper-reading-PnPNet/diff-pipe.png" width="60%" height="60%" title="图 1. Perception and Prediction"> 　　如图 1. 所示，(a) 代表传统的做法，每个步骤都是独立优化并出结果，这种方式将功能模块解耦，容易找到具体问题的位置，但是会降低算法找到最优解的概率；(b) 则将 Detection 与 Prediction 用同一个网络预测，然后用 Tracking 来平滑估计整个运动轨迹(代表方法是 <a href="/paperreading-Fast-and-Furious/" title="Fast and Furious">Fast and Furious</a>)，这种方法下 Tracking 中丰富的时序及空域特征信息没有作用于 Detection 和 Prediction；本文提出的 PnP<a href="#1" id="1ref"><sup>[1]</sup></a>方法则将三个环节作深度的特征再利用，即整个功能模块是 End-to-End 可训练的，更容易得到目标状态及预测的全局最优解，更容易处理遮挡等问题。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-PnPNet/framework.png" width="90%" height="90%" title="图 2. Framework"> 　　如图 2. 所示，PnP 网络包含 Detection、Tracking，Motion Forecasting 三个模块。网络输入为点云及 HD Map。检测模块包含一个任意的 3D 目标检测网络，以及一个存储历史 BEV 特征图的 Memory；Tracking 跟踪模块包含一个存储目标历史轨迹的 Memory，首先作 Track-Detection 的数据关联，然后优化目标历史轨迹并更新存储；Motion Forecasting 模块则根据历史轨迹作目标的运动预测。</p><h2 id="object-detection">2. Object Detection</h2><p>　　网络的输入为序列点云(本文采用 0.5s)及 HD Map，分别将点云在俯视图下体素化后在特征通道维度进行串联得到 \(\mathbf{x} ^ t\)，然后输入 Backbone 网络得到俯视图下特征图： <span class="math display">\[\mathcal{F} ^ t _ {bev}(\mathbf{x} ^ t) = \mathrm{CNN} _ {bev}(\mathbf{x} ^ t) \tag{1}\]</span> 最后加入 3D 目标检测头，得到 3D 目标框属性 \((u _ i ^ t, v _ i ^ t,w _ i,l _ i,\theta _ i ^ t)\) 的预测： <span class="math display">\[\mathcal{D} ^ t=\mathrm{CNN} _ {det}(\mathcal{F} ^ t _ {bev})\tag{2}\]</span></p><h2 id="discrete-continuous-tracking">3. Discrete-Continuous Tracking</h2><p>　　<strong>Tracking 模块包括离散的数据关联问题，以及连续的目标运动轨迹(状态)估计问题。</strong>目标运动轨迹的优化估计对之后的目标运动预测非常重要。</p><h3 id="trajectory-level-object-representation">3.1. Trajectory Level Object Representation</h3><p><img src="/paper-reading-PnPNet/trajectory.png" width="90%" height="90%" title="图 3. Trajectory Level Object Representation"> 　　Tracking 需要优化历史轨迹，Prediction 需要预测未来轨迹，所以轨迹级别的目标特征提取及表达非常重要。本文采用 LSTM 网络来表征。如图 3. 所示，对于轨迹 \(\mathcal{P} _ i ^ t=\mathcal{D} _ i ^ {t _ 0...t}\)，首先提取每个时刻目标的感知特征： <span class="math display">\[f _ i^{bev,t} = \mathrm{BilinearInterp}(\mathcal{F} _ {bev} ^ t,(u _ i ^ t, v _ i ^ t)) \tag{3}\]</span> 然后提取目标运动特征： <span class="math display">\[f _ i ^ {velocity,t}=(\dot{x} _ i ^ t,\dot{x} _ {ego} ^ t, \dot{\theta} _ {ego} ^ t)\tag{4}\]</span> 其中 \(\dot{x} _ i,\dot{x} _ {ego}\) 分别是第 \(i\) 个目标及本车的二维速度，通过位置差计算得到，对于新目标，将其设定为 0。由此得到第 \(i\) 个目标的特征： <span class="math display">\[f(\mathcal{D} _ i ^ t)=\mathrm{MLP} _ {merge}\left(f _ i^{bev,t},f _ i ^ {velocity,t}\right)\tag{5}\]</span> 最后通过 LSTM 网络来提取轨迹级别目标特征： <span class="math display">\[h(\mathcal{P} _ i ^ t)=\mathrm{LSTM}(f(\mathcal{D} _ i ^ {t _ 0...t}))\tag{6}\]</span></p><h3 id="data-association">3.2. Data Association</h3><p>　　当前时刻检测的目标数量为 \(N _ t\)，上一时刻目标轨迹数量为 \(M _ {t-1}\)，将二者关联匹配就是数据关联问题。这在有新目标出现以及目标出现遮挡的时候变得较为困难。类似传统方法，这里设计检测与跟踪轨迹的相似性矩阵 \(C\in\mathbb{R} ^ {N _ t\times (M _ {t-1}+N _ t)}\)(跟踪轨迹加入\(N _ t\)个目标是为了处理新出现目标的情况)： <span class="math display">\[C _ {i,j}=\left\{\begin{array}{l}\mathrm{MLP} _ {pair}\left(f(\mathcal{D} _ i ^ t),h(\mathcal{P} _ j ^ {t-1})\right) &amp;\;\; \mathrm{if}\; 1\leq j\leq M _ {t-1},\\\mathrm{MLP} _ {unary}\left(f(\mathcal{D} _ i ^ t)\right) &amp;\;\; \mathrm{if}\; j=  M _ {t-1} + i,\\-\mathrm{inf} &amp;\;\; \mathrm{otherwise}\end{array}\tag{7}\right.\]</span> 其中 \(\mathrm{MLP} _ {pair}\) 计算检测与跟踪轨迹的相似性分数，\(\mathrm{MLP} _ {unary}\) 计算目标是新出现的概率。有了该相似性矩阵，即可通过匈牙利算法求解最佳匹配对。<br>　　对于被遮挡的物体，跟踪轨迹在当前帧容易出现没有检测的情况，本文引入单目标跟踪的思想作跟踪搜索。设未匹配的跟踪轨迹为 \(\mathcal{P} _ j ^ {t-1}\)，那么根据上一帧该轨迹目标的位置 \(u _ j ^ {t-1}, v _ j ^ {t-1}\)，进行运动补偿后为 \(\tilde{u} _ j ^ {t}, \tilde{v} _ j ^ {t}\)，在其邻域 \(\Omega _ j\) 内寻找最优的检测(跟踪)结果 \(\tilde{\mathcal{D}} _ k ^ t\)： <span class="math display">\[k = \mathop{\arg\max}\limits _ {i\in\Omega _ j} \mathrm{MLP} _ {pair}\left(f(\tilde{\mathcal{D}} _ i ^ t),h(\mathcal{P} _ j ^ {t-1})\right)\tag{8}\]</span> 其中 \(\Omega _ j\) 设计为目标的最大假设速度，如 \(110 km/h\)。<br>　　最终可得到 \(N _ t+ K _ t\) 个目标轨迹，其中 \(K _ t\) 为未匹配的目标轨迹而通过单目标跟踪方法召回的轨迹数量。</p><h3 id="trajectory-estimation">3.3. Trajectory Estimation</h3><p>　　当前帧的观测加入到目标轨迹后，可进一步对目标轨迹作优化以减少 FP 以及提高轨迹定位精度。网络预测轨迹的置信度以及最近 \(T _ 0\) 时间内目标位置的残差： <span class="math display">\[\mathrm{score} _ i,\Delta u _ i ^ {t-T _ 0+1:t},\Delta v _ i ^ {t- T _ 0+1:t}=\mathrm{MLP} _ {refine}(h(\mathcal{P} _ i^t))\tag{9}\]</span> 其中 \(T _ 0\) 小于轨迹的总时间。最后用 NMS 去掉重叠的目标轨迹以消除 FP 与重叠项。</p><h2 id="motion-forecasting">4. Motion Forecasting</h2><p>　　根据优化后的目标轨迹，通过网络预测目标的未来轨迹： <span class="math display">\[\Delta u _ i^{t:t+\Delta T}, \Delta v _ i ^ {t:t+\Delta T}=\mathrm{MLP} _ {predict}(h(\mathcal{P} _ i^t))\tag{10}\]</span></p><h2 id="end-to-end-learning">5. End-to-End Learning</h2><p>　　整个网络多任务联合训练的 Loss 为： <span class="math display">\[\begin{align}\mathcal{L} &amp;= \mathcal{L} _ {detect} + \mathcal{L} _ {track} + \mathcal{L} _ {predict}\\&amp;= \mathcal{L} _ {detect} + \mathcal{L} _ {score} ^ {affinity} + \mathcal{L} _ {score} ^ {sot} + \mathcal{L} _ {socre} ^ {refine} + \mathcal{L} _ {reg} ^ {refine} + \mathcal{L} _ {predict}\end{align}\tag{11}\]</span> 其中 \(\mathcal{L} _ {score}\) 为 \(max-margin \;loss\): <span class="math display">\[\mathcal{L} _ {score} = \frac{1}{N _ {i,j}}\sum _ {i\in pos,j\in neg} \mathrm{max}(0,m-(a _ i-a _ j))\tag{12}\]</span> 对于 \(\mathcal{L} _ {score} ^ {affinity}\) 和 \(\mathcal{L} _ {score} ^ {sot}\)，计算正样本与所有负样本的 Loss；对于 \(\mathcal{L} _ {score} ^ {refine}\)，与真值框 IoU 较高的，则 score 较高，这样作 NMS 时可以该 score 为准则。</p><h2 id="reference">6. Reference</h2><p><a id="1" href="#1ref">[1]</a> Liang, Ming, et al. &quot;PnPNet: End-to-End Perception and Prediction with Tracking in the Loop.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　自动驾驶的障碍物状态估计功能模块中，包含 perception/Detection，tracking，prediction 三个环节。传统的做法这三个环节是分步进行的，Detection 出目标框检测结果；Tracking 则作前后帧目标的数据关联然后用卡尔曼平滑并估计
      
    
    </summary>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/categories/MOT/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/tags/MOT/"/>
    
      <category term="Prediction" scheme="https://leijiezhang001.github.io/tags/Prediction/"/>
    
  </entry>
  
  <entry>
    <title>自动驾驶系统之 Sensing</title>
    <link href="https://leijiezhang001.github.io/Self-Driving-Sensing/"/>
    <id>https://leijiezhang001.github.io/Self-Driving-Sensing/</id>
    <published>2020-09-10T03:09:33.000Z</published>
    <updated>2020-09-10T03:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文介绍了自动驾驶中基于多传感器融合的 Sensing 模块，请输入密码查看：" />    <label for="pass">本文介绍了自动驾驶中基于多传感器融合的 Sensing 模块，请输入密码查看：</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+lyG3+lBoDr34E3KaoX0p4DJVvBLxQ/i4=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      从零到一构建自动驾驶系统之 Sensing。
    
    </summary>
    
      <category term="Autonomous Driving System" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/"/>
    
      <category term="Sensing" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/Sensing/"/>
    
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
      <category term="Tracking" scheme="https://leijiezhang001.github.io/tags/Tracking/"/>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/tags/MOT/"/>
    
      <category term="Sensing" scheme="https://leijiezhang001.github.io/tags/Sensing/"/>
    
      <category term="Detection" scheme="https://leijiezhang001.github.io/tags/Detection/"/>
    
  </entry>
  
  <entry>
    <title>自动驾驶系统之 Localization</title>
    <link href="https://leijiezhang001.github.io/Self-Driving-Localization/"/>
    <id>https://leijiezhang001.github.io/Self-Driving-Localization/</id>
    <published>2020-09-10T03:08:01.000Z</published>
    <updated>2020-09-10T03:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文介绍了自动驾驶中基于多传感器融合的 Localization 模块，请输入密码查看：" />    <label for="pass">本文介绍了自动驾驶中基于多传感器融合的 Localization 模块，请输入密码查看：</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19F5L3CXaEq80FegG7fGZVbXFX+FNboXkQ=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      从零到一构建自动驾驶系统之 Localization。
    
    </summary>
    
      <category term="Autonomous Driving System" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/"/>
    
      <category term="Localization" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/Localization/"/>
    
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>自动驾驶系统之 Mapping</title>
    <link href="https://leijiezhang001.github.io/Self-Driving-Mapping/"/>
    <id>https://leijiezhang001.github.io/Self-Driving-Mapping/</id>
    <published>2020-09-10T02:49:01.000Z</published>
    <updated>2020-09-29T03:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="本文介绍了自动驾驶中用于定位、感知、规划的 Mapping 模块，请输入密码查看：" />    <label for="pass">本文介绍了自动驾驶中用于定位、感知、规划的 Mapping 模块，请输入密码查看：</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      从零到一构建自动驾驶系统之 Mapping。
    
    </summary>
    
      <category term="Autonomous Driving System" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/"/>
    
      <category term="Mapping" scheme="https://leijiezhang001.github.io/categories/Autonomous-Driving-System/Mapping/"/>
    
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>A General Framework for Uncertainty Estimation in Deep Learning</title>
    <link href="https://leijiezhang001.github.io/A-General-Framework-for-Uncertainty-Estimation-in-deep-learning/"/>
    <id>https://leijiezhang001.github.io/A-General-Framework-for-Uncertainty-Estimation-in-deep-learning/</id>
    <published>2020-09-04T01:16:44.000Z</published>
    <updated>2020-09-27T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Uncertainty 估计在深度学习网络预测中同样非常重要，因为我们不仅需要知道预测结果，还想知道该结果的不确定性。Uncertainty 可分为偶然不确定性(Aleatoric Uncertainty，详见 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a>) 以及认知不确定性(Epistemic Uncertainty，详见 <a href="/Epistemic-Uncertainty-for-Active-Learning/" title="Epistemic Uncertainty for Active Learning">Epistemic Uncertainty for Active Learning</a>)。<br>　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种同时估计偶然不确定性与认知不确定性的方法。对于网络输入 \(\mathbf{x}\)，输出的后验概率为 \(p(\mathbf{y}|\mathbf{x})\)，那么由 Aleatoric Uncertainty 和 Epistemic Uncertainty 构成的总的不确定性为 \(\sigma _ {tot} = \mathbf{Var} _ {p(\mathbf{y}|\mathbf{x})}(\mathbf{y})\)。</p><h2 id="aleatoric-uncertaintydata-uncertainty">1. Aleatoric Uncertainty(Data Uncertainty)</h2><p>　　假设传感器得到的数据符合噪音水平 \(\mathbf{v}\) 的高斯分布，那么输入网络的数据 \(\mathbf{z}\) 与其真实数据 \(\mathbf{x}\) 的关系为： <span class="math display">\[q(\mathbf{z}|\mathbf{x})\sim \mathcal{N}(\mathbf{z};\mathbf{x},\mathbf{v})\tag{1}\]</span> 为了计算网络输出的 Data Uncertainty，通过 Assumed Density Filtering(ADF) 来传递输入数据的噪音。网络的联合概率分布为： <span class="math display">\[p(\mathbf{z}^{(0:l)})=p(\mathbf{z}^{(0)})\prod _ {i=1} ^ l p(\mathbf{z}^{(i)}|\mathbf{z} ^ {(i-1)}) \tag{2}\]</span> 其中： <span class="math display">\[p(\mathbf{z}^{(i)}|\mathbf{z}^{(i-1)})=\sigma[\mathbf{z} ^ {(i)}-\mathbf{f} ^ {(i)}(\mathbf{z}^{(i-1)})]\tag{3}\]</span> ADF 将其近似为： <span class="math display">\[p(\mathbf{z}^{(0:l)})\approx q(\mathbf{z}^{(0:l)})=q(\mathbf{z}^{(0)})\prod _ {i=1} ^ l q(\mathbf{z}^{(i)}) \tag{4}\]</span> 其中 \(q(\mathbf{z})\) 符合独立高斯分布： <span class="math display">\[q(\mathbf{z}^{(i)})\sim \mathcal{N}\left(\mathbf{z}^{(i)};\mathbf{\mu}^{(i)},\mathbf{v}^{(i)}\right)=\prod _ j\left(\mathbf{z} _ j ^ {(i)};\mathbf{\mu} _ j ^ {(i)}, \mathbf{v} _ j ^ {(i)}\right)\tag{5}\]</span> 特征 \(\mathbf{z}^{(i-1)}\) 通过第 \(i\) 层映射方程 \(\mathbf{f} ^{(i)}\)，得到： <span class="math display">\[\hat{p}(\mathbf{z}^{(0:i)})=p(\mathbf{z}^{(i)}|\mathbf{z}^{(i-1)})q(\mathbf{z}^{(0:i-1)}) \tag{6}\]</span> ADF 的目标是找到 \(\hat{p}(\mathbf{z}^{(0:i)})\) 的近似分布 \(q(\mathbf{z}^{(0:i)})\)，比如 KL divergence： <span class="math display">\[q(\mathbf{z}^{(0:i)})=\mathop{\arg\min}\limits _ {\hat{q}(\mathbf{z}^{(0:i)})}\mathbf{KL}\left(\hat{q}(\mathbf{z}^{(0:i)})\;\Vert\;\hat{p}(\mathbf{z}^{(0:i)})\right)\tag{7}\]</span> 基于高斯分布的假设，以上解为： <span class="math display">\[\begin{align}\mathbf{\mu}^{(i)}=\mathbb{E} _ {q(\mathbf{z}^{(i-1)})}[\mathbf{f}^{(i)}(z^{(i-1)})]\\\mathbf{v}^{(i)}=\mathbb{V} _ {q(\mathbf{z}^{(i-1)})}[\mathbf{f}^{(i)}(z^{(i-1)})]\\\end{align}\tag{8}\]</span></p><h2 id="epistemic-uncertaintymodel-uncertainty">2. Epistemic Uncertainty(Model Uncertainty)</h2><p>　　Model Uncertainty 表征的是模型的不确定性，对于训练集 \(\mathrm{D}=\{\mathbf{X},\mathbf{Y}\}\)，模型的不确定性即为权重参数的分布 \(p(\mathbf{\omega} | \mathbf{X},\mathbf{Y})\)。可采用 Monte-Carlo 采样方法来近似估计模型权重分布，具体的采样通过 Dropout 实现： <span class="math display">\[p(\omega|\mathbf{X},\mathbf{Y})\approx q(\mathbf{\omega};\mathbf{\Phi})=Bern(\mathbf{\omega};\mathbf{\Phi}) \tag{9}\]</span> 其中 \(\mathbf{\Phi}\) 是 Bernolli(dropout) rates，由此模型的不确定性即为 T 次采样的方差： <span class="math display">\[\mathbf{Var} _ {p(\mathbf{y}|\mathbf{x})} ^ {model}(\mathbf{y})=\sigma _ {model} = \frac{1}{T}\sum _ {t=1} ^ T(\mathbf{y} _ t-\bar{\mathbf{y}}) ^ 2\tag{10}\]</span> 其中 \(\{\mathbf{y} _ t\} _ {t=1} ^ T\) 是不同权重 \(\omega ^ t\sim q(\omega;\mathbf{\Phi})\) 采样下的输出。<br>　　这种模型不确定性的计算方式，直观的理解为：当模型对某些数据预测比较好，误差比较小的时候，那么模型对这些数据的冗余度肯定是较高的，所以去掉模型的一部分网络，模型对这些数据的预测与原模型应该会有较高的一致性。</p><h2 id="total-uncertainty">3. Total Uncertainty</h2><p><img src="/A-General-Framework-for-Uncertainty-Estimation-in-deep-learning/framework.png" width="95%" height="95%" title="图 1. Framework"> 　　如图 2.2 所示，结合蒙特卡洛采样与 ADF 方法，网络预测的结果与对应的总的 Uncertainty 可计算为： <span class="math display">\[\left\{\begin{array}{l}\mu = \frac{1}{T}\sum _ {t=1} ^ T \mathbf{\mu} _ t ^ {(l)}\\\sigma _ {tot} = \frac{1}{T}\sum _ {t=1} ^ {T} \mathbf{v} _ t ^ {(l)} + \frac{1}{T}\sum _ {t=1} ^ T\left(\mathbf{\mu} _ t ^ {(l)}-\bar{\mathbf{\mu}}\right) ^ 2\end{array}\tag{11}\right.\]</span> 其中 \(\{\mathbf{\mu} _ t ^ {(l)},\mathbf{v} _ t ^ {(l)}\} _ {t=1} ^ T\) 是 ADF 网络 \(T\) 次蒙特卡洛采样结果。<strong>由此可见，不同于以往将 Model Uncertainty 和 Data Uncertainty 完全作独立假设的方式，本文方法是将二者联合来估计的。这也比较好理解，如果数据噪音很大，那么模型的不确定性也会很大，所以二者不可能是完全独立的</strong>。<br>　　该方法可归纳为：</p><ol type="1"><li>将现有的网络转换为 ADF 网络形式；</li><li>手机 \(T\) 次蒙特卡洛采样的网络输出；</li><li>计算网络输出的 Mean 和 Variance；</li></ol><p>其中步骤一不用作任何额外训练的操作，神经网络中的每个操作都有对应的 ADF 操作，详见<a href="#2" id="2ref">[2]</a>，代码可参考<a href="#3" id="3ref">[3]</a>。比如基于 Pytorch的 2D 卷积： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Conv2d(_ConvNd):</span><br><span class="line">    def __init__(self, in_channels, out_channels, kernel_size, stride=1,</span><br><span class="line">        padding=0, dilation=1, groups=1, bias=True,</span><br><span class="line">        keep_variance_fn=None, padding_mode=&apos;zeros&apos;):</span><br><span class="line">        self._keep_variance_fn = keep_variance_fn</span><br><span class="line">        kernel_size = _pair(kernel_size)</span><br><span class="line">        stride = _pair(stride)</span><br><span class="line">        padding = _pair(padding)</span><br><span class="line">        dilation = _pair(dilation)</span><br><span class="line">        super(Conv2d, self).__init__(</span><br><span class="line">            in_channels, out_channels, kernel_size, stride, padding, dilation,</span><br><span class="line">            False, _pair(0), groups, bias, padding_mode)</span><br><span class="line"></span><br><span class="line">        def forward(self, inputs_mean, inputs_variance):</span><br><span class="line">            outputs_mean = F.conv2d(inputs_mean, self.weight, self.bias, self.stride, self.padding, self.dilation, self.groups)</span><br><span class="line">            outputs_variance = F.conv2d(inputs_variance, self.weight ** 2, None, self.stride, self.padding, self.dilation, self.groups)</span><br><span class="line">            if self._keep_variance_fn is not None:</span><br><span class="line">                outputs_variance = self._keep_variance_fn(outputs_variance)</span><br><span class="line">                return outputs_mean, outputs_variance</span><br></pre></td></tr></table></figure></p><p>Softmax: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Softmax(nn.Module):</span><br><span class="line">    def __init__(self, dim=1, keep_variance_fn=None):</span><br><span class="line">        super(Softmax, self).__init__()</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self._keep_variance_fn = keep_variance_fn</span><br><span class="line"></span><br><span class="line">        def forward(self, features_mean, features_variance, eps=1e-5):</span><br><span class="line">            &quot;&quot;&quot;Softmax function applied to a multivariate Gaussian distribution.</span><br><span class="line">            It works under the assumption that features_mean and features_variance </span><br><span class="line">            are the parameters of a the indepent gaussians that contribute to the </span><br><span class="line">            multivariate gaussian. </span><br><span class="line">            Mean and variance of the log-normal distribution are computed following</span><br><span class="line">            https://en.wikipedia.org/wiki/Log-normal_distribution.&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">                    </span><br><span class="line">            log_gaussian_mean = features_mean + 0.5 * features_variance</span><br><span class="line">            log_gaussian_variance = 2 * log_gaussian_mean</span><br><span class="line">                    </span><br><span class="line">            log_gaussian_mean = torch.exp(log_gaussian_mean)</span><br><span class="line">            log_gaussian_variance = torch.exp(log_gaussian_variance)</span><br><span class="line">            log_gaussian_variance = log_gaussian_variance*(torch.exp(features_variance)-1)</span><br><span class="line">                    </span><br><span class="line">            constant = torch.sum(log_gaussian_mean, dim=self.dim) + eps</span><br><span class="line">            constant = constant.unsqueeze(self.dim)</span><br><span class="line">            outputs_mean = log_gaussian_mean/constant</span><br><span class="line">            outputs_variance = log_gaussian_variance/(constant**2)</span><br><span class="line">                    </span><br><span class="line">            if self._keep_variance_fn is not None:</span><br><span class="line">                outputs_variance = self._keep_variance_fn(outputs_variance)</span><br><span class="line">                return outputs_mean, outputs_variance</span><br></pre></td></tr></table></figure></p><h2 id="experiments">4. Experiments</h2><p>　　本文在 Steering Angle Prediction，Object Future Motion Prediction，Object Recognition，Closed-Loop Control of a Quadrotor 等任务上作了 Uncertainty 的估计，用 KL，NLL 来评估预测好坏。KL 本质上用于描述两个分布的距离。NLL(Negative Log-likelihood) 数学形式为 \(\frac{1}{2}\mathrm{log}(\sigma _ {tot})+\frac{1}{2\sigma _ {tot}}(y _ {gt}-y _ {pred}) ^ 2\)，即为 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中预测 Uncertainty 方法中的 Loss 项。</p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> Loquercio, Antonio , Segù, Mattia, and D. Scaramuzza . &quot;A General Framework for Uncertainty Estimation in Deep Learning.&quot; (2019).<br><a id="2" href="#2ref">[2]</a> Gast, Jochen , and S. Roth . &quot;Lightweight Probabilistic Deep Networks.&quot; (2018).<br><a id="3" href="#3ref">[3]</a> https://github.com/mattiasegu/uncertainty_estimation_deep_learning/blob/master/contrib/adf.py</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Uncertainty 估计在深度学习网络预测中同样非常重要，因为我们不仅需要知道预测结果，还想知道该结果的不确定性。Uncertainty 可分为偶然不确定性(Aleatoric Uncertainty，详见 &lt;a href=&quot;/Heteroscedastic-Ale
      
    
    </summary>
    
      <category term="Uncertainty" scheme="https://leijiezhang001.github.io/categories/Uncertainty/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Uncertainty" scheme="https://leijiezhang001.github.io/tags/Uncertainty/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;AFDet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-AFDet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-AFDet/</id>
    <published>2020-08-28T01:45:09.000Z</published>
    <updated>2020-09-02T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　点云目标检测方法已趋于完善，为了能在嵌入式系统上高效运行点云目标检测算法，地平线提出了 AFDet <a href="#1" id="1ref"><sup>[1]</sup></a>，该文章发表在 CVPR2020 Workshop 上，算是很工程化的一个工作了，对工程产品落地有很好的参考价值。AFDet 应用了很多 Anchor-Free 2D 目标检测思想，可参考 <a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a>。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-AFDet/framework.png" width="90%" height="90%" title="图 1. Framework"> 　　AFDet 是一种 Anchor-Free，NMS-Free 的检测方法，所以后处理非常简单，高效。如图 1. 所示，AFDet 采用了传统的 Birdview 下的 Point Cloud Encoder，Backbone &amp; Necks，Anchor-Free Detector 三种网络结构。Point Cloud Encoder 可采用 <a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a> 结构，Backbone &amp; Necks 这里也不作展开。这里最重要的设计是 Anchor-Free 的检测头，由 Keypoint Heatmap，Local Offset Head，z-axis Location Head，3D Object Size Head，Orientation Head 等五个分支构成。</p><h3 id="keypoint-heatmap-local-offset-head">1.1. Keypoint Heatmap &amp; Local Offset Head</h3><p>　　BEV 下目标定位由 Heatmap \(M\in\mathbb{R} ^ {W\times H\times C}\) 和 Offset Regression Map \(O\in\mathbb{R} ^ {W\times H\times 2}\) 组成，其中 \(C\) 为 Keypoint 类型。Offset Head 是为了消除 Voxel 后的量化误差以预测更准确的目标位置。<br>　　对于第 \(k\) 个类别为 \(c _ k\) 的目标，其 3D 属性为：\((x ^ {(k)},y ^ {(k)},z ^ {(k)},w ^ {(k)},l ^ {(k)},h ^ {(k)},\theta ^ {(k)})\)。设 Pillar 边长为 \(b\)，那么在 BEV 栅格图上，目标中心点作为关键点的坐标为 \(\bar{p}=\left(\left\lfloor\frac{x ^ {(k)}-back}{b}\right\rfloor,\left\lfloor\frac{y ^ {(k)}-left}{b}\right\rfloor\right)\in\mathbb{R} ^ 2\)，其中 \([(back,front),(left,right)]\) 为 \(x-y\) 平面检测范围。由此，目标在 BEV 下的 2D 属性框表示为 \(\left(\left\lfloor\frac{x ^ {(k)}-back}{b}\right\rfloor,\left\lfloor\frac{y ^ {(k)}-left}{b}\right\rfloor,\left\lfloor\frac{w ^ {(k)}}{b}\right\rfloor,\left\lfloor\frac{l ^ {(k)}}{b}\right\rfloor,\theta ^ {(k)}\right)\)。<br>　　对于 BEV Heatmap 分支的真值，需要根据目标框真值来生成。对于 Heatmap 中的像素点 \((x,y)\)，设计其值为： <span class="math display">\[M _ {x,y,z} =\left\{\begin{array}{l}1, &amp;\mathrm{if}\;d=0\\0.8, &amp;\mathrm{if}\; d=1\\\frac{1}{d}, &amp;\mathrm{else}\end{array}\tag{1}\right.\]</span> 其中 \(d\) 表示目标框中心点与对应像素点的距离，Heatmap 中预测量 \(\hat{M} _ {x,y,c}=1\) 表示其为目标框中心点，\(\hat{M} _ {x,y,c}=0\) 则表示是背景。Heatmap 中 \(\bar{p}\) 位置定义为正样本点，其余 Pillars 为负样本点，使用 Focal Loss： <span class="math display">\[\mathcal{L} _ {heat} = -\frac{1}{N}\sum _ {x,y,c}\left\{\begin{array}{l}\left(1-\hat{M} _ {x,y,c}\right) ^ {\alpha}\;\mathrm{log}\left(\hat{M} _ {x,y,c}\right), \;\mathrm{if}\; M _ {x,y,c} = 1 \\\left(1-\hat{M} _ {x,y,c}\right) ^ {\beta}\; \left(\hat{M} _ {x,y,c}\right) ^ {\alpha}\mathrm{log}\left(1-\hat{M} _ {x,y,c}\right), \;\mathrm{else} \\\end{array}\tag{2}\right.\]</span> 　　另一方面，Offset Regression 分支可以解决量化误差，以及当 Heatmap 中心点分类错误的时候，补救预测准确的中心点位置。选择中心点周围半径 \(r\) 区域作 Offset 预测： <span class="math display">\[\mathcal{L} _ {off} = \frac{1}{N}\sum _ p\sum ^ r _ {\sigma =-r}\sum ^ r _ {\epsilon = -r}\left\vert\hat{O} _ {\bar{p}}-b(p-\bar{p}+(\sigma,\epsilon))\right\vert\tag{3}\]</span> 只对 \(2r+1\) 的矩形区域作 Offset 预测。</p><h3 id="z-axis-location-head">1.2. z-axis Location Head</h3><p>　　高度预测值 \(\hat{Z}\in\mathbb{R} ^ {W\times H\times 1}\)，其 Loss 为： <span class="math display">\[\mathcal{L _ z} = \frac{1}{N}\sum _ {k=1} ^ N\left\vert\hat{Z} _ {p ^ {(k)}}-z ^ {(k)}\right\vert\tag{4}\]</span></p><h3 id="d-object-size-head">1.3. 3D Object Size Head</h3><p>　　尺寸预测值 \(\hat{S}\in\mathbb{R} ^ {W\times H\times 3}\)，其 Loss 为： <span class="math display">\[\mathcal{L} _ {size} = \frac{1}{N}\sum _ {k=1} ^ N\left\vert\hat{S} _ {p ^ {(k)}}-s ^ {(k)}\right\vert\tag{5}\]</span> 其中 \(s ^ {(k)} = (w ^ {(k)},l ^ {(k)}, h ^ {(k)})\)。</p><h3 id="orientation-head">1.4. Orientation Head</h3><p>　　与传统的一样，将角度预测分解为 bin 分类＋ offset 回归两个任务。具体的，分成两个 bin：\(\Psi _ 1 =[-\frac{7\pi}{6}, \frac{\pi}{6}]\)；\(\Psi _ 2 =[-\frac{\pi}{6}, \frac{7\pi}{6}]\)。对于每个 bin，softmax 分类 \(\hat{\mu} _ i ^ {(k)}\in\mathbb{R} ^ 2\)，与 bin 中心夹角 \(\gamma _ i\) 的 sin/cos 值 \(\hat{v} _ i ^ {(k)}\)。Loss 为： <span class="math display">\[\mathcal{L} _ {ori} = \frac{1}{N}\sum _ {k=1}^N\sum _ {i=1}^2\left(\mathrm{softmax}\left(\hat{\mu} _ i ^ {(k)},\eta _ i ^ {(k)}\right)+\eta _ i ^ {(k)}\left\vert\hat{v} _ i ^ {(k)}-v _ i ^ {(k)}\right\vert\right)\tag{6}\]</span> 其中当 \(\theta ^ {(k)}\in\Psi _ i\) 时，\(\eta _ i ^ {(k)} = \mathbb{1}\)，\(v _ i^ {(k)}=\left(\mathrm{sin}(\theta ^ {(k)}-\gamma _ i), \mathrm{cos}(\theta ^ {(k)}-\gamma _ i)\right)\)。由此，预测的角度可通过如下方式解码： <span class="math display">\[\hat{\theta} ^ {(k)}=\mathrm{arctan2}\left(\hat{v} _ {j,1} ^ {(k)},\hat{v} _ {j,2} ^ {(k)}\right)+\gamma _ j\tag{7}\]</span> 　　<strong>因为是 Anchor Free 的方式，所以如果按照传统的方式， bin 数量较大，那么最后输出的 map 所占的内存也会相当大，所以这里只采用了两个 bin</strong>。这么做有很大好处，比如量化时数值的稳定性，所以在工程应用中非常值得借鉴思考。</p><h2 id="experiments">2. Experiments</h2><p><img src="/paper-reading-AFDet/res1.png" width="70%" height="70%" title="图 2. res1"> <img src="/paper-reading-AFDet/res2.png" width="70%" height="70%" title="图 3. res2"> 　　如图 2. 所示，AFDet 在同等计算量下，基本能达到 <a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a> 水平。图 3. 则对比了几种 Anchor-Based 方法，效果也较好。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Ge, Runzhou, et al. &quot;Afdet: Anchor free one stage 3d object detection.&quot; arXiv preprint arXiv:2006.12671 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　点云目标检测方法已趋于完善，为了能在嵌入式系统上高效运行点云目标检测算法，地平线提出了 AFDet &lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;，该文章发表在 CVPR2020 Workshop 上，算是很工程化的一个工作了，对工程
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;EPNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-EPNet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-EPNet/</id>
    <published>2020-08-24T01:38:40.000Z</published>
    <updated>2020-08-28T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　在大多数场景下，融合激光雷达与图像数据能有效提升各种深度学习任务性能。本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种图像数据与激光雷达的前融合框架，并且考虑到分类分数与定位置信度的不一致性，提出了一种约束两者一致性的 Loss。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-EPNet/framework.png" width="90%" height="90%" title="图 1. Framework"> 　　如图 1. 所示，EPNet 主要由 Image Stream，Geometric Stream，LI-Fusion Module，及 Detect Head 组成。<br>　　Image Stream 中，提取不同尺度的图像特征 \(F _ i(i = 1,2,3,4)\)，然后经过 2D Transposed Convolution 将不同尺度的特征变换到图像分辨率，得到特征 \(F _ U\)。<br>　　Geometric Stream 用 PointNet++(<a href="/PointNet-系列论文详读/" title="PointNet-系列论文详读">PointNet-系列论文详读</a>) 作特征提取，对应的 SA，FP 特征为 \(S _ i,P _ i(i =1,2,3,4)\)。\(S _ i,F _ i\) 通过 LI-Fusion 模块进行深度融合，此外 \(F _ U\) 与 \( P _ 4\) 也通过 LI-Fusion 进行融合。</p><h2 id="li-fusion-module">2. LI-Fusion Module</h2><p><img src="/paper-reading-EPNet/LI.png" width="70%" height="70%" title="图 2. LI-Fusion"> 　　LiDAR-guided Image Fusion Module 是图像点云两个数据流融合的核心模块。如图 2. 所示，LI-Fusion 由 Point-wise Correspondence Generation 和 LiDAR-guided fusion 两部分组成。Point-wise Correspondence Generation 又由 Grid Generator 和 Image Sampler 实现，对于点云中的点 \(p(x,y,z)\)，可得到不同尺度图像上的像素点 \(p'(x',y')\)： <span class="math display">\[p&#39;=M\times p\tag{1}\]</span> 其中 \(M\in\mathbb{R}^ {3\times 4}\)。\(p'\) 可能不是正好位于图像坐标像素点上，所以用双线性插值的方法取邻近像素点的特征值： <span class="math display">\[V^{(p)}=\mathcal{K}\left(F^{\mathcal{N}(p&#39;)}\right)\tag{2}\]</span> 其中 \(V^{(p)}\) 表示点 \(p\) 对应的图像点特征，\(\mathcal{K}\) 表示双线性插值，\(\left(F^{\mathcal{N}(p')}\right)\) 表示图像 \(p'\) 邻近点的特征。<br>　　LiDAR-guided Fusion 考虑到不能直接将点的图像特征与点特征进行串联融合，因为图像特征容易受光照，遮挡等因素影响，所以通过点云对图像点特征进行重要性权重融合。如图 2. 所示，重要性权重设计为： <span class="math display">\[\mathbf{w}=\sigma\left(\mathcal{W}\;\mathrm{tanh}(\mathcal{U} F _ P+\mathcal{V}F _ I)\right)\tag{3}\]</span> 其中 \(\mathcal{W,U,V}\) 为 MLP 网络，\(\sigma\) 为 sigmoid 归一化函数。<br>　　最终的融合特征为： <span class="math display">\[F _ {LI}=\mathrm{Concate}(F _ P,\mathbf{w}F _ I)\tag{4}\]</span></p><h2 id="consistency-enforcing-loss">2. Consistency Enforcing Loss</h2><p>　　NMS 操作时，一般用分类的分数，但是分类分数与定位置信度是不一致的。本文提出 Consistency Enforcing Loss，将定位与分类的分数监督成一致： <span class="math display">\[L _ {ce}=-log\left(c\times\frac{Area(D\cap G)}{Area(D\cup G)}\right)\tag{5}\]</span> 其中 \(D,G\) 分别为预测框与真值框，\(c\) 为分类分数，该 Loss 鼓励定位准的框分类分数越高。<br>　　这与 IoU Loss 作用相似！</p><h2 id="ablation-study">3. Ablation Study</h2><p><img src="/paper-reading-EPNet/ablation.png" width="90%" height="90%" title="图 3. Ablation Study"> 　　如图 3. 所示，LI-Fusion 和 CE Loss 对检测性能提升还是比较明显的。此外，本文还对比了三种 Fusion 方式，另外两种为：SC(simple concatenation)，将原始图像像素值串联到对应的点云原始数据中，没有 Image Stream；SS(single scale)，只用最后一层的图像点云特征作融合。<br>　　实验表明，SC 性能反而下降，SS 有所提升，但是 Multi-scale 的性能最好。结论就是，在一个尺度下，相对靠后的前融合可能比相对靠前的前融合效果更好(类比 <a href="/PointPainting/" title="PointPainting">PointPainting</a>，其虽然是前融合，但是直接提取的是图像的语义分割结果，所以相对靠后，效果也好)，当然多尺度的效果会是最好的。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Huang, Tengteng, et al. &quot;EPNet: Enhancing Point Features with Image Semantics for 3D Object Detection.&quot; arXiv preprint arXiv:2007.08856 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　在大多数场景下，融合激光雷达与图像数据能有效提升各种深度学习任务性能。本文&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;提出了一种图像数据与激光雷达的前融合框架，并且考虑到分类分数与定位置信度的不一致性，提出了一种约束两者一致性的 L
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;PV-RCNN&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-PV-RCNN/"/>
    <id>https://leijiezhang001.github.io/paper-reading-PV-RCNN/</id>
    <published>2020-08-19T01:24:10.000Z</published>
    <updated>2020-08-20T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　PV-RCNN<a href="#1" id="1ref"><sup>[1]</sup></a> 目前在 Waymo 数据集上排名第二，性能还是比较强悍的，顺便也看了下港中文多媒体实验室开源的 OpenPCDet<a href="#2" id="2ref"><sup>[2]</sup></a> 代码，收获还是蛮多，与图像点云通用的 mmdetection3d<a href="#3" id="3ref"><sup>[3]</sup></a> 各有优劣吧。虽然 PV-RCNN 对于实际应用还是略显复杂，以及超参数较麻烦，但是其相关思想还是非常值得借鉴。本文主要关注其 Point + Vexol 特征提取并融合的方式。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-PV-RCNN/framework.png" width="90%" height="90%" title="图 1. Framework"> 　　如图 1. 所示，PV-RCNN 首先将原始点云体素化，然后用 3D Sparse Convolution(<a href="/Rethinking-of-Sparse-3D-Convolution/" title="Rethinking of Sparse 3D Convolution">Rethinking of Sparse 3D Convolution</a>) 作 Voxel-level 的特征提取，并预测俯视图下的目标 ROI Proposal；另一方面，在原始点云中用 FPS 采样出特定数量的 key-point，然后通过 Voxel Set Abstraction 模块，将提取到的多尺度的 Voxel-level 特征融合到 key-point 特征；最后用 ROI-Grid 模块将 key-point 特征融合到 ROI Grid-Point 中，作进一步的 3D 目标框属性精细化预测。<br>　　由此不仅利用了 Voxel-level 3D Sparse Convolution 的高效性，还利用了 Point-based 模型对局部信息提取更加精细有效的特性。总体上，PV-RCNN 框架中特征提取操作由两大块组成：1. Voxel-to-Keypoint Scene Encoding；2. Point-to-Grid RoI Feature Abstraction。</p><h2 id="voxel-to-keypoint-scene-encoding">2. Voxel-to-Keypoint Scene Encoding</h2><p>　　该模块的作用是将提取的特征用特定数量的 Keypoint 来表示。所以有 Keypoints Sampling，Voxel Set Abstraction Module，Extended VSA Module，Predicted Keypoint Weighting 等组成。</p><h3 id="keypoints-sampling">2.1. Keypoints Sampling</h3><p>　　因为期望采样的 Keypoints 能完全覆盖整个场景，所以采用 Furthest-Point-Sampling(FPS) 来采样 \(n\) 个点 \(\mathcal{K}=\{p _ 1,...,p _ n\}\)。对于 KITTI 数据集，取 \(n=2048\)，对于 Waymo 数据集，取 \(n=4096\)。</p><h3 id="voxel-set-abstraction-module">2.2. Voxel Set Abstraction Module</h3><p>　　VSA 模块将经过 3D Sparse Convolution 得到的多尺度的 Voxel 特征编码为 Keypoints 表达形式，与 <a href="/PointNet-系列论文详读/" title="PointNet-系列论文详读">PointNet-系列论文详读</a> 类似，只不过这里点周围不是点，而是 Voxel。<br>　　具体的，设尺度 \(k\) 的 3D voxel 特征集合为 \(\mathcal{F}^ {(l _ k)}=\{f _ 1 ^ {(l _ k)},...,f _ {N _ k}^{(l _ k)}\}\)，对应的 Voxel 3D 坐标为 \(\mathcal{V}^ {(l _ k)}=\{v _ 1 ^ {(l _ k)},...,v _ {N _ k}^{(l _ k)}\}\)，其中 \(N _ k\) 为非零 Voxel 数量。对于 keypoint \(p _ i\)，在半径 \(r _ k\) 内找到所有 voxel 的特征向量： <span class="math display">\[S _ i ^ {(l _ k)} = \left\{\left[f _ j^{(l _ k)};v _ j^{(l _ k)}-p _ i\right] ^ T \left\vert\begin{array}{l}\Vert v _ j^{(l _ k)}-p _ i\Vert ^ 2 &lt; r _ k,\\\forall v _ j^{(l _ k)} \in \mathcal{V} ^ {(l _ k)},\\\forall f _ j ^ {(l _ k)} \in \mathcal{F} ^ {(l _ k)}\end{array}\right.\right\}\tag{1}\]</span> 其中 \(v _ j^{(l _ k)}-p _ i\) 为对应的 Voxel 与该点 \(p _ i\) 的相对位置，与特征向量串联得到该 Voxel 在该点的投影特征。由此用 PointNet 方式可得到该 Keypoint 融合领域内 Voxel 特征集 \(S _ i ^ {(l _ k)}\) 后的特征： <span class="math display">\[f _ i ^ {(pv _ k)}=\mathrm{max}\left\{G\left(\mathcal{M}(S _ i^{(l _ k)})\right)\right\}\tag{2}\]</span> 其中 \(\mathcal{M}\) 为随机采样 Voxel 的操作，目的是为了减少计算量；\(G\) 为 MLP 网络。<br>　　本文采用了 4 个尺度的 Voxel 特征，每个尺度的领域半径 \(r _ k\) 根据感受野而变化。最终得到的多尺度的语义的 Keypoint 特征为： <span class="math display">\[f _ i^{(pv)} = \left[f _ i^{(pv _ 1)},f _ i^{(pv _ 2)},f _ i^{(pv _ 3)},f _ i^{(pv _ 4)}\right],\;\mathrm{for}\; i = 1,...,n\tag{3}\]</span></p><h3 id="extended-vsa-module">2.3. Extended VSA Module</h3><p>　　此外，Keypoint 还利用了原始点云的特征以及经过 3D Sparse Convolution 和 ToBEV 后的 2D BEV 特征。Keypoint 通过双线性插值的方式从 BEV 特征层中计算对应空间位置的特征。综上，Keypoint 特征为： <span class="math display">\[f _ i^{(p)} = \left[f _ i^{(pv)},f _ i^{(raw)},f _ i^{(bev)}\right],\;\mathrm{for}\; i = 1,...,n\tag{4}\]</span></p><h3 id="predicted-keypoint-weighting">2.4. Predicted Keypoint Weighting</h3><p><img src="/paper-reading-PV-RCNN/weight.png" width="50%" height="50%" title="图 2. PKW"> 　　通过 FPS 采样得到的 Keypoint 也包含了大量的背景点，所以需要弱化背景点的特征，强化前景点特征，以便之后前景目标框属性的精细化估计。如图 2. 所示，训练阶段，对 Keypoint 进行点级别前景背景分类，标签可由目标框内点自动生成；测试阶段，直接预测点的类别，然后作点特征的权重化整合： <span class="math display">\[\tilde{f _ i} ^ {(p)} = \mathcal{A}(f _ i^{(p)})\cdot f _ i^{(p)}\tag{5}\]</span> 其中 \(\mathcal{A}(\cdot)\) 为 MLP 网络。</p><h2 id="point-to-grid-roi-feature-abstraction">3. Point-to-Grid RoI Feature Abstraction</h2><p><img src="/paper-reading-PV-RCNN/roi.png" width="50%" height="50%" title="图 3. RoI-grid Pooling"> 　　得到了 Keypoint 特征 \(\mathcal{\tilde{F}}=\{\tilde{f} _ 1^{(p)},...,\tilde{f} _ n^{(p)}\}\) 以及俯视图下的 3D proposal ROI 后，可进一步提取 ROI 特征，以作 3D 目标框属性的精细化估计。如图 3. 所示，类似 Voxel-to-Point 的 Voxel Set Abstraction 模块，本文提出了 Point-to-Grid 的 Set Abstraction，称之为 ROI-Grid Pooling。具体的，对每个 ROI Proposal，采样 \(6\times 6\times 6\) 个栅格点：\(\mathcal{G}=\{g _ 1,...,g _ {216}\}\)。Set Abstraction 操作将 Keypoint 的特征映射到栅格点处。类似 VSA，首先在 \(\tilde{r}\) 半径内查找栅格点的周围 Keypoint： <span class="math display">\[\tilde{\psi} = \left\{\left[\tilde{f} _ j^{(p)};p _ j-g _ i\right] ^ T \left\vert\begin{array}{l}\Vert p _ j-g _ i\Vert ^ 2 &lt; \tilde{r},\\\forall p _ j\in \mathcal{K},\\\forall \tilde{f} _ j ^ {(p)} \in \mathcal{\tilde{F}}\end{array}\right.\right\}\tag{6}\]</span> 类似的，再通过 PointNet 得到栅格点 \(g _ i\) 的特征： <span class="math display">\[\tilde{f} _ i ^ {(g)}=\mathrm{max}\left\{G\left(\mathcal{M}(\tilde{\psi})\right)\right\}\tag{7}\]</span> 　　由此得到所有 ROI 固定长度的特征向量，进而可在 ROI Proposal 的基础上，作最后的尺寸，角度，位置等属性的精细化估计，这里不做展开。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Shi, Shaoshuai, et al. &quot;Pv-rcnn: Point-voxel feature set abstraction for 3d object detection.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.<br><a id="2" href="#2ref">[2]</a> https://github.com/open-mmlab/OpenPCDet<br><a id="3" href="#3ref">[3]</a> https://github.com/open-mmlab/mmdetection3d</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　PV-RCNN&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt; 目前在 Waymo 数据集上排名第二，性能还是比较强悍的，顺便也看了下港中文多媒体实验室开源的 OpenPCDet&lt;a href=&quot;#2&quot; id=&quot;2ref&quot;&gt;&lt;sup&gt;[
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;MotionNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-MotionNet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-MotionNet/</id>
    <published>2020-08-17T01:23:18.000Z</published>
    <updated>2020-08-18T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　基于点云的 3D 感知一般通过 3D 目标框实现，但是如果直接网络出 3D 目标框属性，那么召回率很难达到非常高的水平(所以之前提到检测的任务可以分解为分割+后处理聚类来作，这样召回率会比较高)。本文提出的 MotionNet<a href="#1" id="1ref"><sup>[1]</sup></a> 用于检测俯视图下每个栅格的类别及轨迹，可作为检测的辅助，能召回更小的目标，以及没有标注的动态障碍物目标。这种栅格级别或点级别的目标探测能力相比直接出目标框的优势有：</p><ol type="1"><li>目标框形式一般依赖于目标框区域的特征，不同目标类别之间的特征很难泛化，所以无法检测未见过的类别；</li><li>目标框形式一般会作 NMS 等处理去掉不确定性较大的框，而栅格级别的会保留；</li></ol><p><img src="/paper-reading-MotionNet/compare.png" width="40%" height="40%" title="图 1. Detection VS. Motion Prediction"> 　　如图 1. 所示，对于轮椅这种非正常类别(或预定义类别)的目标，检测任务可能会失效，此时 MotionNet 则会根据时序信息输出该区域的目标速度(未来运动轨迹)，这可作为 Motion Planning 阶段的另一重要线索。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-MotionNet/framework.png" width="80%" height="80%" title="图 2. Framework"> 　　如图 2. 所示，MotionNet 输入为连续帧点云在当前坐标系下的俯视图表示，然后经过 Spatio-temporal Pyramid 网络作特征提取，最后三个分支网络输出三个信息：</p><ul><li>Cell Classification，每个 cell 的类别；</li><li>Motion Prediction，每个 cell 的未来轨迹；</li><li>State Estimation，每个 cell 是否静止的判断；</li></ul><h2 id="spatio-temporal-pyramid-network">2. Spatio-temporal Pyramid Network</h2><p><img src="/paper-reading-MotionNet/stpn.png" width="50%" height="50%" title="图 3. STPN"> 　　 将时序点云组织成多层的俯视图表达后，面临两个问题：1. 如何整合时序信息；2. 如何提取多尺度的空间及时序特征。本文设计了 STPN 网络，如图 3. 所示，STC 模块由 2D Convolution 以及 \(k\times 1\times 1\) 的 3D Convolution (本质上退化成 1D Convolution)组成；此外设计了金字塔式的特征提取结构，最终输出 \(1\times C\times H\times W\) 大小的特征图。相比于直接 3D 卷积形式，这种方式 2D + 1D 卷积方式极大提高了网络计算效率(很多地方用到这种方式，如 <a href="/paperreading-Fast-and-Furious/" title="FaF">FaF</a>)。</p><h2 id="output-heads">3. Output Heads</h2><p>　　三个分支输出的细节为：</p><ol type="1"><li>Cell Classification，输出尺寸为 \(H\times W\times C\)，其中 \(C\) 为类别；</li><li>Motion Prediction，输出尺寸为 \(N\times H\times W\times 2\)，表示时间 \(\tau\in (t,t+N)\) 内 cell 的位置 \(\{X ^ {(\tau)}\} _ {\tau =t} ^ {t + N}\)，其中 \(X ^ {(\tau)}\in\mathbb{R} ^ {H\times W\times 2}\) 只估计平面 2D 的位置。</li><li>State Estimation，输出尺寸为 \(H\times W\)，表示 cell 静止的概率。</li></ol><p>　　直接对静止 Cell 的 Motion Prediction 回归，会引入运动的微小跳变。这里采用两种策略来抑制这种跳变：1. 根据类别分支，如果是背景的类别，则将其 Motion 置 0；2. 根据静止判断分支，如果是静止的，则将其 Motion 也置为 0。这样就能较好的解决静态 cell 出速度轨迹的情况。</p><h2 id="loss-function">4. Loss Function</h2><p>　　Classification 和 State Estimation 用 Cross-Entropy Loss，Motion Prediction 用 Smooth L1 Loss。此外为了保证空域与时域的一致性，引入另外三种 Loss：</p><ul><li><strong>Spatial Consistency Loss</strong><br>属于同一物体的 Cell 的 Motion 应该是一致的(这里其实不太准确，考虑到转向情况，目标区域内 Cell 轨迹其实是不一样的，所以一般有两种思路，一种认为都一样，即每个 Cell 都建模成目标的运动；另一种则基于刚体假设，作类似 Flow 的建模，稍复杂些)。由此设计空间一致性损失函数： <span class="math display">\[L _ s = \sum _ {k}\sum _ {(i,j),(i&#39;,j&#39;)\in o _ k}\left\Vert X _ {i,j}^{(\tau)}-X _ {i&#39;,j&#39;} ^ {(\tau)}\right\Vert \tag{1}\]</span> 其中 \(||\cdot||\) 为 Smooth L1 Loss，\(o _ k\) 为第 \(k\) 个目标，\(X _ {i,j} ^ {(\tau)}\in\mathbb{R} ^ 2\) 为时间 \(\tau\) 时 Cell \((i,j)\) 的 motion。为了减少计算量，这里只是采样一些相邻的 \(X _ {i,j} ^ {(\tau)},X _ {i',j'} ^ {(\tau)}\) 匹配对。</li><li><strong>Foreground Temporal Consistency Loss</strong><br>类似的，属于同一物体的 Motion 在时域上也应该是一致的，所以设计损失函数： <span class="math display">\[L _ {ft} = \sum _ k\left\Vert X _ {o _ k} ^ {(\tau)} - X _ {o _ k} ^ {(\tau+\Delta t)}\right\Vert\tag{2}\]</span> 其中 \(X _ {o _ k} ^ {(\tau)}\in\mathbb{R} ^ 2\) 为第 \(k\) 个目标的 Motion，计算方式为 \(X _ {o _ k} ^ {(\tau)}=\sum _ {(i,j)\in o _ k}X _ {i,j} ^ {(\tau)}/M\)，其中 \(M\) 为目标中 Cell 的个数。</li><li><strong>Background Temporal Consistency Loss</strong><br>对静止的背景区域，其时域上 Motion 应该也是一致的(均为 0)。设计损失函数： <span class="math display">\[L _ {bt} = \sum _ {(i,j)\;\in\; X ^ {(\tau)}\;\cap\; T\left(\tilde{X} ^ {(\tau-\Delta t)}\right)}\left\Vert X _ {i,j} ^ {(\tau)}-T _ {i,j}\left(\tilde{X} ^ {(\tau-\Delta t)}\right)\right\Vert\tag{3}\]</span> 其中 \(T\in SE(3)\) 是 \(\tau-\Delta t\) 到 \(\tau\) 的位姿变换。将 \(\tilde{X} ^ {\tau-\Delta t}\) 变换到当前时刻后，与 \(X ^ {(\tau)}\) 会有一定的重合，将重合部分的背景区域的 Motion 约束为一致。有点 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 的味道。</li></ul><p>综上，所有的 Loss 为： <span class="math display">\[ L = L _ {cls} + L _ {motion} + L _ {state} + \alpha L _ s+ \beta L _ {ft} + \gamma L _ {bt} \tag{4}\]</span></p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> Wu, Pengxiang, Siheng Chen, and Dimitris N. Metaxas. &quot;MotionNet: Joint Perception and Motion Prediction for Autonomous Driving Based on Bird's Eye View Maps.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　基于点云的 3D 感知一般通过 3D 目标框实现，但是如果直接网络出 3D 目标框属性，那么召回率很难达到非常高的水平(所以之前提到检测的任务可以分解为分割+后处理聚类来作，这样召回率会比较高)。本文提出的 MotionNet&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Deep Learning&quot;" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Cylinder3D&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Cylinder3D/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Cylinder3D/</id>
    <published>2020-08-12T03:43:33.000Z</published>
    <updated>2020-08-17T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Voxel-based 点云分割/检测等任务中，点云的投影表示方法有三种：</p><ul><li>Spherical</li><li>Bird-eye View</li><li>Cylinder</li></ul><p>其中 Spherical 球坐标投影代表为 <a href="/paper-reading-RandLA-Net/" title="RandLA-Net">RandLA-Net</a>；Bird-eye View 则是目前主流的方法。有关 Bird-eye View 点云处理的优劣已经说了很多了，这里不再赘述。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 介绍一种 Cylinder 柱状投影的点云处理方式，类似 <a href="/paper-reading-Pillar-based-Object-Detection/" title="Pillar-based Object Detection">Pillar-based Object Detection</a>，也可以认为是 <a href="/paper-reading-PolarNet/" title="PolarNet">PolarNet</a> 的 3D 版本。 <img src="/paper-reading-Cylinder3D/vs.png" width="70%" height="70%" title="图 1. Comparison"> 　　<a href="/paper-reading-Pillar-based-Object-Detection/" title="Pillar-based Object Detection">Pillar-based Object Detection</a> 中详细说明了 Cylinder 投影比 Spherical 投影的优势，这里不做赘述，如图 1. 所示，相比 Spherical 投影，Cylinder 投影效果提升很明显。</p><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-Cylinder3D/framework.png" width="80%" height="80%" title="图 2. Framework"> 　　如图 2. Cylinder3D 由 3D 柱坐标投影和 3D U-Net 特征提取两部分组成。框架比较简单，网络结构主要由 DownSample，UpSample，Asymmetry Residual Block，Dimension-Decomposition based Context Modeling 四种组件构成。</p><h2 id="cylinder-partition">2. Cylinder Partition</h2><p><img src="/paper-reading-Cylinder3D/coord.png" width="80%" height="80%" title="图 3. Cylinder Partition"> 　　如图 3. 所示，将笛卡尔坐标系下的点云 \((x,y,z)\) 转换到柱坐标系下 \((\rho,\theta,z)\)。对于每个扇形 Voxel，作 PointNet 特征提取，最终得到 3D Cylinder 点云特征表示 \(\mathbb{R}\in C\times H\times W\times L\)。</p><h2 id="network">3. Network</h2><p><img src="/paper-reading-Cylinder3D/block.png" width="70%" height="70%" title="图 4. A & DDCM"></p><h3 id="asymmetry-residual-block">3.1. Asymmetry Residual Block</h3><p>　　如图 4. 所示，Asymmetry Residual Block 将 \(3\times 3\times 3\) 卷积拆分成 \(1\times 3\times 3\) 和 \(3\times 1\times 3\) 两种，这样作有两个好处：</p><ul><li>由于待检测的目标都接近于长方体，这种卷积形式更有利于提取长方体样式的特征；</li><li>减少 33% 的计算量，类似 Depth-wise Convolution；</li></ul><p>该模块作为 3D 卷积的基本模块，嵌入在下采样前，以及上采样后。</p><h3 id="dimension-decomposition-based-context-modeling">3.2. Dimension-Decomposition based Context Modeling</h3><p>　　由于 3D 空间的特征表达是 high-rank 的，所以利用矩阵分解的思想，将其用 height，width，depth 三维的 low-rank 向量来权重化表达，由此设计如图 4. 中的 DDCM 模块。该模块将三个方向的特征计算各自的权重，然后与原始特征作权重化整合。输出的特征用于最终的预测，预测输出是 Voxel-based，维度为 \(Class\times H\times W\times L\)。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Zhou, Hui, et al. &quot;Cylinder3D: An Effective 3D Framework for Driving-scene LiDAR Semantic Segmentation.&quot; arXiv preprint arXiv:2008.01550 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Voxel-based 点云分割/检测等任务中，点云的投影表示方法有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spherical&lt;/li&gt;
&lt;li&gt;Bird-eye View&lt;/li&gt;
&lt;li&gt;Cylinder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 Spherical 球坐标投影代
      
    
    </summary>
    
      <category term="Semantic Segmentation" scheme="https://leijiezhang001.github.io/categories/Semantic-Segmentation/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Segmentation" scheme="https://leijiezhang001.github.io/tags/Segmentation/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;RadarNet&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-RadarNet/"/>
    <id>https://leijiezhang001.github.io/paper-reading-RadarNet/</id>
    <published>2020-08-07T01:25:41.000Z</published>
    <updated>2020-08-12T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Radar 相比 LiDAR/Camera，对天气影响鲁棒性较强，而且能直接测量目标速度，所以是多传感器融合感知里比较重要的一个输入。其在 ADAS 领域应用已经较为广泛。但是 Radar 的测量噪声较大，这给有效的多传感器融合带来了难度。本文提出了 RadarNet<a href="#1" id="1ref"><sup>[1]</sup></a>，利用 Radar 的几何数据以及动态数据，同时做特征级别的前融合以及注意力机制下的后融合，达到了较好的效果。</p><h2 id="comparison-between-lidar-and-radar">1. Comparison between LiDAR and Radar</h2><p><img src="/paper-reading-RadarNet/compare.png" width="90%" height="90%" title="图 1. Comparison"> 　　LiDAR 可分为三种类型：Spinning，Solid State，Flash。目前主要采用的是 Spinning 旋转式的激光雷达。激光雷达的缺点有：</p><ul><li>对雨雾雪，车尾气等比较敏感；</li><li>对玻璃等物体没有反射;</li><li>点云密度随着距离增加而下降，远距离探测能力较弱。</li></ul><p>毫米波雷达则能克服以上缺点，并且能直接测量速度；但是缺点也比较明显：</p><ul><li>分辨率低，对小目标探测能力较弱；</li><li>误检较多；</li><li>测量的速度只是径向速度。</li></ul><p>毫米波雷达可输出三种形式的数据：1. 原始点运数据；2. 经过 DBSCAN 等聚类算法获得的聚类点集数据；3. 对点集作跟踪的数据。三种数据越来越高层，但是噪音越来越大。本文考虑输出点集的数据，设探测到的点集目标为 \(Q = (q, v _ {||},m,t)\)，其中 \(q = (x,y)\) 是俯视图下的位置，\(v _ {||}\) 是径向速度，\(m\) 代表目标是否运动，\(t\) 则为时间戳。我们需要进一步估计出目标的 2D 速度，由此在毫米波雷达的辅助下，能获得更长的检测距离，以及更准确的速度。 <img src="/paper-reading-RadarNet/fusion.png" width="90%" height="90%" title="图 2. Fusion"> 　　激光雷达数据与毫米波雷达数据融合示意图如图 2. 所示。</p><h2 id="radarnet">2. RadarNet</h2><p><img src="/paper-reading-RadarNet/framework.png" width="90%" height="90%" title="图 3. Framework"> 　　如图 3. 所示，RadarNet 主要由 Voxel-Based Early Fusion，Detection Network 以及 Attention-Based Late Fusion 来做融合检测。前融合将各传感器数据通过俯视图形式进行表示并融合；后融合则通过基于注意力的数据关联及整合机制来对目标速度进行精细估计。检测网络是在传统的分类＋回归基础上，多了速度预测的分支。具体的，所有回归的预测量为 \((x-p _ x,y - p _ y,w,l,\mathrm{cos}(\theta),\mathrm{sin}(\theta),m,v _ x, v _ y)\)，其中 \(p _ x,p _ y\) 为体素/栅格的中心点，\(m\) 为目标是运动的概率，如果 \(m &lt; 0.5\)，则将速度置为 0。</p><h3 id="early-fusion">2.1. Early Fusion</h3><p>　　对于激光雷达数据，类似 <a href="/paperreading-Fast-and-Furious/" title="FAF">FAF</a>，将时序多帧(0.5s)的点云数据在本车坐标系下打成俯视图体素表示，然后在通道维度进行串联。如果体素内没有点，那么该体素值为 0；如果体素内有点 \(\{(x _ i,y _ i,z _ i),i=1,...,N\}\)，那么体素值为 \(\sum _ i\left( 1- \frac{|x _ i-a|}{dx / 2}\right)\left( 1- \frac{|y _ i-b|}{dy / 2}\right)\left( 1- \frac{|z _ i-c|}{dz / 2}\right)\)，其中 \((a,b,c)\) 为体素中心坐标，\(dx,dy,dz\) 为体素尺寸。<br>　　对于毫米波雷达数据，将其转到激光雷达坐标系后，也进行 BEV 时序串联，并将每一帧中不同线束的数据在 BEV 下体素化，然后串联。具体的，如果体素(本文丢掉了高度信息，所以退化为栅格)中没有毫米波探测到的目标，那么置为 0，如果探测到动态目标，则置为 1，如果探测到静态目标，则置为 -1。<br>　　分别得到激光雷达与毫米波雷达的 BEV 表示后，将二者在通道维度串联起来，就完成了前融合。</p><h3 id="late-fusion">2.2. Late Fusion</h3><p>　　<strong>前融合关注毫米波雷达探测到的目标的位置和密度，后融合则使用毫米波雷达探测到的目标径向速度信息</strong>。检测网络输出的目标状态为 \(D = (c,x,y,w,l,\theta,\mathbf{v})\)，毫米波雷达输出的目标状态为 \(Q=(q,v _ {||},m,t)\)。两者的目标级别的后融合通过 Association 和 Aggregation 两步骤组成。 <img src="/paper-reading-RadarNet/late-fusion.png" width="90%" height="90%" title="图 4. Late-Fusion"> 　　本文将 Association 和 Aggregation 用 End-to-End 的网络来处理。如图 4. 所示，首先进行检测目标与毫米波目标的成对特征提取，然后经过 MLP/Softmax 作匹配分数估计，最后根据分数作速度的加权优化。</p><h4 id="pairwise-detection-radar-association">2.2.1. Pairwise Detection-Radar Association</h4><p>　　定义 Pairwise Feature 为： <span class="math display">\[\begin{align}f(D,Q) &amp;= \left(f ^ {det}(D),f ^ {det-radar}(D,Q)\right) \tag{1}\\f ^ {det}(D) &amp;= \left(w,l,||\mathbf{v}||,\frac{v _ x}{||\mathbf{v}||},\frac{v _ y}{||\mathbf{v}||},\mathrm{cos}(\gamma)\right) \tag{2}\\f ^ {det-radar}(D,Q) &amp;= \left(dx,dy,dt,v ^ {bp}\right) \tag{3}\\v ^ {bp} &amp;= \mathrm{min}\left(50,\frac{v _ {||}}{\mathrm{cos}(\phi)}\right) \tag{4}\end{align}\]</span> 其中 \((\cdot,\cdot)\) 是 Concatenation 操作；\(\gamma\) 是网络检测 \(D\) 的运动方向与径向方向的夹角；\(\phi\) 是 \(D\) 运动方向与雷达探测目标 \(Q\) 的径向方向的夹角；\(v ^ {bp}\) 是径向速度反投影到运动方向(朝向)的速度值；\((dx,dy,dt)\) 为俯视图下 \(D,Q\) 的相对位置和时间。由此，通过 MLP 学习匹配分数： <span class="math display">\[s _ {i,j}=\mathrm{MLP} _ {match}\left(f(D _ i,Q _ j)\right)\tag{5}\]</span></p><h4 id="velocity-aggregation">2.2.2. Velocity Aggregation</h4><p>　　根据 \(D,Q\) 间的匹配分数，优化<strong>目标的绝对速度值</strong>。为了解决没有匹配的情况，分数 Concate 1，然后计算归一化的匹配分数： <span class="math display">\[s _ i ^ {norm}=\mathrm{softmax}((1,s _ {i,:})) \tag{6}\]</span> 然后优化每个检测目标 \(i\) 的绝对速度值： <span class="math display">\[v _ i&#39; = s _ i ^ {norm}\cdot\begin{bmatrix}||\mathbf{v} _ i|| \\v _ {i,:} ^ {bp}\end{bmatrix}\tag{7}\]</span> 最终可得到目标的 2D 速度： <span class="math display">\[\mathbf{v}&#39; _ i = v&#39; _ i\cdot\left(\frac{v _ x}{||\mathbf{v}||},\frac{v _ y}{||\mathbf{v}||}\right) \tag{8}\]</span> 　　<strong>由此可知，该后融合优化的只是目标的绝对速度(毫米波雷达也没办法探测目标的朝向或运动方向)，目标的朝向准确度还是由检测网络决定。</strong></p><h2 id="experiments">3. Experiments</h2><p>　　根据式(2,3)提取的特征，作者设计了基于 Heuristic 的关联方法，毫米波雷达探测的目标与网络检测的目标关联的条件为： <span class="math display">\[\left\{\begin{array}{rl}\sqrt{(dx) ^ 2+(dy) ^ 2} &amp;&lt; 3m \\\gamma &amp;&lt; 40°\\||\mathbf{v}|| &amp;&gt; 1m/s\\v ^ {bp} &amp;&lt; 30m/s \\\end{array}\tag{9}\right.\]</span> 一旦关联上后，去毫米波雷达速度的中位数作目标速度的进一步优化。这种传统的 Heuristic 与本文的 Attention 方法对比如下，优势明显。 <img src="/paper-reading-RadarNet/exp.png" width="80%" height="80%" title="图 5. Heuristic VS. Attention"></p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Yang, Bin, et al. &quot;RadarNet: Exploiting Radar for Robust Perception of Dynamic Objects.&quot; arXiv preprint arXiv:2007.14366 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Radar 相比 LiDAR/Camera，对天气影响鲁棒性较强，而且能直接测量目标速度，所以是多传感器融合感知里比较重要的一个输入。其在 ADAS 领域应用已经较为广泛。但是 Radar 的测量噪声较大，这给有效的多传感器融合带来了难度。本文提出了 RadarNet&lt;
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Pillar-based Object Detection&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Pillar-based-Object-Detection/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Pillar-based-Object-Detection/</id>
    <published>2020-08-04T03:42:08.000Z</published>
    <updated>2020-08-06T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 在俯视图点云特征的基础上，融合了点云的前视图特征，由此解决点云在远处比较稀疏，以及行人等狭长型目标特征信息较少的问题。本文<a href="#1" id="1ref"><sup>[1]</sup></a>基于 <a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 作了三部分的改进：</p><ol type="1"><li>检测头改为 Anchor-Free 的形式，本文称之为 Pillar-based，其实就是图像中对应的像素点；</li><li>前视图用 Cylindrical View 代替 Spherical View，解决目标高度失真的问题；</li><li>两个视图的栅格特征反投影回点特征作融合时，采用双线性插值的形式，避免量化误差的影响。</li></ol><h2 id="framework">1. Framework</h2><p><img src="/paper-reading-Pillar-based-Object-Detection/framework.png" width="90%" height="90%" title="图 1. Framework"> 　　如图 1. 所示，点云分别投影到 BEV(Brids-Eye)，CYV(Cylindrical) 视角，然后作类似图像卷积的 2D 卷积操作以提取特征，并将特征反投影回点作融合(与 <a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 一致)，接着将点云特征再次投影到 BEV 下，最后作 Anchor-Free 的分类与回归任务。<br>　　具体的，设 \(N\) 个点的点云 \(P=\{p _ i\} _ {i=0} ^ {N-1}\subseteq\mathbb{R} ^ 3\)，对应的特征向量为 \(F = \{f _ i\} _ {i=0} ^ {N-1}\subseteq\mathbb{R} ^ K\)。令 \(F _ V(p _ i)\) 返回点 \(p _ i\) 对应的栅格柱子 \(v _ j\) 的索引 \(j\)；\(F _ P(v _ j)\) 则返回栅格柱子 \(v _ j\) 对应的点集。对每个柱子进行特征整合，一般采用类似 PointNet(PN) 的方法： <span class="math display">\[f _ j ^{pillar} = \mathrm{PN} (\{f _ i|\forall p _ i\in F _ P(v _ j)\}) \tag{1}\]</span> pillar 级别的特征经过 CNN \(\phi\) 后得到进一步的 pillar 级别特征：\(\varphi=\phi(f ^ {pillar})\)。然后分别对 BEV，CYV 作 pillar-to-point 的特征投影变换： <span class="math display">\[f _ i^{point}=f _ j^{pillar}\;\mathrm{and}\;\varphi _ i^{point} = \varphi _ j^{pillar},\;\mathrm{where}\; j = F _ V(p _ i) \tag{2}\]</span> 最后的检测头是应用已经较为广泛的 Anchor-Free 形式。</p><h2 id="cylindrical-view">2. Cylindrical View</h2><p><img src="/paper-reading-Pillar-based-Object-Detection/proj.png" width="60%" height="60%" title="图 2. Projection"> 　　<a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 采用 Spherical 投影方式，对于点 \(p _ i=(x _ i, y _ i, z _ i)\)，其球坐标 \(\varphi _ i,\theta _ i,d _ i\) 为： <span class="math display">\[\left\{\begin{array}{l}\varphi _ i &amp;= \mathrm{arctan}\frac{y _ i}{x _ i}\\\theta _ i &amp;= \mathrm{arccos}\frac{z _ i}{d _ i}\\d _ i &amp;= \sqrt{x _ i ^ 2+y _ i ^ 2+z _ i^2}\end{array}\tag{3}\right.\]</span> 如图 2. 所示，球坐标系下目标高度的形变比较严重，本文采用柱坐标系，其柱坐标 \(\rho _ i,\varphi _ i,z _ i\) 表示为： <span class="math display">\[\left\{\begin{array}{l}\rho _ i &amp;=\sqrt{x _ i ^ 2+y _ i^2}\\\varphi _ i &amp;= \mathrm{arctan}\frac{y _ i}{x _ i}\\z _ i &amp;= z _ i\end{array}\tag{4}\right.\]</span> 　　在此视角下作 pillar-level 的特征提取，与俯视图视角一样，只不过作卷积的时候，是环状卷积。具体实现方式是，将柱坐标系下的 pillar 展开，然后边缘补对应展开处另一边的 pillar 值，最后作传统的 2D 卷积即可。</p><h2 id="pillar-based-prediction">3. Pillar-based Prediction</h2><p>　　这里所谓的 Pillar-based 预测，本质上就是图像中常说的 Anchor-Free 的 Pixel-Level 的检测方法。最后特征图上的每个点预测类别概率，以及 3D 框属性 \(\Delta _ x,\Delta _ y,\Delta _ z,\Delta _ l,\Delta _ w,\Delta _ h,\theta ^ p\)。这里不作展开。</p><h2 id="bilinear-interpolation">4. Bilinear Interpolation</h2><p><img src="/paper-reading-Pillar-based-Object-Detection/bilinear.png" width="60%" height="60%" title="图 3. Bilinear"> 　　将 Pillar-Level 提取的特征反投影到 Point-Level 的特征时，需要进行插值处理。如图 3. 所示，传统的方式是最近邻插值，这种方式会引入量化误差，使得点投影反投影后的空间坐标不一致，产生的影响是同一 Pillar 内的点特征都是一样了。本文采用双线性插值的方法，使得 Point-Pillar-Point 的空间坐标一致，这样保证了 Pillar 内点特征的原始精度。该思想还是非常有借鉴意义的，实验效果提升也比较明显。</p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> Wang, Yue, et al. &quot;Pillar-based Object Detection for Autonomous Driving.&quot; arXiv preprint arXiv:2007.10323 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/&quot; title=&quot;MVF&quot;&gt;MVF&lt;/a&gt; 在俯视图点云特征的基础上，融合
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="autonomous driving" scheme="https://leijiezhang001.github.io/tags/autonomous-driving/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
  </entry>
  
  <entry>
    <title>VLOAM(Visual-lidar Odometry and Mapping)</title>
    <link href="https://leijiezhang001.github.io/VLOAM/"/>
    <id>https://leijiezhang001.github.io/VLOAM/</id>
    <published>2020-07-29T08:36:38.000Z</published>
    <updated>2020-08-04T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　<a href="/LOAM/" title="LOAM">LOAM</a> 中 Lidar Odometry 模块将当前累积的 Sweep 点云通过 Sweep-to-Sweep 注册到上一时刻的 Sweep 点云，从而生成高频低精度的位姿；Lidar Mapping 则将完整的当前 Sweep 点云通过 Sweep-to-Model 注册到全局地图中，从而生成低频高精度的位姿。这其中高频低精度的位姿可通过其它方式获得，如 IMU 等其它高频传感器。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 采用高频的 Visual Odometry 来生成高频低精度的位姿，低频高精度的位姿则还是通过 Lidar Odometry(Mapping) 获得，但做了细微的改变。 <img src="/VLOAM/demo.png" width="55%" height="55%" title="图 1. Visual & Lidar Odometry"> 　　如图 1. 所示，VSLAM 结合了高频低精度的 Visual Odometry，以及低频高精度的 Lidar Odometry，最终得到高频高精度的位姿，以及准确的全局点云地图。</p><h2 id="framework">1. Framework</h2><p>　　本文坐标系以相机坐标系 \(\{S\}\) 为主(x left，y upward，z forward)，所有点云都会通过外参转换到该坐标系下；设世界坐标系 \(\{W\}\) 为起始点。那么位姿求解问题的数学描述为：给定各个坐标系 \(\{S\}\) 下的图像和点云，求解所有 \(\{S\}\) 在 \(\{W\}\) 下的表示，以及 \(\{W\}\) 下地图的构建。 <img src="/VLOAM/framework.png" width="95%" height="95%" title="图 2. VSLAM Framework"> 　　如图 2. 所示，Visual Odometry 作前后帧的特征跟踪(或匹配)，结合点云深度信息，作 Frame-to-Frame 的运动位姿估计；Lidar Odometry 则先通过 Sweep-to-Sweep 作运动粗估计，然后用 Sweep-to-Map 作精估计(其中 Sweep 的定义可见 <a href="/LOAM/" title="LOAM">LOAM</a>)。由此输出低频的全局地图，以及高频的位姿估计。</p><h2 id="visual-odometry">2. Visual Odometry</h2><p>　　首先用 Visual Odometry 得到的高频位姿估计将点云注册为一个局部的深度图。由此维护三种类型的特征点：1. 从深度图获得深度的特征点；2. 从前后帧三角化获得深度的特征点；3. 没有深度的特征点。这里的特征点提取可采用任意的特征点提取方法，如果采用前后帧特征匹配的策略，则还得作相应的特征描述子提取，如果采用特征跟踪策略，则不需要。<br>　　设图像帧序号 \(k\in Z ^ +\)，特征点序号 \(i\in\mathcal{I}\)，那么在相机坐标系 \(\{S ^ k\}\) 下，特征点坐标表示为 \(\sideset{^S}{}X ^ k _ i = [\sideset{^S}{}x ^ k _ i,\sideset{^S}{}y ^ k _ i,\sideset{^S}{}z ^ k _ i] ^ T\)，其归一化表示为 \({\sideset{^S}{}{\overline{X}}} ^ k _ i = [\sideset{^S}{}{\overline{x}} ^ k _ i,\sideset{^S}{}{\overline{y}} ^ k _ i,\sideset{^S}{}{\overline{z}} ^ k _ i] ^ T\)。前后匹配的特征点与运动位姿的关系为： <span class="math display">\[{\sideset{^S}{}X} ^ k _ i=R\;{\sideset{^S}{}X} ^ {k-1} _ i+T \tag{1}\]</span> 其中 \({\sideset{^S}{}X} ^ k _ i\) 为当前帧的特征点坐标，由于还未估计出当前帧的位姿，所以该特征点是没有深度信息的。根据特征点 \({\sideset{^S}{}X} ^ {k-1} _ i\) 是否有深度信息，可归纳出方程：</p><ol type="1"><li>\({\sideset{^S}{}X} ^ {k-1} _ i\) 有深度信息 <span class="math display">\[\begin{align}&amp;{\sideset{^S}{}{\overline{d}}} ^ k _ i{\sideset{^S}{}{\overline{X}}} ^ k _ i=R\;{\sideset{^S}{}X} ^ {k-1} _ i+T\\\Longrightarrow &amp; \left\{\begin{array}{l}\left({\sideset{^S}{}{\overline{z}}} ^ k _ i R _ 1-{\sideset{^S}{}{\overline{x}}} ^ k _ i R _ 3\right){\sideset{^S}{}{X}} ^ k _ i + {\sideset{^S}{}{\overline{z}}} ^ k _ i T _ 1-{\sideset{^S}{}{\overline{x}}} ^ k _ i T _ 3 = 0\\\left({\sideset{^S}{}{\overline{z}}} ^ k _ i R _ 2-{\sideset{^S}{}{\overline{y}}} ^ k _ i R _ 3\right){\sideset{^S}{}{X}} ^ k _ i + {\sideset{^S}{}{\overline{z}}} ^ k _ i T _ 2-{\sideset{^S}{}{\overline{y}}} ^ k _ i T _ 3 = 0\\\end{array}\tag{2}\right.\end{align}\]</span> 其中 \(\sideset{^S}{}{d} ^ k _ i = \left\Vert \sideset{^S}{}{\overline{X}} ^ k _ i\right\Vert \)，\(R _ l, T _ l\) 为第 \(l\in\{1,2,3\}\) 行的 \(R,T\)。</li><li>\({\sideset{^S}{}X} ^ {k-1} _ i\) 无深度信息 <span class="math display">\[\begin{align}&amp;{\sideset{^S}{}{\overline{d}}} ^ k _ i{\sideset{^S}{}{\overline{X}}} ^ k _ i=R\;{\sideset{^S}{}{\overline{d}}} ^ {k-1} _ i\;{\sideset{^S}{}X} ^ {k-1} _ i+T\\\Longrightarrow &amp;\begin{bmatrix}-{\sideset{^S}{}{\overline{y}}} ^ k _ i T _ 3  +{\sideset{^S}{}{\overline{z}}} ^ k _ i T _ 2 &amp;{\sideset{^S}{}{\overline{x}}} ^ k _ i T _ 3-{\sideset{^S}{}{\overline{z}}} ^ k _ i T _ 1 &amp;-{\sideset{^S}{}{\overline{x}}} ^ k _ i T _ 2+{\sideset{^S}{}{\overline{y}}} ^ k _ i T _ 1\end{bmatrix}R\;{\sideset{^S}{}{\overline{X}}} ^ {k-1} _ i = 0\tag{3}\end{align}\]</span> 推导过程比较繁杂，但是也比较简单，依次消去 \(\sideset{^S}{}{d} ^ k _ i,\sideset{^S}{}{d} ^ {k-1} _ i\) 即可。</li></ol><p>将所有特征点所构成的 residual 累积，然后可用 LM 法求解该非线性问题中 6-DOF 的位姿。考虑到有较大 residual 的特征点大概率是离群点，所以对特征点的 residual 作权重处理，residual 越大，权重越小。<br><img src="/VLOAM/feats.png" width="55%" height="55%" title="图 3. Edge & Planar Feature"> 　　为了获取特征点的深度，维护一个从点云中采样的在上一帧图像坐标系下的深度图，深度图维护较新的点云深度信息，并且保持一定的点密度。深度图中的点用极坐标形式的 2D KD-tree 存储，具体的特征点深度值计算通过周围深度点构成的平面插值得到。在无法从深度图中获得特征点的深度信息时，如果特征点被跟踪了较长的距离，那么采用三角测量法获得该特征点深度。三种点的可视化如图 3. 所示。</p><h2 id="lidar-odometry">3. Lidar Odometry</h2><p>　　高频的 frame-to-frame Visual Odometry 得到的位姿估计是粗糙且有漂移的，接下来用 Lidar Odometry 作进一步的精估计。激光雷达里程计又基于 coarse-to-fine 的思想，分为 sweep-to-sweep 以及 sweep-to-map 两个步骤。这两个步骤的具体计算过程很相似，只不过前者是前后帧点云的匹配以消除运动引入的点云畸变，后者则是当前帧去畸变的点云与世界坐标系下的地图点云匹配，能消除累积误差。总体上这部分与 <a href="/LOAM/" title="LOAM">LOAM</a> 处理方式一致。</p><h3 id="sweep-to-sweep">3.1. Sweep-to-Sweep</h3><p><img src="/VLOAM/vo_drift.png" width="55%" height="55%" title="图 4. Drift"> 　　与 <a href="/LOAM/" title="LOAM">LOAM</a> 一样，对第 \(m\in Z ^ +\) 个 Sweep 点云 \(\mathcal{P} ^ m\)，提取线特征 \(\mathcal{E} ^ m\) 与面特征 \(\mathcal{H} ^ m\)。如图 4. 所示，将 Visual Odometry 产生的漂移建模为线性运动模型。假设第 \(m\) 个 Sweep 扫描期间其漂移的位姿为 \(T'\in\mathbb{R} ^ {6\times 1}\)，那么，对于点 \(i\in\mathcal{E} ^ m\cup\mathcal{H} ^ m\)，其接收时间 \(t _ i\) 对应的位姿漂移为： <span class="math display">\[T _ i&#39; = T&#39;(t _ i-t ^ m)/(t ^ {m+1}-t ^ m) \tag{4}\]</span> 　　为了求解 \(T'\)，分别找到当前帧特征点 \(\mathcal{E} ^ m,\mathcal{H} ^ m\) 与上一帧特征点的匹配，然后计算距离误差的 residual，累积后即可用 LM 法来求解该非线性最小二乘问题。对于 \(\mathcal{E} ^ m\)，在 \(\mathcal{P} ^ {m-1}\) 中找到最近的两个线特征点，从而计算 point-to-edge 距离；对于 \(\mathcal{H} ^ m\)，在 \(\mathcal{P} ^ {m-1}\) 中找到最近的三个面特征点，从而计算 point-to-plane 距离。找特征点的过程通过 3D KD-tree 实现(工程上为了加速，可以采用其它方法)。由此得到一系列方程： <span class="math display">\[f({\sideset{^S}{}X} ^ m _ i, T _ i&#39;)=d _ i \tag{5}\]</span> 其中 \({\sideset{^S}{}X} ^ m _ i\) 是点 \(i\in\mathcal{E} ^ m\cup\mathcal{H} ^ m\) 在 \(\{S ^ m\}\) 下的坐标。计算 \(T'\) 后，即可得到去畸变的当前帧点云 \(\mathcal{P} ^ m\)。</p><h3 id="sweep-to-map">3.2. Sweep-to-Map</h3><p>　　去畸变的点云 \(\mathcal{P} ^ m\) 可以进一步注册到点云地图 \(\mathcal{Q} ^ {m-1}\) 中。考虑到点云地图较为稠密，匹配过程为计算局部点集的分布特征值与特征向量。特征值一大两小，即为线特征；特征值两大一小则为面特征。因为没有 Sweep-to-Sweep 中的运动模型，所以可直接用 ICP 方法来优化求解位姿。最终得到低频高精度的位姿结果。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Zhang, Ji, and Sanjiv Singh. &quot;Visual-lidar odometry and mapping: Low-drift, robust, and fast.&quot; 2015 IEEE International Conference on Robotics and Automation (ICRA). IEEE, 2015.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　&lt;a href=&quot;/LOAM/&quot; title=&quot;LOAM&quot;&gt;LOAM&lt;/a&gt; 中 Lidar Odometry 模块将当前累积的 Sweep 点云通过 Sweep-to-Sweep 注册到上一时刻的 Sweep 点云，从而生成高频低精度的位姿；Lidar Mapping
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>SuMa(Surfel-based Mapping)</title>
    <link href="https://leijiezhang001.github.io/SuMa/"/>
    <id>https://leijiezhang001.github.io/SuMa/</id>
    <published>2020-07-20T01:31:34.000Z</published>
    <updated>2020-07-28T03:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　目前业界比较流行的基于激光雷达的 SLAM 是 <a href="/LOAM/" title="LOAM">LOAM</a>，其中 Mapping 又是非常重要的一环，LOAM 提取 Edge 点与 Surf 点然后建立以 Voxel 约束点个数的点云地图，该地图用于 Lidar Odometry 时的匹配定位。实际应用于工业界时，Mapping 的数据结构设计及存取管理对整体系统的效率至关重要，具体可优化的细节以后再写文阐述。<br>　　本系列文章<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a> 提出了一种基于 Surfel 和语义信息的建图及定位方法。整体框架与 LOAM 类似，只是这里只用了面区域的特征点，其它模块，如优化方式，也有很大的差异。</p><h2 id="suma">1. SuMa</h2><p>　　设 \(A\) 坐标系下的点 \(p _ A\)，\(B\) 坐标系下的点 \(p _ B\)，其变换矩阵 \(T _ {BA}\in\mathbb{R}^{4\times 4}\)，使得 \(p _ B = T _ {BA} p _ A\)。变换矩阵 \(T _ {BA}\) 又由 \(R _ {BA}\in\mathbf{SO}(3)\) 和 \(t _ {BA}\in\mathbb{R}^3\) 构成。设每帧点云的雷达坐标系为 \(C _ k,k\in\{0,...,t\}\)，那么 Lidar Odometry 要求解的问题就是当前雷达坐标系在世界坐标系下的表示： <span class="math display">\[T _ {WC _ t} = T _ {WC _ 0}T _ {C _ 0C _ 1}\cdots T _ {C _ {t-1}C _ t} \tag{1}\]</span> 其中 \(T _ {WC _ 0}\) 为已标定的变换矩阵。 <img src="/SuMa/suma.png" width="65%" height="65%" title="图 1. SuMa Framework"> 　　如图 1. 所示，SuMa 根据点云 \(\mathcal{P} = \{p\in\mathbb{R}^3\}\) 估计 \(T _ {WC _ t}\) 的步骤为：</p><ol type="1"><li>当前帧地图计算。将当前帧的三维点云投影到二维，得到顶点图 \(\mathcal{V} _ D\)，以及计算对应的法向量图 \(\mathcal{N} _ D\)；</li><li>当前地图计算。对上一帧优化出的 Surfel Map \(\mathcal{M} _ {active}\) 作顶点图和法向量图的渲染 \(\mathcal{V} _ M,\mathcal{N} _ M\)；</li><li>位姿计算。根据 \(\mathcal{V} _ D, \mathcal{N} _ D\) 以及 \(\mathcal{V} _ M,\mathcal{N} _ M\) 作 frame-to-model 的 ICP 匹配，得到相对位姿 \(T _ {C _ {t-1}C _ t}\)，最后用式(1)计算当前帧在世界坐标系下的位姿态 \(T _ {WC _ t}\)；</li><li>地图更新。根据 \(T _ {WC _ t}\)，更新 Surfel Map \(\mathcal{M} _ {active}\)：初始化首次观测的区域，优化更新再次观测的区域；</li><li>闭环检测。在未激活的 Surfel Map \(\mathcal{M} _ {inactive}\) 中搜索当前帧地图的匹配；</li><li>闭环检测验证。在接下来 \(\Delta _ {verification}\) 时间内，验证闭环检测的有效性，如果有效，那么加入之后的位姿图优化；</li><li>位姿图优化。另一个线程作位姿图优化，输入信息是前后帧的相对位姿里程计以及闭环检测的相对位姿结果，类似 <a href="/AVP-SLAM/" title="AVP-SLAM">AVP-SLAM</a> 中的位姿图优化。优化后的位姿用来更新 Surfel Map。</li></ol><h3 id="preprocessing">1.1. Preprocessing</h3><p>　　与 RangeNet++<a href="#3" id="3ref"><sup>[3]</sup></a> 中对点云的表示一样，顶点图 \(\mathcal{V} _ D\) 的计算方法为： <span class="math display">\[\left(\begin{matrix}u\\v\\\end{matrix}\right)=\left(\begin{matrix}\frac{1}{2}[1-\mathrm{arctan}(y,x)\cdot \pi ^ {-1}]\cdot w\\[1-(\mathrm{arcsin}(z\cdot r ^ {-1})+f _ {up})f ^ {-1}]\cdot h\end{matrix}\right)\tag{2}\]</span> 其中 \(r = \Vert p\Vert _ 2\) 为点的距离，\(f = f _ {up} + f _ {down}\) 是雷达的上下视野角，\(w,h\) 为顶点图的宽和高。然后基于 \(\mathcal{V} _ D\) 计算每个顶点的法向量，得到法向量图 \(\mathcal{N} _ D\): <span class="math display">\[\mathcal{N} _ D((u,v)) = \left(\mathcal{V} _ D((u+1,v))-\mathcal{V} _ D((u,v))\right)\times \left(\mathcal{V} _ D((u,v+1))-\mathcal{V} _ D((u,v))\right) \tag{3}\]</span> 其中只计算坐标点 \((u,v)\) 有顶点的法向量。因为 \(u\) 方向物理世界是环状的，所以对边界作环向处理。这种法向量计算的 \(\mathcal{N} _ D\) 由较大噪声，但是实验发现对 Frame-to-Model 的 ICP 匹配不会产生精度影响。 <img src="/SuMa/preprocess_suma.png" width="55%" height="55%" title="图 2. SuMa Preprocessing"> 　　顶点图 \(\mathcal{V} _ D\) 与法向量图 \(\mathcal{V} _ N\) 的可视化结果如图 2. 所示。</p><h3 id="map-representation">1.2. Map Representation</h3><p>　　不同于 <a href="/LOAM/" title="LOAM">LOAM</a> 中采用了 Edge 和 Surf 两种特征来表示地图，本文只用 Surfel 来表示地图 \(\mathcal{M}\)。<a href="/LOAM/" title="LOAM">LOAM</a> 中计算了每个点的曲率，然后将其归为 Edge 或是 Surf，实际工程应用中，为了存储的高效性，首先将点云地图体素化，然后将体素内的特征点用 Mean，Normal，协方差矩阵的 EigenVector 等信息来存储，Normal 可用来表征 Surf 特征点，EigenVector 则可用来表征 Edge 特征点，这块具体的细节以后开文再详细阐述。<br>　　本文的 Surfel Map 自然就提取了点云的 Surf 特征，每个Surfel 可以用位置 \(v _ s\in\mathbb{R} ^ 3\)，法向量 \(n _ s\in\mathbb{R} ^ 3\)，半径 \(r _ s\in\mathbb{R}\) 来表示。此外每个 Surf 包含两个时间戳：首次建立的时间 \(t _ c\)，以及最新更新的时间 \(t _ u\)。然后采用贝叶斯滤波方法(详见 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a>)，定义及计算 Surfel 特征的稳定概率： <span class="math display">\[\begin{align}l _ s ^ {(t)} &amp;= l _ s ^ {t-1} + \mathrm{log}(p\cdot (1-p) ^ {-1}) - \mathrm{log}(p _ {prior}\cdot (1-p _ {prior}) ^ {-1})\\&amp;= l _ s ^ {t-1} + \mathrm{odds}(p) - \mathrm{odds}(p _ {prior})\\&amp;= l _ s ^ {t-1} + \mathrm{odds}\left(p _ {stable}\cdot \mathrm{exp}\left(-\frac{\alpha ^ 2}{\sigma _ {\alpha} ^ 2}\right)\mathrm{exp}\left(-\frac{d ^ 2}{\sigma _ d ^ 2}\right)\right) - \mathrm{odds}(p _ {prior})\end{align} \tag{4}\]</span> 其中 \(p _ {stable}, p _ {prior}\) 分别为测量为 surfel 是 stable 的概率，以及先验概率。\(\sigma ^ 2\) 为测量噪声方差。\(\alpha\) 为测量的 Surfel 法向量与对应的地图中 Surfel 法向量的夹角，\(d\) 则为测量的 Surfel 与对应的地图中 Surfel 的距离。<br>　　每个 Surfel 的位置及法向量都是以建立时的位置作为参考系，即 \(C _ {t _ c}\)。这样经过全局位姿优化后，就不需要重新建图，只需要通过 \(T _ {WC _ {t _ c}}\) 将 Surfel 地图更新到世界坐标系即可。<br>　　\(\mathcal{M} _ {active}\) 与 \(\mathcal{M} _ {inactive}\) 的区分也比较简单：\(\mathcal{M} _ {active}\) 定义为最近更新的 Surfels，即 \(t _ u\geq t - \Delta _ {active}\)；\(\mathcal{M} _ {inactive}\) 则定义为不是最近建立的 Surfels，即 \(t _ c&lt; t - \Delta _ {active}\)。Odometry 只在 \(\mathcal{M} _ {active}\) 中作匹配计算，Loop Closure 则只在 \(\mathcal{M} _ {inactive}\) 中搜索。</p><h3 id="odometry-estimation">1.3. Odometry Estimation</h3><p>　　里程计是将当前帧点云与地图点云匹配的过程。将上一时刻的地图 \(\mathcal{M} _ {active}\) 渲染成上一时刻局部坐标系下的顶点图 \(\mathcal{V} _ M\) 与法向量图 \(\mathcal{N} _ M\) 形式。然后采用 point-to-plane 的 ICP 匹配方法，其最小化误差为： <span class="math display">\[ E(\mathcal{V} _ D,\mathcal{V} _ M, \mathcal{N} _ M) = \sum _ {u\in\mathcal{V} _ D}n _ u ^ T\cdot\left(T _ {C _ {t-1}\;C _ t}^{(k)}\;u-v _ u\right) ^ 2 \tag{5}\]</span> 其中 \(u\in\mathcal{V} _ D\)，\(v _ u\in\mathcal{V} _ M,n _ u\in\mathcal{N} _ M\) 是地图上对应关联上的点，关联过程为： <span class="math display">\[\begin{align}v _ u &amp;= \mathcal{V} _ M\left(\Pi\left(T _ {C _ {t-1}\;C _ t}^{(k)}\;u\right)\right)\\n _ u &amp;= \mathcal{N} _ M\left(\Pi\left(T _ {C _ {t-1}\;C _ t}^{(k)}\;u\right)\right)\end{align} \tag{6}\]</span> 其中 \(T _ {C _ {t-1}\;C _ t} ^ {(t)}\) 为 frame-to-model ICP 得到的里程计估计的相对位姿。\(\Pi(u)\) 是特征点的关联方式，<a href="/LOAM/" title="LOAM">LOAM</a> 中根据前后线束的关系来寻找关联方式，本方案则采用直接坐标映射的方式。<strong>因为点云均投影到了前视图，所以可根据坐标直接搜索关联，这也是本方案最重要的优势之一</strong>。具体的，如图对应的地图顶点图中没有顶点，或者地图法向量点没有定义，那么忽略该待关联的特征点；对于关联的特征点对距离大于 \(\sigma _ {ICP}\) 或是法向量夹角大于 \(\theta _ {ICP}\) 的情况，则认为是离群点，不计入误差项。ICP 初始化为上一帧的相对位姿结果。<br>　　该问题是典型的非线性最小二乘问题，可在李空间下对位姿进行线性化并用 Gaussian-Newton 求解，这里不做展开。</p><h3 id="map-update">1.4. Map Update</h3><p>　　得到里程计估计的相对位姿后，要将当前帧的特征点更新到地图中，即要确定哪些 Surfel 要更新，哪些要重新构建新的 Surfel。对于 \(v _ s\in\mathcal{V} _ D\)，首先计算其面元的半径： <span class="math display">\[ r _ s = \frac{\sqrt{2}\Vert v _ s\Vert _ 2\cdot p}{\mathrm{clam}(-v _ s ^ T n _ s\cdot\Vert v _ s\Vert _ 2 ^ {-1}, 0.5, 1.0)} \tag{7}\]</span> 其中 \(p=\mathrm{max}(w\cdot f _ {horiz} ^ {-1}, h\cdot f _ {vert} ^ {-1})\)。<strong>根据式(2)，每个 \(v _ s\) 均能找到地图中对应的 Surfel \(s '\)。</strong>然后通过 \(\vert n _ {s'} ^ T(v _ s-v _ {s'})\vert &lt; \sigma _ M \;\mathrm{and}\; \Vert n _ s\times n _ {s'}\Vert &lt; \mathrm{sin}(\theta _ M)\) 判定当前帧的 Surfel 与地图中的 \(s'\) 是否一致：</p><ul><li>如果一致。那么更新地图中的 Surfel，如果估计的半径更准，那么也更新： <span class="math display">\[\begin{align}v _ {s&#39;} ^ {(t)} &amp;= (1-\gamma)\cdot v _ s + \gamma\cdot v _ {s&#39;} ^ {(t-1)}\\n _ {s&#39;} ^ {(t)} &amp;= (1-\gamma)\cdot n _ s + \gamma\cdot n _ {s&#39;} ^ {(t-1)}\\r _ {s&#39;} ^ {(t)} &amp;= r _ s, \; \mathrm{if} \; r _ s &lt; r _ {s&#39;}\end{align} \tag{8}\]</span></li><li>如果不一致。那么将地图中匹配上的 Surfel 作 Stable 概率衰减，然后创建新的 Surfel。如果地图中没有匹配的 Surfel，那么也创建新的 Surfel。</li></ul><p>最后将 Stable 概率较小的 Surfel 以及时间较早的 Surfel 删除，以此删除动态障碍物特征点以及较老的无关的特征点。</p><h3 id="loop-closures">1.5. Loop Closures</h3><p>　　检测到闭环后就可以作 Pose Graph 优化。闭环检测由检测与验证两部分组成，检测的过程为在未激活的地图 \(\mathcal{M} _ {inactive}\) 中找到一个最相近的位姿： <span class="math display">\[ j ^ * = \mathop{\arg\min}\limits _ {j\in 0,...,t-\Delta _ {active}} \Vert t _ {WC _ t}-t _ {WC _ j}\Vert \tag{9}\]</span> 然后类似 Odometry 的过程，将当前帧的点云特征注册到 \(T _ {WC _ j ^ * }\) 的地图特征中。为了用 ICP 求解两者的相对位姿 \(T _ {C _ {j ^ * }C _ t}\)，初始化 \(T ^ {(0) } _ {C _ {j ^ * }C _ t}\) 为： <span class="math display">\[\begin{align}R _ {C _ {j^ * }C _ t} &amp;= R ^ {-1} _ {WC _ {j ^ * }}R _ {WC _ t}\\t _ {C _ {j^ * }C _ t} &amp;= R ^ {-1} _ {WC _ {j ^ * }}(t _ {WC _ t}-t _ {WC _ {j ^ * }})\\\end{align} \tag{10}\]</span> 本文将 \(T ^ {(0) } _ {C _ {j ^ * }C _ t}\) 中的位移用 \(\lambda t _ {C _ {j ^ * }C _ t}\) 代替，其中 \(\lambda = \{0.0,0.5,1.0\}\)。由此可得到三种初始化后 ICP 迭代的结果，选择最合理的结果即可。<br>　　验证阶段，在 \(t + 1,...,t+ \Delta _ {verification}\) 时间段内，在 \(\mathcal{M} _ {active}\) 与 \(\mathcal{M} _ {inactive}\) 地图中分别作 Odometry 累加，查看两者的一致性，如果一致则认为该闭环检测是有效的。</p><h2 id="suma-1">2. SuMa++</h2><p><img src="/SuMa/suma++.png" width="95%" height="95%" title="图 3. SuMa++ Framework"> 　　SuMa++ 相比 SuMa，只增加了语义信息，算法框架没有改变。如图 3. 所示，SuMa++ 也有当前帧地图计算，当前地图计算，位姿计算，地图更新，闭环检测，闭环检测验证，位姿图优化等七个部分组成，其中，在地图计算中加入了有 RangeNet++ 产生的语义信息，在 \(\mathcal{V} _ D,\mathcal{N} _ D\) 的基础上，增加 \(\mathcal{S} _ D\) 特征；在地图更新中，根据语义信息加入了动态障碍物过滤的策略；在位姿计算中，用语义信息来权重化特征的 ICP 匹配迭代。</p><h3 id="semantic-map">2.1. Semantic Map</h3><p>　　RangeNet++ 也是基于式(2)投影试图下的分割模型，由此可得到 Surfel 特征图 \(\mathcal{V} _ D\) 中每个像素点的语义类别以及对应的类别概率。由于语义分割预测的噪声，本文用 Flood-fill 算法对网络输出的语义分割图 \(\mathcal{S} _ {raw}\) 作优化，得到顶点图对应的语义信息 \(\mathcal{S} _ D\)。 <img src="/SuMa/preprocess.png" width="65%" height="65%" title="图 4. SuMa++ Preprocessing"> 　　考虑到语义分割在物体中心区域确定性较高，而在边缘处不确定性较高，所以 Flood-fill 算法采用两个步骤：</p><ol type="1"><li>用腐蚀算法将与周围语义类别不一致的像素点移除，得到腐蚀后的语义图 \(\mathcal{S} _ {raw} ^ {eroded}\)；</li><li>结合有深度信息的顶点图 \(\mathcal{V} _ D\)，对腐蚀的边缘像素点填充为周围相近距离的顶点对应的语义类别，得到 \(\mathcal{S} _ D\)；</li></ol><p>如图 4. 所示，该方法能修正边缘类别错误的情况。由此，\(\mathcal{V} _ D, \mathcal{N} _ D,\mathcal{S} _ D\)组成每一帧的特征点信息。</p><h3 id="filtering-dynamics">2.2. Filtering Dynamics</h3><p><img src="/SuMa/res.png" width="65%" height="65%" title="图 5. Filterring Dynamics"> 　　有了语义类别信息后，在更新地图时，可计算当前帧每个 Surfel 与地图中对应 Surfel 的类别一致性，由此作为地图贝叶斯更新的惩罚项，如果类别不一致，地图中的 Surfel 稳定性概率会降低，直到去除。如图 5. 所示，这种方法能去除大部分动态障碍物区域所构成的 Surfel。地图具体的贝叶斯更新为： <span class="math display">\[\begin{align}l _ s ^ {(t)} = l _ s ^ {t-1} + \mathrm{odds}\left(p _ {stable}\cdot \mathrm{exp}\left(-\frac{\alpha ^ 2}{\sigma _ {\alpha} ^ 2}\right)\mathrm{exp}\left(-\frac{d ^ 2}{\sigma _ d ^ 2}\right)\right) - \mathrm{odds}(p _ {prior}) - \mathrm{odds}(p _ {penalty})\end{align} \tag{11}\]</span></p><h3 id="semantic-icp">2.3. Semantic ICP</h3><p>　　在式(5)的 ICP 误差项基础上，可加入语义约束，对误差项作权重化： <span class="math display">\[ E(\mathcal{V} _ D,\mathcal{V} _ M, \mathcal{N} _ M) = \sum _ {u\in\mathcal{V} _ D}w _ u n _ u ^ T\cdot\left(T _ {C _ {t-1}\;C _ t}^{(k)}\;u-v _ u\right) ^ 2 \tag{12}\]</span> 其中权重项结合了语义约束与几何约束，以此来减少离群特征点对优化的影响： <span class="math display">\[w _ u ^{(k)} = \rho _ {Huper}\left(r _ u ^ {(k)}C _ {semantic}(\mathcal{S} _ D(u),\mathcal{S} _ M(u))\right)\mathbb{1}\left\{l _ s ^ {(k)}\geq l _ {stable}\right\} \tag{13}\]</span> 其中 \(\rho _ {Huber}(r)\) 是 Huber 核函数： <span class="math display">\[\rho _ {Huber}(r)=\left\{\begin{array}{l}1 &amp;,\mathrm{if}\;\vert r\vert &lt; \sigma\\\sigma\vert r\vert ^ {-1} &amp;,\mathrm{otherwise}\end{array}\tag{14}\right.\]</span> 语义约束项为： <span class="math display">\[C _ {semantic}\left((y _ u,P _ u),(y _ {v _ u}, P _ {v _ u})\right)=\left\{\begin{array}{l}P(y _ u|u) &amp;,\mathrm{if}\;y _ u=y _ {v _ u}\\1-P(y _ u|u) &amp;,\mathrm{otherwise}\end{array}\tag{15}\right.\]</span></p><p><img src="/SuMa/icp.png" width="65%" height="65%" title="图 6. Weights of ICP"> 　　如图 6. 所示，在语义信息的约束下，如果当前帧某个 Surfel 的类别与地图中对应的 Surfel 类别不一致，那么就会减少该 Surfel 匹配对的误差项。</p><h2 id="thinkings">3. Thinkings</h2><p>　　利用检测或分割得到的语义信息去过滤当前帧以及地图中的动态障碍物，在 SLAM/Odometry 中已经非常常见，其实可以大概率相信语义信息，然后直接将对应的点云干掉。而本文以融合迭代的思路，想通过将信将疑的方式来完成有效的 ICP 匹配（既要滤掉大多数动态障碍物的影响，也期望一堆车停在场景中时然后保留足够匹配的特征点）。但是一般工程上，直接干掉也够用，毕竟场景够大，不太可能出现特征点不够匹配的情景。<strong>而本方法的高效性在于，寻找当前帧与地图中的 Surfel 匹配时，直接采用图像索引然后顶点图距离及法向量图角度判断有效性的形式，没有 KD-Tree，极大提高效率</strong>，类似 ICPCUDA<a href="#4" id="4ref"><sup>[4]</sup></a>。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Behley, Jens, and Cyrill Stachniss. &quot;Efficient Surfel-Based SLAM using 3D Laser Range Data in Urban Environments.&quot; Robotics: Science and Systems. 2018.<br><a id="2" href="#2ref">[2]</a> Chen, Xieyuanli, et al. &quot;Suma++: Efficient lidar-based semantic slam.&quot; 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2019.<br><a id="3" href="#3ref">[3]</a> Milioto, Andres, et al. &quot;RangeNet++: Fast and accurate LiDAR semantic segmentation.&quot; 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2019.<br><a id="4" href="#4ref">[4]</a> https://github.com/mp3guy/ICPCUDA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　目前业界比较流行的基于激光雷达的 SLAM 是 &lt;a href=&quot;/LOAM/&quot; title=&quot;LOAM&quot;&gt;LOAM&lt;/a&gt;，其中 Mapping 又是非常重要的一环，LOAM 提取 Edge 点与 Surf 点然后建立以 Voxel 约束点个数的点云地图，该地图用于 
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>AVP-SLAM</title>
    <link href="https://leijiezhang001.github.io/AVP-SLAM/"/>
    <id>https://leijiezhang001.github.io/AVP-SLAM/</id>
    <published>2020-07-15T01:17:56.000Z</published>
    <updated>2020-07-17T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Visual-SLAM 一般采用特征点或像素直接法来建图定位，这种方式对光照较为敏感。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提出了一种基于语义特征的 Visual Semantic SLAM，应用于光照条件较为复杂的室内停车场环境，相比于采用特征点的 ORB-SLAM，性能较为鲁棒。</p><h2 id="framework">1. Framework</h2><p><img src="/AVP-SLAM/framework.png" width="95%" height="95%" title="图 1. AVP-SLAM Framework"> 　　如图 1. 所示，AVP-SLAM 由 Mapping，Localization 两部分组成。Mapping 阶段，将车周围的四张图通过 IPM 拼接并变换到俯视图，然后作 Guide Signs，Parking Lines，Speed Bumps 等语义信息的提取，接着通过 Odometry 将每帧的特征累积成局部地图，最后通过回环检测，全局优化出全局地图。Localization 阶段，提取出每帧的语义信息后，用 Odometry 初始化位姿，然后用 ICP 匹配求解当前帧在全局地图中的位姿，得到基于地图的位姿观测量，最后用 EKF 融合该观测量与 Odometry 信息，得到本车的最终位姿。<br>　　有了本车在全局地图下的位姿后，然后通过语义信息识别停车位，即可达到本车自动泊车的目的。</p><h2 id="mapping">2. Mapping</h2><h3 id="ipm">2.1. IPM</h3><p>　　传感器为车身四周四个鱼眼相机，相机内外参已知。IPM(Inverse Perspective Mapping) 是将图像中的像素点投影到车身物理坐标系下的俯视图中，具体的： <span class="math display">\[\frac{1}{\lambda}\;\begin{bmatrix}x ^ v \\y ^ v \\1\end{bmatrix} =[\mathbf{R} _ c \;\mathbf{t} _ c] ^ {-1} _ {col:1,2,4} \;\pi _ c ^ {-1}\begin{bmatrix}u \\v \\1\end{bmatrix}\tag{1}\]</span> 其中 \(\pi _ c(\cdot)\) 为鱼眼相机的内参矩阵，\([\mathbf{R} _ c\;\mathbf{t} _ c]\) 为每个相机到车身坐标系的外参矩阵，\([x ^ v\; y ^ v]\) 为车身坐标系下语义特征的位置。关于 IPM 更多细节可参考 <a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a>。<br>　　进一步将 IPM 图拼接成一张全景图： <span class="math display">\[\begin{bmatrix}u _ {ipm}\\v _ {ipm}\\1\end{bmatrix}=\mathbf{K} _ {ipm}\begin{bmatrix}x ^ v \\y ^ v \\1\end{bmatrix}\tag{2}\]</span> 其中 \(\mathbf{K} _ {ipm}\) 是全景图的内参。</p><h3 id="feature-detection">2.2. Feature Detection</h3><p><img src="/AVP-SLAM/segment.png" width="65%" height="65%" title="图 2. Segmentation in IPM Image"> 　　将每张 IPM 图拼接成一张大全景图，然后用基于深度学习的语义分割方法，对全景图作像素级别作 lane，parking line，guide sign，speed bump，free space，obstacle，wall 等类别的语义分割。如图 4. 所示，parking line，guide sign，speed bump 是稳定的特征，用于定位；parking line 用于车位的识别；free space 与 obstacle 用于路径规划。</p><h3 id="local-mapping">2.3. Local Mapping</h3><p>　　全景图语义分割得到的用于定位的特征(parking line，guide sign，speed bump)需要反投影回车身物理坐标系： <span class="math display">\[\begin{bmatrix}x ^ v \\y ^ v \\1\end{bmatrix}=\mathbf{K} _ {ipm} ^ {-1}\begin{bmatrix}u _ {ipm}\\v _ {ipm}\\1\end{bmatrix}\tag{3}\]</span> 然后基于 Odometry 的相对位姿，将当前的语义特征点转换到世界坐标系下： <span class="math display">\[\begin{bmatrix}x ^ w \\y ^ w \\z ^ w\end{bmatrix}=\mathbf{R _ o}\begin{bmatrix}x ^ v \\y ^ v \\0\end{bmatrix} + \mathbf{t _ o}\tag{4}\]</span> 由此得到局部地图，本文保持车身周边 30m 内的局部地图。</p><h3 id="loop-detection">2.4. Loop Detection</h3><p><img src="/AVP-SLAM/loop_det.png" width="65%" height="65%" title="图 3. Loop Detection"> 　　因为 Odometry 有累计误差，所以这里对局部地图作一个闭环检测。如图 3. 所示，通过 ICP 对两个局部地图作匹配，一旦匹配成功，就说明检测到了闭环，ICP 匹配的相对位姿用于之后的全局位子图优化，以消除里程计累计误差。</p><h3 id="global-optimization">2.5. Global Optimization</h3><p>　　检测到闭环后，需进行全局位姿图优化。位姿图中，节点(node)为每个局部地图的位姿：\((\mathbf{r, t})\)；边(edge)有两种：odometry 相对位姿以及闭环检测中 ICP 匹配位姿。由此位姿图优化的损失函数为： <span class="math display">\[\chi ^ * = \mathop{\arg\min}\limits _ \chi \sum _ t\Vert f(\mathbf{r} _ {t+1},\mathbf{t} _ {t+1}, \mathbf{r} _ t, \mathbf{t} _ t) - \mathbf{z} ^ o _ {t,t+1}\Vert ^ 2 + \sum _ {i,j\in\mathcal{L}}\Vert f(\mathbf{r} _ i,\mathbf{t} _ i,\mathbf{r} _ j, \mathbf{t} _ j)-\mathbf{z} ^ l _ {i,j}\Vert ^ 2 \tag{5}\]</span> 其中 \(\chi = [\mathbf{r} _ 0,\mathbf{t} _ 0,...,\mathbf{r} _ t,\mathbf{t} _ t] ^ T\) 是所有局部地图的位姿，也是待优化的参数。\(\mathbf{z} ^ 0 _ {t,t+1}\) 为 Odometry 得到的位姿。\(\mathbf{z} ^ l _ {i,j}\) 为闭环检测 ICP 得到的位姿。\(f(\cdot)\) 为计算两个局部地图相对位姿的方程。该优化问题可通过 Gauss-Newton 法求解。<br>　　用优化后的位姿将局部地图叠加起来，就获得了整个场景的全局地图。</p><h2 id="localization">3. Localization</h2><p><img src="/AVP-SLAM/loc.png" width="65%" height="65%" title="图 4. Localization"> 　　有了全局地图后，基于全局地图的定位观测量可通过当前帧与全局地图的匹配得到。如图 4. 所示，绿色为当前帧检测到的语义特征，与全局地图匹配后即可得到当前的绝对位置。匹配通过 ICP 算法实现： <span class="math display">\[ \mathbf{r ^ * ,t ^ * } =  \mathop{\arg\min}\limits _ {\mathbf{r,t}}\sum _ {k\in\mathcal{S}}\Vert\mathbf{R(r)}\begin{bmatrix}x ^ v  _ k\\y ^ v  _ k\\0\end{bmatrix} + \mathbf{t} - \begin{bmatrix}x ^ w _ k \\y ^ w _ k\\z ^ w _ k\end{bmatrix}\Vert ^ 2 \tag{6}\]</span> 其中 \(\mathcal{S}\) 为当前帧语义特征点集，\([x _ k ^ w\; y _ k ^ w\; z _ k ^ w]\) 分别为对应的全局地图中最近的特征点集。<br>　　ICP 的初始化非常重要，本文提出了两种初始化方法：1. 直接在地图上标记车库入口作为全局坐标点；2. 室外 GPS 信号初始化，然后用 Odometry 累积到车库。</p><h2 id="extended-kalman-filter">4. Extended Kalman Filter</h2><p>　　Visual Localization 在语义特征较少的情况下，比如车辆停满了，定位会不稳定，所以这里采用 EKF 对 Visual Localization 与 Odometry 中的轮速计和 IMU 作扩展卡尔曼融合，这里不做展开。</p><h2 id="thinkings">5. Thinkings</h2><p>　　Semantic SLAM 相比基于几何特征点的 SLAM 更加鲁棒。但是在车库场景下，一旦车子停满后，停车线等语义信息会急剧减少，所以实际商业应用中，AVP-SLAM 能满足室内自动泊车的需求吗？<br>　　对此我持怀疑态度。我认为，对于车库自动泊车的商业落地，可能最有效且低成本的方法还是得基于室内 UWB 定位技术。至少 UWB 可作为辅助。当然要将 UWB 应用于车载装置，目前好像还没有，不过随着车载软硬件系统的完善，手机上能做的事，车载平台问题也不大。</p><h2 id="reference">6. Reference</h2><p><a id="1" href="#1ref">[1]</a> Qin, Tong, et al. &quot;AVP-SLAM: Semantic Visual Mapping and Localization for Autonomous Vehicles in the Parking Lot.&quot; arXiv preprint arXiv:2007.01813 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Visual-SLAM 一般采用特征点或像素直接法来建图定位，这种方式对光照较为敏感。本文&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt; 提出了一种基于语义特征的 Visual Semantic SLAM，应用于光照条件较为复杂的室内
      
    
    </summary>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/categories/SLAM/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="SLAM" scheme="https://leijiezhang001.github.io/tags/SLAM/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;Point-GNN: Graph Neural Network for 3D Object Detection in a Point Cloud&quot;</title>
    <link href="https://leijiezhang001.github.io/paper-reading-Point-GNN/"/>
    <id>https://leijiezhang001.github.io/paper-reading-Point-GNN/</id>
    <published>2020-07-10T01:22:07.000Z</published>
    <updated>2020-07-14T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种基于图网络来提取点云特征的方法，理论上可在不损失原始信息的情况下，高效的学习点云特征，其在点云 3D 检测任务中效果提升明显。</p><h2 id="different-point-cloud-representations">1. Different Point Cloud Representations</h2><p><img src="/paper-reading-Point-GNN/repr.png" width="65%" height="65%" title="图 1. Point Cloud Representations"> 　　如图 1. 所示，目前点云表示方式以及对应的特征学习方式有三种：Grids，栅格化后类似图像 2D/3D 卷积的形式；Sets，以 PointNet 为代表的最近邻查找周围点并学习的形式；Graph，将无序点集转换为图模型，特征信息通过点云顶点传递学习的形式。Grids 及 Sets 形式我们已经比较熟悉了，Graph 则查询效率比 Sets 高，特征提取能力又比 Grids 高。Graph 的建图时间复杂度为 \(\mathcal{O}(cN)\)，领域查询复杂度则为 \(\mathcal{O}(1)\)，Sets 中的 KNN 建树及查询复杂度可见 <a href="/PointCloud-Feature-Extraction/" title="PointCloud Feature Extraction">PointCloud Feature Extraction</a>。当然 KNN 式的领域查询方式可以用近似 \(\mathcal{O}(1)\) 方法实现，但是会影响特征学习的准确度。</p><h2 id="framework">2. Framework</h2><p><img src="/paper-reading-Point-GNN/framework.png" width="95%" height="95%" title="图 2. Framework of Point-GNN"> 　　如图 2. 所示，基于 Graph 的 3D 点云检测，首先对点云作 Graph Construction，然后用 GNN 来学习每个顶点的特征，接着对每个顶点预测目标框，最后作目标框的整合和 NMS。</p><h3 id="graph-construction">2.1. Graph Construction</h3><p>　　设点云集：\(P=\{p _ 1,...,p _ N\}\)，其中 \(p _ i=(x _ i, s _ i)\) 分别表示坐标 \(x _ i\in\mathbb{R} ^ 3\)，以及该点反射率，领域点相对位置等信息 \(s _ i\in\mathbb{R} ^ k\)。对该点集建图 \(G=(P,E)\)，将距离小于一定阈值的两个点进行连接，即： <span class="math display">\[E = \{(p _ i, p _ j)|\Vert x _ i-x _ j\Vert _ 2 &lt; r\} \tag{1}\]</span> 这种建图方式是 Fixed Radius Near-Neighbors 问题，可在 \(\mathcal{O}(cN)\) 时间复杂度下解决，其中 \(c\) 为最大连接数。<br>　　建图完成后，要对每个点信息状态 \(s _ i\) 作初始化。这里采用类似 Sets 的特征提取方式，即将该点的反射率，以及与领域内点的相对位置，串联成特征向量，然后用 MLP 作空间变换，最后在点维度上作 Max Pooling，即可得到初始化的该点特征状态量 \(s _ i\)。</p><h3 id="graph-neural-network-with-auto-registration">2.2. Graph Neural Network with Auto-Registration</h3><p>　　传统的图神经网络，通过边迭代每个顶点的特征。在 \((t+1) ^ {th}\) 迭代时： <span class="math display">\[\begin{align} v _ i ^ {t+1} &amp;= g ^ t\left(\rho\left(\{e _ {ij} ^ t|(i,j)\in E\}\right), v _ i ^ t\right) \\e _ {ij} ^ t &amp;= f ^ t(v _ i ^ t, v _ j ^ t) \tag{2}\end{align}\]</span> 其中 \(e ^ t,v ^ t\) 分别是边和顶点特征，\(f ^ t(\cdot)\) 计算两个顶点之间边的特征，\(\rho(\cdot)\) 将与该点连接的边特征整合，得到该点特征增量，\(g ^ t(\cdot)\) 将该点特征增量与原特征进行整合得到本次迭代后该点的最终特征。<br>　　对于边特征，一种设计方式为，描述领域特征对该点位置的作用力，重写式 (2)： <span class="math display">\[s _ i ^ {t+1} = g ^ t\left(\rho\left(\{f ^ t(x _ j-x _ i,s _ j^t)|(i,j)\in E\}\right), s _ i ^ t\right) \tag{3}\]</span> 这样就得到了图神经网络的迭代模型。此外，本文还指出，由于边特征对领域点的距离较为敏感，所以作者提出对相对位置作自动补偿，实验表明其实意义不大： <span class="math display">\[\begin{align}\Delta x _ i ^ t &amp;= h ^ t(s _ i^t) \\s _ i ^ {t+1} &amp;= g ^ t\left(\rho\left(\{f ^ t(x _ j-x _ i+\Delta x _ i ^ t,s _ j^t)|(i,j)\in E\}\right), s _ i ^ t\right) \tag{4}\end{align}\]</span> 　　具体的，\(f ^ t(\cdot),g ^ t(\cdot), h ^ t(\cdot)\) 可用 MLP 来建模，\(\rho(\cdot)\) 则采用 Max 操作： <span class="math display">\[\begin{align}\Delta x _ i ^ t &amp;= MLP _ h ^ t(s _ i^t) \\e _ {ij} ^ t &amp;= MLP _ f ^ t([x _ j - x _ i + \Delta x _ i ^ t, s _ j ^ t]) \\s _ i ^ {t+1} &amp;= MLP _ g ^ t\left(MAX(\{e _ {ij}|(i,j)\in E\})\right)+ s _ i ^ t \tag{5}\end{align}\]</span></p><h3 id="loss">2.3. Loss</h3><p>　　为了作 3D 检测的任务，网络头输出为每个顶点的类别，目标框中心的 offset，以及目标框的尺寸，朝向。这与传统的基于 Ancho-Free 的 3D 目标检测基本一致，这里不做展开。</p><h3 id="box-merging-and-scoring">2.4. Box Merging and Scoring</h3><p>　　本方法的 3D 检测需要作 NMS 后处理，由于分类的 Score 不能反应目标框的 Uncertainty，所以基于 Score 的 NMS 是不合理的。这个问题在 2D 检测中也有比较多的研究，比如采用预测 IoU 值的方式来作权重。本文则认为遮挡信息能作为 NMS 操作的指导，由此定义了遮挡值的计算方式。但是实验显示，其实提升并不明显，所以这里不做具体展开。</p><h2 id="reference">3. Reference</h2><p><a id="1" href="#1ref">[1]</a> Shi, Weijing, and Raj Rajkumar. &quot;Point-gnn: Graph neural network for 3d object detection in a point cloud.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　本文&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;提出了一种基于图网络来提取点云特征的方法，理论上可在不损失原始信息的情况下，高效的学习点云特征，其在点云 3D 检测任务中效果提升明显。&lt;/p&gt;
&lt;h2 id=&quot;different-p
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>CenterTrack</title>
    <link href="https://leijiezhang001.github.io/CenterTrack/"/>
    <id>https://leijiezhang001.github.io/CenterTrack/</id>
    <published>2020-07-02T01:16:36.000Z</published>
    <updated>2020-07-08T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　障碍物感知由目标检测，目标跟踪(MOT)，目标状态估计等三个模块构成。目标状态估计一般是指将位置，速度等观测量作卡尔曼滤波平滑；广义的目标跟踪也包含了状态估计过程，这里采用狭义的目标跟踪定义方式，主要指出目标 ID 的过程。传统的做法，目标检测与目标跟踪是分开进行的，检测模块分别对前后帧作目标检测，目标跟踪模块则接收前后帧检测结果，然后用 Motion Model 将上一帧的检测结果预测到这一帧，最后与这一帧的检测结果作数据关联(Data Association)出目标 ID。这里的 Motion Model 可以是 3D 下目标的物理运动模型，也可以是图像下的单目标跟踪结果，如 KCF 算法。详细介绍可参考 <a href="/MOT-综述-Multiple-Object-Tracking-A-Literature-Review/" title="Multiple Object Tracking: A Literature Review">Multiple Object Tracking: A Literature Review</a>。<br>　　随着检测技术的发展，检测与跟踪的整合成为了趋势。<a href="#1" id="1ref">[1]</a> 是较早将跟踪的 “Motion Model” 用 Anchor-based Two-stage 网络来预测的方法，其网络输入为前后帧图像，其中一个分支输出当前帧的检测框，另一个分支用上一帧的检测结果作为 proposal，输出这一帧的跟踪框，最后用传统的数据关联方法得到目标的 ID。随着检测技术往 Anchor-Free One-stage 方向发展，在此基础上整合目标检测与跟踪也就顺理成章。<br>　　<a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a> 中详细描述了 Anchor-Free 的目标检测方法，相比于 Anchor-Based 的目标检测，其有很多优势，这里不做赘述。本文基于 CenterNet<a href="#2" id="2ref"><sup>[2]</sup></a>，总结了 CenterTrack<a href="#3" id="3ref"><sup>[3]</sup></a>，以及 CenterPoint(3D CenterTrack)<a href="#4" id="4ref"><sup>[4]</sup></a>方法。</p><h2 id="centernet">1. CenterNet</h2><p>　　CenterNet 在 <a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a> 中已经较为详细得阐述了。需要补充的是，中心点的正负样本设计为：正样本只有中心点像素，负样本则为其它区域，并加入以中心点为中心的高斯权重，越靠近中心点，负样本权重越小。其 Loss 基于 Focal Loss，数学描述为： <span class="math display">\[L _ k = \frac{1}{N}\sum _ {xyc}\left\{\begin{array}{l}(1-\hat{Y} _ {xyc})^{\alpha}\mathrm{log}(\hat{Y} _ {xyc}) &amp; \mathrm{if}\; Y _ {xyc} = 1\\(1- Y _ {xyc})^{\beta}(\hat{Y} _ {xyc})^{\alpha}\mathrm{log}(1-\hat{Y} _ {xyc}) &amp; \mathrm{otherwise}\end{array}\tag{1}\right.\]</span> 其中 \(Y _ {xyc}\) 为高斯权重后的正负样本分布值。<br>　　具体的，设图像 \(I\in \mathbb{R}^{W\times H\times 3}\)，CenterNet 输出的每个类别 \(c\in\{0,...,C-1\}\) 的目标为 \(\{(\mathbf{p} _ i, \mathbf{s} _ i)\} _ {i=0} ^ {N-1}\)。其中 \(\mathbf{p}\in \mathbb{R} ^ 2\)，\(\mathbf{s}\in\mathbb{R} ^ 2\) 为目标框的尺寸。对应的，最终输出的 heatmap 位置和尺寸图为：\(\hat{Y}\in [0,1]^{\frac{W}{R}\times\frac{H}{R}\times C}\)，\(\hat{S}\in\mathbb{R}^{\frac{W}{R}\times\frac{H}{R}\times 2}\)。对 \(\hat{Y}\) 作 \(3\times 3\) 的 max pooling，即可获得目标中心点，\(\hat{S}\) 上对应的的点即为该目标的尺寸。此外还用额外的 heatmap 作位置 offset 的回归，因为 \(\hat{Y}\) 存在量化误差。最终由中心点位置 loss，位置 offset loss，尺寸 loss 三部分组成。</p><h2 id="centertrack">2. CenterTrack</h2><h3 id="framework">2.1. Framework</h3><p><img src="/CenterTrack/centertrack.png" width="85%" height="85%" title="图 1. CenterTrack"> 　　如图 1. 所示，CenterTrack 基于 CenterNet，框架也较为简单：输入前后帧图像，以及上一帧跟踪到的目标中心点所渲染的 heatmap，经过网络后输出为当前帧的检测 heatmap，size map，以及这一帧相对上一帧跟踪的 offset map。最后通过最近距离匹配即可作数据关联获得目标的 ID。算法得到的目标属性有 \(b = (\mathbf{p,s},w,id)\)，分别为目标的 location，size，confidence，identity。<br>　　相比于 CenterNet，CenterTrack 还预测了这一帧相对上一帧，目标的 2D displacement：\(\hat{D}\in\mathbb{R}^{\frac{W}{R}\times\frac{H}{R}\times 2}\)。这相当于 Tracking 中 Motion Model 的结果，分别计算上一帧目标经过该 displacement 变换到这一帧后的目标位置与当前帧检测的目标位置的距离误差，用最小距离的贪心法即可将目标作数据关联，得到目标的 ID。</p><h3 id="experiments">2.2. Experiments</h3><p>　　网络结构相比于 CenterNet 只是增加了输入的四个通道特征，输出的两个通道特征。网络可在视频流图像或者单帧图像上训练，对于单帧图像，可对图像中的目标作伸缩平移变换来模拟目标运动，实验表明，也非常有效。 <img src="/CenterTrack/motion_models2d.png" width="85%" height="85%" title="图 2. Motion Models"> 　　如图 2. 所示，本文比较了 displacement 与 kalman filter，optical flow 等 Motion Model，显示本文效果是最好的，我猜测是因为 displacement 回归的直接是物体级别的像素运动，抗噪性更强。</p><h2 id="center-based-3d-object-detection-and-tracking">3. Center-based 3D Object Detection and Tracking</h2><h3 id="framework-1">3.1. Framework</h3><p><img src="/CenterTrack/centertrack3d.png" width="85%" height="85%" title="图 3. 3D CenterTrack"> 　　如图 3. 所示，CenterPoint 将点云在俯视图下栅格化，然后采用 CenterTrack 一样的网络结构，只是输出为目标的 3D location，size，orientation，velocity。<br>　　点云俯视图下的栅格化，如果对栅格不做点云的精细化估计，那么会影响到目标位置及速度估计的精度，所以理论上 PointPillars 这种栅格点云特征学习方式能更有效的提取点云的信息，保留特征的连续化信息(但是论文的实验表明 VoxelNet 比 PointPillars 效果更好)。否则，虽然目标位置等信息的监督项是连续量，但是栅格化的特征是离散量，这会降低预测精度。<br>　　具体的，网络输出为：\(K\) 个类别的 \(K\)-channel heatmap 表示目标中心点，目标的尺寸 \(\mathbf{s}=(w,l,h)\) heatmap，目标的中心点 offset \(\mathbf{o}=(o _ x,o _ y,o _ z)\) heatmap，朝向角 \(\mathbf{e} = (\mathrm{sin}(\alpha),\mathrm{cos}(\alpha))\) heatmap，目标速度 \(\mathbf{v}=(v _ x,v _ y)\) heatmap。与 CenterTrack 非常相似，只不过这里的速度就是真实的物理速度。</p><h3 id="experiments-1">3.2. Experiments</h3><p><img src="/CenterTrack/detmap.png" width="85%" height="85%" title="图 4. 3D Detection Benchmark"> 　　如图 4. 所示，引入 Velocity 预测，能有效提升检测的性能，这应该是网络输入前一帧信息的结果，对半遮挡情况能有较好效果。 <img src="/CenterTrack/experiment3d.png" width="85%" height="85%" title="图 5. 3D MOT Benchmark"> 　　如图 5. 所示，跟踪性能也是有很大提升，而且数据关联等后处理相对比较简单。</p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> Feichtenhofer, Christoph, Axel Pinz, and Andrew Zisserman. &quot;Detect to track and track to detect.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2017.<br><a id="2" href="#2ref">[2]</a> Zhou, Xingyi, Dequan Wang, and Philipp Krähenbühl. &quot;Objects as points.&quot; arXiv preprint arXiv:1904.07850 (2019).<br><a id="3" href="#3ref">[3]</a> Zhou, Xingyi, Vladlen Koltun, and Philipp Krähenbühl. &quot;Tracking Objects as Points.&quot; arXiv preprint arXiv:2004.01177 (2020).<br><a id="4" href="#4ref">[4]</a> Yin, Tianwei, Xingyi Zhou, and Philipp Krähenbühl. &quot;Center-based 3D Object Detection and Tracking.&quot; arXiv preprint arXiv:2006.11275 (2020).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　障碍物感知由目标检测，目标跟踪(MOT)，目标状态估计等三个模块构成。目标状态估计一般是指将位置，速度等观测量作卡尔曼滤波平滑；广义的目标跟踪也包含了状态估计过程，这里采用狭义的目标跟踪定义方式，主要指出目标 ID 的过程。传统的做法，目标检测与目标跟踪是分开进行的，检
      
    
    </summary>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/categories/MOT/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
      <category term="Tracking" scheme="https://leijiezhang001.github.io/tags/Tracking/"/>
    
      <category term="MOT" scheme="https://leijiezhang001.github.io/tags/MOT/"/>
    
  </entry>
  
  <entry>
    <title>Rethinking of Sparse 3D Convolution</title>
    <link href="https://leijiezhang001.github.io/Rethinking-of-Sparse-3D-Convolution/"/>
    <id>https://leijiezhang001.github.io/Rethinking-of-Sparse-3D-Convolution/</id>
    <published>2020-06-23T09:37:12.000Z</published>
    <updated>2020-06-25T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　Sparse 3D Convolution 最早在<a href="#1" id="1ref">[1]</a>中提出，然后该作者又提出了 Submanifold Sparse Convolution<a href="#2" id="2ref"><sup>[2]</sup></a>，并将其应用于 3D 语义分割中<a href="#3" id="3ref"><sup>[3]</sup></a>。<a href="#4" id="4ref">[4]</a>则改进了 Sparse 3D Convolution 的实现方式，并应用于 3D 目标检测中。之前一直没仔细看 Sparse 3D Convolution 原理，以为只是基于稀疏矩阵的矩阵相乘加速，最近的一些实验发现 Sparse 3D Convolution 在点云相关的任务中不仅仅是加速，还能提升网络特征提取的性能，所以回过头来重新思考 Sparse 3D Convolution 原理及作用。</p><h2 id="sparse-convolution">1. Sparse Convolution</h2><p><img src="/Rethinking-of-Sparse-3D-Convolution/spconv.png" width="85%" height="85%" title="图 1. sparse VS. submanifold sparse"> 　　如图 1. 左图所示，对于稀疏的特征输入，传统的 Sparse Convolution 与 Convolution 一致，只是对于卷积核覆盖的输入特征为零的区域不做计算，直接置为零。这种方式下，随着卷积层的增加，特征层会变得不那么稀疏，这样不仅使得计算量上升，而且会使得提取的信息变得不那么准确。</p><h2 id="submanifold-sparse-convolution">2. Submanifold Sparse Convolution</h2><p>　　如图 1. 右图所示，Submanifold Sparse Convolution 解决了 Sparse Convolution 存在的问题。原理也很直观：只计算输出特征层映射到输入特征层不为零的位置区域。这种方式下，随着卷积层的增加，不仅能保持稀疏性，而且能保证原始信息的准确性。 <img src="/Rethinking-of-Sparse-3D-Convolution/flops.png" width="85%" height="85%" title="图 2. Flops"> 　　如图 2. 所示，Sparse Convolution 相比传统的 Convolution 已经能减少较多的计算量，而 Submanifold Sparse Convolution 则能减少更多的计算量。特征输入越稀疏，减少的计算量就越多，这对点云的三维特征提取，或者是俯视图下的二维特征提取有很大的帮助。</p><h2 id="implementation">3. Implementation</h2><p><img src="/Rethinking-of-Sparse-3D-Convolution/speed.png" width="85%" height="85%" title="图 3. Speed"> 　　<a href="#2" id="2ref">[2]</a> 中实现了 Submanifold Sparse Convolution，其中的卷积运算是手写的矩阵相乘，所以速度较慢；<a href="#4" id="4ref">[4]</a> 则基于 GEMM 实现了更高效的 Submanifold Sparse Convolution。如图 3. 所示，其有将近一倍的速度提升。 <img src="/Rethinking-of-Sparse-3D-Convolution/imple.png" width="90%" height="90%" title="图 4. Implementation"> 　　图 4. 描述了<a href="#4" id="4ref">[4]</a>实现的 Submanifold Sparse Convolution 原理。其首先通过 gather 操作将非零的元素进行矩阵相乘，然后通过 scatter 操作将结果映射回原位置。为了加速，前后元素的映射矩阵计算比较关键，这里实现了一种 GPU 计算方法，这里不做展开。</p><h2 id="application">4. Application</h2><p><img src="/Rethinking-of-Sparse-3D-Convolution/second.png" width="90%" height="90%" title="图 5. SECOND Framework"> 　　Submanifold Sparse Convolution 可应用于点云的分类，分割，检测等任务的特征提取中，SECOND<a href="#4" id="4ref"><sup>[4]</sup></a>是一种点云检测方法，如图 5. 所示，其检测框架与传统的一致，只是将体素化后的点云特征信息，进一步用 Sparse Convolution 来作特征提取。该方法不仅速度较快，而且性能也有不少提升。所以 Submanifold Sparse Convolution 是非常高效的，可作为点云特征提取的基本操作。但是传统的 Convolution，在 GPU 平台下，已经有较多的硬件级优化(cudnn)，在 CPU 平台下也有很多的指令集优化，所以最终在特定硬件下作 Inference 时，到底 Submanifold Sparse Convolution 速度能提升多少，还得看 Submanifold Sparse Convolution 实现的好不好。不过可以猜测，在目前的实现下，Submanifold Sparse Convolution 在 GPU 平台下应该能有不少的速度提升。<br>　　此外，传统的卷积量化操作也比较成熟，cudnn 已经有基本的操作引擎，而 Submanifold Sparse Convolution 的 INT8 引擎则目前还没有。所以 float32/float16 的 Submanifold Sparse Convolution 与 INT8 的 Convolution，孰快孰慢？这两条路大概就是部署的思路了，当然 INT8 的 Submanifold Sparse Convolution 会更好，但是开发成本会比较高。</p><h2 id="reference">5. Reference</h2><p><a id="1" href="#1ref">[1]</a> Graham, Ben. &quot;Sparse 3D convolutional neural networks.&quot; arXiv preprint arXiv:1505.02890 (2015).<br><a id="2" href="#2ref">[2]</a> Graham, Benjamin, and Laurens van der Maaten. &quot;Submanifold sparse convolutional networks.&quot; arXiv preprint arXiv:1706.01307 (2017).<br><a id="3" href="#3ref">[3]</a> Graham, Benjamin, Martin Engelcke, and Laurens Van Der Maaten. &quot;3d semantic segmentation with submanifold sparse convolutional networks.&quot; Proceedings of the IEEE conference on computer vision and pattern recognition. 2018.<br><a id="4" href="#4ref">[4]</a> Yan, Yan, Yuxing Mao, and Bo Li. &quot;Second: Sparsely embedded convolutional detection.&quot; Sensors 18.10 (2018): 3337.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Sparse 3D Convolution 最早在&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;[1]&lt;/a&gt;中提出，然后该作者又提出了 Submanifold Sparse Convolution&lt;a href=&quot;#2&quot; id=&quot;2ref&quot;&gt;&lt;sup&gt;[2]&lt;/sup
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;End-to-End Pseudo-LiDAR for Image-Based 3D Object Detection&quot;</title>
    <link href="https://leijiezhang001.github.io/End-to-End-Pseudo-LiDAR-for-3D-Det/"/>
    <id>https://leijiezhang001.github.io/End-to-End-Pseudo-LiDAR-for-3D-Det/</id>
    <published>2020-06-22T01:19:12.000Z</published>
    <updated>2020-06-25T01:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　基于视觉的 3D 目标检测方法因为成本较低，所以在 ADAS 领域应用非常广泛。其基本思路有以下几种：</p><ul><li>单目\(\rightarrow\)3D 框，代表文章有<a href="#1" id="1ref">[1]</a>。</li><li>单目\(\rightarrow\)深度图\(\rightarrow\)3D 框</li><li>双目\(\rightarrow\)3D 框，代表文章有<a href="#2" id="2ref">[2]</a>。</li><li>双目\(\rightarrow\)深度图\(\rightarrow\)3D 框</li></ul><p>由单目或双目直接回归 3D 目标框的属性，这种方法优势是 latency 小，缺点则是，没有显式的预测深度图，导致目标 3D 位置回归较为困难。而在深度图基础上回归 3D 目标位置则相对容易些，这种方法由两个模块构成：深度图预测，3D 目标预测。得到深度图后，可以在前视图下将深度图直接 concate 到 rgb 图上来做，另一种方法是将深度图转换为 pseudo-LiDAR 点云，然后用基于点云的 3D 目标检测方法来做，目前学术界基本有结论：pseudo-LiDAR 效果更好。<br>　　本文<a href="#3" id="3ref"><sup>[3]</sup></a>即采用双目出深度图，然后基于 pseudo-LiDAR 来作 3D 目标检测的方案，并且解决了两个模块需要两个网络来优化的大 lantency 问题，实现了 End-to-End 联合优化的方式。</p><h2 id="framework">1. Framework</h2><p><img src="/End-to-End-Pseudo-LiDAR-for-3D-Det/framework.png" width="60%" height="60%" title="图 1. Framework"> 　　基于点云作 3D 目标检测大致可分为 point-based 与 voxel-based 两大类，详见 <a href="/Point-based-3D-Det/" title="Point-based 3D Detection">Point-based 3D Detection</a>，传统的基于双目的 pseudo-LiDAR 方案无法 End-to-End 作俯视图下 voxel-based 3D 检测，因为点云信息需要作俯视图离散化，离散的过程是无法作反向传播训练的，本文提出了 Change of Representation(CoR) 模块有效解决了这个问题。如图 1. 所示，本方案中 Depth Estimation 可由任何深度估计网络实现，然后经过 CoR 模块，将深度图变换成点云形式用于 point-based 3D detection，或者是 Voxel 形式用于 voxel-based 3D detection。这里的关键是可求导的 CoR 模块设计。</p><h2 id="cor">2. CoR</h2><h3 id="quantization">2.1. Quantization</h3><p>　　点云检测模块如果采用 voxel-based 方案，那么点云到俯视图栅格的离散化(quantization)是必不可少的。假设点云 \(P = \{p _ 1,...,p _ N\}\)，待生成的 3D 占据栅格(最简单的特征形式) \(T\) 包含 \(M\) 个 bins，即 \(m\in\{1,...,M\}\)，每个 bin 的中心点设为 \(\hat{p} _ m\)。那么生成的 \(T\) 可表示为： <span class="math display">\[ T(m) = \left\{\begin{array}{l}1, &amp; \mathrm{if}\;\exists p\in P \; \mathrm{s.t.}\; m = \mathop{\arg\min}\limits _ {m &#39;}\Vert p - \hat{p} _ {m&#39;}\Vert _ 2 \\0, &amp; \mathrm{otherwise}.\end{array}\tag{1}\right.\]</span> 即如果有点落在该 bin 里，那么该 bin 对应的值置为 1。这种离散方式是无法求导的。<br>　　本文提出了一种可导的软量化模块(soft quantization module)，即用 RBF 作权重计数，另一种角度来看，<strong>这其实类似于点的空间概率密度表示</strong>。设 \(P _ m\) 为落在 bin \(m\) 的点集： <span class="math display">\[ P _ m=\left\{p\in |, \mathrm{s.t.}\; m=\mathop{\arg\min}\limits _ {m &#39;}\Vert p - \hat{p} _ {m&#39;}\Vert _ 2\right\} \tag{2}\]</span> 那么，\(m'\) 作用于 \(m\) 的值为： <span class="math display">\[ T(m, m&#39;) = \left\{\begin{array}{l}0 &amp; \mathrm{if}\; \vert P _ {m&#39;}\vert = 0;\\\frac{1}{\vert P _ {m&#39;}\vert} \sum _ {p\in P _ {m&#39;}} e^{-\frac{\Vert p-\hat{p} _ m\Vert ^2}{\sigma ^ 2}} &amp; \mathrm{if}\; \vert P _ {m&#39;}\vert &gt; 0.\end{array}\tag{3}\right.\]</span> 最终的 bin 值为： <span class="math display">\[ T(m) = T(m,m)+\frac{1}{\vert \mathcal{N} _ m\vert}\sum _ {m&#39;\in\mathcal{N} _ m}T(m,m&#39;) \tag{4}\]</span> 当 \(\sigma ^2\gg 0\) 以及 \(\mathcal{N} _ m=\varnothing\) 时，回退到式 (1) 的离散化方式。本文实验中采用 \(\sigma ^2 = 0.01\)，\(\mathcal{N} _ m=3\times 3\times 3 -1 = 26\)。传统的点云栅格概率密度计算方式为：将点云中的每个点高斯化，然后统计每个栅格中心坐标上覆盖到的值。与上述方法的高斯原点不一样，但是计算结果是一致的。 <img src="/End-to-End-Pseudo-LiDAR-for-3D-Det/quantization.png" width="90%" height="90%" title="图 2. Quantization"> 　　这种方法可将导数反向传播到 \(m'\) 中的每个点：\(\frac{\partial\mathcal{L} _ {det}}{\partial T(m)}\times\frac{\partial T(m)}{\partial T(m,m')}\times\bigtriangledown _ pT(m,m')\)。如图 2. 所示，蓝色 voxel 表示梯度为正，即 \(\frac{\partial\mathcal{L} _ {det}}{\partial T(m)} &gt; 0\)，红色 voxel 表示梯度为负。那么蓝色 voxel 期望没有点，所以将点往外推，红色 voxel 则将点往里拉，最终使点云与 LiDAR 点云，即 GT 点云一致。</p><h3 id="subsampling">2.1. Subsampling</h3><p>　　点云检测模块如果采用 point-based 方案，那么就比较容易直接与深度图网络进行 End-to-End 整合。point-based 3D Detection 一般通过 sampling 来扩大感受野，提取局部信息，因为这种方法的计算量对点数比较敏感，所以 sampling 也是降低计算量的有效手段。一个 \(640\times 480\) 的深度图所包含的点云超过 30 万，远远超过一个 64 线的激光雷达，所以对其进行采样就非常关键。<br>　　本文对深度图点云进行模拟雷达式的采样，即定义球坐标系下栅格化参数：\((r,\theta,\phi)\)。其中 \(\theta\) 为水平分辨率，\(\phi\) 为垂直分辨率。对每个栅格内采样一个点，即可得到一个较为稀疏，且接近激光雷达扫描属性的点云。</p><h2 id="loss">3. Loss</h2><p>　　Loss 由 depth 估计与 3D Detection 两项构成： <span class="math display">\[\mathcal{L} = \lambda _ {det}\mathcal{L} _ {det} + \lambda _ {depth}\mathcal{L} _ {depth} \tag{5}\]</span></p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Mousavian, Arsalan, et al. &quot;3d bounding box estimation using deep learning and geometry.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017.<br><a id="2" href="#2ref">[2]</a> Li, Peiliang, Xiaozhi Chen, and Shaojie Shen. &quot;Stereo r-cnn based 3d object detection for autonomous driving.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br><a id="3" href="#3ref">[3]</a> Qian, Rui, et al. &quot;End-to-End Pseudo-LiDAR for Image-Based 3D Object Detection.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　基于视觉的 3D 目标检测方法因为成本较低，所以在 ADAS 领域应用非常广泛。其基本思路有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单目\(\rightarrow\)3D 框，代表文章有&lt;a href=&quot;#1&quot; id=&quot;1ref&quot;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;单目
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="Point Cloud" scheme="https://leijiezhang001.github.io/tags/Point-Cloud/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
  <entry>
    <title>[paper_reading]-&quot;PointPainting: Sequential Fusion for 3D Object Detection&quot;</title>
    <link href="https://leijiezhang001.github.io/PointPainting/"/>
    <id>https://leijiezhang001.github.io/PointPainting/</id>
    <published>2020-06-17T03:27:38.000Z</published>
    <updated>2020-06-22T09:00:45.632Z</updated>
    
    <content type="html"><![CDATA[<p>　　相机能很好的捕捉场景的语义信息，激光雷达则能很好的捕捉场景的三维信息，所以图像与点云的融合，对检测，分割等任务有非常大的帮助。融合可分为，<strong>数据级或特征级的前融合</strong>，以及<strong>任务级的后融合</strong>。本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种将图像分割结果的语义信息映射到点云，进而作 3D 检测的方法。这种串行方式的融合，既有点前融合的意思，也有点后融合的意思，暂且可归为前融合吧。本方法可认为是个框架，该框架下，基于图像的语义分割，以及基于点云的 3D 检测，均为独立模块。实验表明，融合了图像的语义信息后，点云针对行人等小目标的检测有较大的性能提升。</p><h2 id="framework">1. Framework</h2><p><img src="/PointPainting/framework.png" width="100%" height="100%" title="图 1. Framework"> 　　如图 1. 所示，算法框架非常简单，一句话能说明白：1). 首先经过图像语义分割获得语义图；2). 然后将点云投影到图像上，查询点云的语义信息，并连接到坐标信息中；3). 最后用点云 3D 检测的方法作 3D 检测。</p><h2 id="experiments">2. Experiments</h2><p><img src="/PointPainting/sota.png" width="90%" height="90%" title="图 2. PointPainting Applied to SOTA"> 　　采用 DeepLabv3+ 作为语义分割模块，应用到不同的点云 3D 检测后，结果如图 2. 所示，均有不同程度的提升，尤其是行人这种小目标。 <img src="/PointPainting/pointrcnn.png" width="90%" height="90%" title="图 3. Painted PointRCNN"> 　　图 3. 显示了 Painted PointRCNN 与各个方法的对比结果，mAP 是最高的。 <img src="/PointPainting/per-class.png" width="90%" height="90%" title="图 4. 不同类别的提升程度"> 　　由图 4. 可知，对行人，自行车，雪糕筒等小目标(俯视图下来说)，本方法提升非常显著。这也比较好理解，因为前视图下，这些目标所占的像素会比较多，所以更容易在前视相机图像下提取有效信息，辅助俯视图下作更准确的检测。</p><h2 id="rethinking-of-early-fusion">3. Rethinking of Early Fusion</h2><p>　　这里将本方法归为前融合，但是并不是真正意义上的前融合。如果是前融合，那么一般是 concate 语义分割网络的中低层特征到点云信息中，然而本文是直接取语义分割网络的最高层特征(即分类结果)。<strong>所以问题来了，所谓的前融合，一定比后融合更好吗？</strong>我想，这篇文章可能给了一些答案(不知道作者有没有做过取其它特征的实验，姑且认为做过，然后选择了本方法的策略)，虽然理论上前融合信息最完整，但是，如果这种完整的信息无法有效学出来或者对标定外参比较敏感，那么这种前融合也提升不了后续任务的性能，更有甚者，由于信息空间的变大或紊乱，导致后续任务性能下降。相反，对于不是那么“前”的后融合，我们能极大得保证各个任务学习结果的有效性，基于此，融合后学习的有效性也会比较确定。</p><h2 id="reference">4. Reference</h2><p><a id="1" href="#1ref">[1]</a> Vora, Sourabh, et al. &quot;Pointpainting: Sequential fusion for 3d object detection.&quot; Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　相机能很好的捕捉场景的语义信息，激光雷达则能很好的捕捉场景的三维信息，所以图像与点云的融合，对检测，分割等任务有非常大的帮助。融合可分为，&lt;strong&gt;数据级或特征级的前融合&lt;/strong&gt;，以及&lt;strong&gt;任务级的后融合&lt;/strong&gt;。本文&lt;a href=
      
    
    </summary>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/categories/3D-Detection/"/>
    
    
      <category term="Deep Learning" scheme="https://leijiezhang001.github.io/tags/Deep-Learning/"/>
    
      <category term="3D Detection" scheme="https://leijiezhang001.github.io/tags/3D-Detection/"/>
    
      <category term="paper reading" scheme="https://leijiezhang001.github.io/tags/paper-reading/"/>
    
      <category term="Autonomous Driving" scheme="https://leijiezhang001.github.io/tags/Autonomous-Driving/"/>
    
  </entry>
  
</feed>
