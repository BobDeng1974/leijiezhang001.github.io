<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[paper_reading]-"FlowNet3D"]]></title>
    <url>%2Fpaperreading-FlowNet3D%2F</url>
    <content type="text"><![CDATA[本来以为这篇文章是 FlowNet[1]，FlowNet2.0[2] 的续作，其实不是，大概只是借鉴了其网络框架。从网络细节上来说，应该算是 PointNet[3]，PointNet++[4] 系列的续作，本文[5]二作也是 PointNet 系列的作者。 光流(Optical Flow)是指图像坐标系下像素点的运动(详细可见 KLT)，而 Scene Flow 是三维坐标下，物理点的运动。Scene Flow 是较底层的一种信息，可进一步提取高层的语义信息，如运动分割等。 1. 背景 1.1. FlowNet 系列 如图 1. 与 2. 所示，FlowNet 在特征提取编码阶段提出了两种网络结构：FlowNetSimple 以及 FlowNetCorr。FlowNetSimple 是将前后帧图像按通道维拼接作为输入，FlowNetCorr 则设计了互相关层，描述前后帧特征的相关性，从而得到像素级偏置。refinement 解码阶段则采用 FPN 形式进行上采样，这样每一层反卷积层在细化时，不仅可以获得深层的抽象信息，同时还能获得浅层的具体信息。 FlowNet 虽然验证了用深度学习预测光流的可行性，但是性能比不上传统方法。FlowNet2.0 在此基础上进行了三大改进： 增加训练数据，改进训练策略； 在数据足够的情况下，证明了 FlowNetCorr 比 FlowNetSimple 较好。 利用堆叠结构使性能得到多级提升； 如图 3. 所示，采用 FlowNet2-CSS 形式堆叠一个 FlowNetCorr 以及两个 FlowNetSimple 模块，FlowNetSimple 的输入为前一模块预测的光流，原图像经过光流变换后的图像，以及与另一图像的误差，这样可以使得该模块专注去学习前序模块未预测准确的误差项。训练时，由前往后单独训练每个模块。 针对小位移的情况引入特定的子网络进行处理； 如图 3. 所示，FlowNet2-SD 网络卷积核均改为 3x3 形式，以增加对小位移的分辨率。最后再利用一个小网络将 FlowNet2-CSS 与 FlowNet2-SD 的结果进行融合。 1.2. PointNet 系列 这部分详见 PointNet-系列论文详读。 这里介绍下 PointNet++ 中点云采样的过程。点云采样有集中形式： 格点采样 空间栅格化，然后按照栅格进行点云采样； 随机采样 几何采样 根据点云所在平面的曲率，将点云分成不同集合，在每一集合里面进行均匀采样，获得曲率大的地方采样点多的效果，即获得更多“细节”； 均匀采样 PointNet++ 中采用的 Farthest Point Sample 属于均匀采样，其可以采样出特定个数的点，且比较均匀。大致过程为： 点云总集合为 \(\mathcal{C}\)，随机取一点，形成采样目标集合 \(\mathcal{S}\)； 在剩余点集 \(\mathcal{C}-\mathcal{S}\) 中取与集合 \(\mathcal{S}\) 距离最远的一点，加入目标集合 \(\mathcal{S}\)； 如果目标集合 \(\mathcal{S}\) 个数达到预定值，则终止，否则重复步骤 2.； 2. FlowNet3D 网络结构 如图 4. 所示，FlowNet3D 整体思路与 FlowNetCorr 非常像，其 set conv，flow embedding，set upconv 三个层相当于 FlowNetCorr 中的 conv，correlation，upconv 层。网络结构的连接方式也比较相像，上采样的过程都有接入前面浅层的具体特征。下面重点分析下这三个层的细节。 假设两个连续帧的两堆点：\(\mathcal{P} = \{x_i\vert i = 1,...,n_1\}\) 以及 \(\mathcal{Q} = \{y_j\vert j = 1,...,n_2\}\)，其中 \(x_i, y_j \in \mathbb{R}^3\) 是每个点的物理空间坐标。Scene Flow 的目标是求解 \(\mathcal{D}=\{x_i'-x_i \vert i = 1,...,n_1\} = \{d_i\vert i=1,...,n_1\}\)，其中 \(x_i'\) 是 \(x_i\) 在下一帧的位置。图 5. 较清晰地阐述了这三个层对点云的作用： 2.1. set conv layer set conv layer 就是 PointNet++ 中的 set abstraction layer，其作用相当于图像中的卷积操作，能提取环境上下文特征。假设输入 \(n\) 个点，每个点 \(p_i = \{x_i, f_i\}\)，其中 \(x_i\in \mathbb{R}^3\) 是物理坐标空间，\(f_i\in\mathbb{R}^c\) 是特征空间；输出 \(n'\) 个点，对应每个点为 \(p_j'=\{x_j',f_j'\}\)，其中 \(f_j'\in\mathbb{R}^{c'}\) 为特征空间。那么 set conv layer 可以描述为： \[f_j&#39; = \max_{\left\{i\vert\Vert x_i-x_j&#39;\Vert \leq r\right\}}\left\{\mathbf{h}\left(\mathrm{concat}(f_i,x_i-x_j&#39;)\right)\right\}\] 其中 \(x_j'\) 是输入的 \(n\) 个点经过 Farthest Point Sample 后的点集，感知机 \(\mathbf{h}\) 将空间 \(\mathbb{R}^{c+3}\) 映射到空间 \(\mathbb{R}^{c'}\)，然后进行 max 操作。 2.2. flow embedding layer 有了 PointNet 思想后，其实比较容易想到如何进行两个点云的特征融合提取(看论文之前，自己有想过，和论文一样⊙o⊙)。对于两个点集：\(\left\{p_i = \{x_i, f_i\}\right\}_{i=1}^{n_1}\) 以及 \(\left\{q_j = \{y_j, g_j\}\right\}_{j=1}^{n_2}\)，其中 \(x_i,y_j\in\mathbb{R}^3\)，特征量 \(f_i,g_j\in\mathbb{R}^c\)， 那么输出为：\(\left\{o_i=\{x_i,e_i\}\right\}_{i=1}^{n_1}\)，其中 \(e_i\in\mathbb{R}^{c'}\)。由此 flow embedding layer 可描述为： \[e_i = \max_{\left\{j\vert\Vert y_j-x_i\Vert \leq r\right\}}\left\{\mathbf{h}\left(\mathrm{concat}(f_i,g_j,y_j-x_i)\right)\right\}\] 可见，其数学形式与 set conv layer 基本一致，但是物理意义是完全不一样的， flow embedding layer 是以 \(x_i\) 为锚点，在另一堆点云中找到距离 \(r\) 范围内的点，从何提取特征，用来描述该点与另一堆点云的相关性。这里的感知机作用可以有其它形式，作者试验后发现这种方式最简单有效。 2.3. set upconv layer PointNet++ 中 refinement 过程是 3D 插值上采样与 unit pointnet 过程，这里作者参考图像中 conv2D 与 upconv2D 的关系，提出了 set upconv layer。图像中 upconv2D 可以认为是特征扩大+填0+conv的结合(插值上采样则等价于扩大+插值的过程)，那么类似的，set upconv layer 就是点云扩大后，再对每个目标点进行 set conv layer 的操作。 作者称这种方法比纯插值上采样好(这当然了)，也有可能是称比插值上采样+unit pointnet 好？但是这种方法本质上还是插值上采样+pointnet。 3. 其它细节 3.1. Training Loss 输入两堆点云： \(\mathcal{P}=\{x_i\}_{i=1}^{n_1}\), \(\mathcal{Q}=\{y_j\}_{j=1}^{n_2}\)，网络预测的 Scene Flow 为 \(\mathcal{D}=F(\mathcal{P,Q;\theta})=\{d_i\}_{i=1}^{n_1}\)， 真值为 \(\mathcal{D}^*=\{d_i^*\}_{i=1}^{n_1}\)。经过 Scene Flow 变换后的点云为：\(\mathcal{P'}=\{x_i+d_i\}_{i=1}^{n_1}\)，那么经过网络预测的反向的 Scene Flow 为 \(\{d_i'\}_{i=1}^{n_1}=F(\mathcal{P',P;\theta})\)，由此定义 cycle-consistency 项 \(\Vert d_i'+d_i\Vert\)，最终的 Loss 函数为： \[L(\mathcal{P,Q,D^*,\theta})=\frac{1}{n_1}\sum_{i=1}^{n_1}\left(\Vert d_i-d_i^*\vert+\lambda\Vert d_i&#39;+d_i\Vert\right)\] 3.2. Three Meta-architectures 如图 6. 所示，两个点云集合特征融合方式有三种，作者的 baseline 模型也是基于这三种，flow embedding layer 属于 Deep Mixture 类型。 3.3. Runtime 速度嘛，还是比较慢的，要应用得做优化。 3.4. Applications: Scan Registration &amp; Motion Segmentation 待补充。 4. 实验结果 如图 8. 所示，可得结论： PointNet 中 max 操作比 avg 操作效果好； 上采样中 upconv 比 interpolation 效果好； cycle-consistency loss 项有助于提升性能； 5. 参考文献 [1] Dosovitskiy, Alexey, et al. &quot;Flownet: Learning optical flow with convolutional networks.&quot; Proceedings of the IEEE international conference on computer vision. 2015. [2] Ilg, Eddy, et al. &quot;Flownet 2.0: Evolution of optical flow estimation with deep networks.&quot; Proceedings of the IEEE conference on computer vision and pattern recognition. 2017. [3] Qi, Charles R., et al. &quot;Pointnet: Deep learning on point sets for 3d classification and segmentation.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017. [4] Qi, Charles Ruizhongtai, et al. &quot;Pointnet++: Deep hierarchical feature learning on point sets in a metric space.&quot; Advances in neural information processing systems. 2017. [5] Liu, Xingyu, Charles R. Qi, and Leonidas J. Guibas. &quot;Flownet3d: Learning scene flow in 3d point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
        <tag>Scene Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds"]]></title>
    <url>%2Fpaperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds%2F</url>
    <content type="text"><![CDATA[在多视角融合 3D 检测上，研究比较多的是俯视图下的激光点云以及前视图下的图像做多传感器融合，而融合点云俯视图(Bird's Eye View)与前视图(Perspective View)的特征则比较少，新鲜出炉的本文[1]提供了一种较好的点云前视图与俯视图特征前融合(early fusion)方法。 1. 为什么要融合点云前视图特征 目前主流的点云检测算法，都是将点云在俯视图下以一定分辨率体素化(Voxelization)，然后用网络提取特征做 3D 检测。单纯在俯视图下提取特征虽然比单纯在前视图下做有优势，但还是存在几个问题： 激光点云在远处，会变得很稀疏，从而空像素会比较多； 行人等狭长型小目标特征所占像素会很小； 将点云投影到前视图，这两个问题则能有效减弱，所以本文提出融合点云前视图特征。 2. 贡献点 本文是在 PointPillars 基础上做的工作，PointPillars 主要由三个模块构成： Voxelization； Point Feature Encoding； CNN Backbone； 本文改进了前两个模块，但是本质思想还是 PointNet 形式。其余包括 Loss 形式等与 PointPillars 一致。 针对这两个模块，本文有两个贡献点，Dynamic Voxelization 以及 Point-level Feature Fusion，接下来作详细介绍。 2.1. 动态体素化(Dynamic Voxelization) 如图 1. 所示，PointPillars (包括之前的 VoxelNet 等工作)体素化的过程都是 Hard Voxelization，即 Voxel 数目要采样，每个 Voxel 里面的点数也会采样，比如 PointPillars 将每个 Voxel 的点数定义为 100 个，少于 100 个点，则作补零处理。这样会存在问题： 内存消耗大，很多稀疏的区域导致体素中要补零的内存很多； 采样导致信息丢失； 采样导致检测输出有一定的不一致性； 不能作点级别的特征融合； 由此提出动态体素化(Dynamic Voxelization)，取消所有的采样过程，为什么可以这么做呢？其实这么做也比较自然，PointPillars 中 PointNet 网络将 \((P, N, D)\) 特征映射为 \((P, N, C)\)，这里就是多层感知机将输入的 channel 维度从 \(D\) 变换到 \(C\)，与其它两个维度没有关系，而接下来做的 max-pooling 操作则将 \(N\) 维(N 个点)压缩到 1，PointPillars 中每个柱子的 N 是采样成一样的。但是可以不一样！这就是本文的动态体素化思想了。 2.2. 点级别特征融合(Point-level Feature Fusion) MMF 以 Voxel-level 将前视图的图像特征融合到俯视图的点云特征中，并以 ROI-level 融合图像前视图特征及点云俯视图特征做检测分类，本文则提出了更加前序的特征融合-Point-level 融合。 如图 2. 所示，首先将每个点的特征(x,y,z,intensity...)映射到高维度，然后经过 FC+Maxpool(PointNet 形式) 得到标准卷积网络需要的输入数据形式，再经过 Convolution Tower 模块进行环境上下文特征提取，最终每个体素的特征作为体素内每个点的特征，由此拼接成总的点特征。 其中 Convolution Tower 网络结构如图 3. 所示，输入输出的尺寸保持不变，类似于 FPN 结构。 最终每个点的特征由三部分构成： 自身特征维度映射； 俯视图下抽取的 Voxel 级别特征，有一定的感受野； 前视图下抽取的 Voxel 级别特征，有一定的感受野； 俯视图下点云特征提取过程我们比较熟悉了，这里再详细介绍下点云在前视图下提取特征的过程(还没看懂，论文中好像没有详细信息，看懂了再补充)。 3. 实验结果 网络参数配置可详见论文，图 4. 是在 Waymo 公开数据集上的实验结果。可知： 动态体素化在全距离范围内对检测都有一定的提升； 融合前视图特征能有效提升提升检测性能，尤其是远距离情况，距离越远，提升越明显； 融合前视图特征对小目标提升更加明显，如行人； 4. 参考文献 [1] Zhou, Yin, et al. &quot;End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds.&quot; arXiv preprint arXiv:1910.06528 (2019).]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lane Detection from BEV]]></title>
    <url>%2Flane-det-from-BEV%2F</url>
    <content type="text"><![CDATA[车道线检测(Lane Detection)是 ADAS 系统中重要的功能模块，而对于 L4 自动驾驶系统，在不完全依赖高精度地图的情况下，车道线检测结果也是车辆运动规划的重要输入信息。由于俯视图(BEV, Bird's Eye View)下做车道线检测相比于前视图，有天然的优势，所以本文根据几篇论文(就看了两三篇)及项目经验，探讨总结俯视图下做车道线检测的流程方案，[0]为车道线检测资源集。 1. 流程框架 由于激光点云的稀疏性，所以目前车道线检测主要还是依靠图像，激光点云数据当然可作为辅助输入。由此归纳一种可能的粒度较粗的车道线检测的流程： 仿射变换，将图像前视图变换为俯视图； 网络，提取特征，进行像素级别的分类或回归； 后处理，根据网络像素级别的预测，提取车道线； 网络相对比较成熟，后处理则在不同网络方法下复杂度差异很大，这里不做讨论。接下来主要讨论如何进行仿射变换。 2. 仿射变换 设变换前后图像坐标为 \((u,v)\), \((u',v')\), 仿射变换(Affine transformation)矩阵为 A，则： \[\begin{bmatrix} u&#39; \\ v&#39; \\ \end{bmatrix} = A \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} a_{11} &amp;a_{12} &amp;a_{13} \\ a_{21} &amp;a_{22} &amp;a_{23} \end{bmatrix} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} \tag{1}\] 根据传感器的配置及传感器参数标定情况，从图像前视图到俯视图的仿射变换有许多方法，这里介绍两种代表性的方法。 2.1. IPM(Inverse Perspective Mapping) [1]可能是首次用 IPM 进行车道线检测的文章，其检测流程基于传统方法，包括图像二值化，轮廓提取，IPM，聚类，拟合车道线等流程。 逆透视 IPM 是透视变换的逆变换，透视变换过程为： \[\begin{align} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} &amp;= \frac{1}{Z_{cam}} \begin{bmatrix} f_x &amp;0 &amp;u_0 \\ 0 &amp;f_y &amp;v_0\\ 0 &amp;0 &amp;1 \end{bmatrix} \begin{bmatrix} R &amp;t\\ 0 &amp;1 \end{bmatrix} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix}_{world}\\ &amp;= \frac{1}{Z_{cam}} \begin{bmatrix} m_{11} &amp;m_{12} &amp;m_{13}\\ m_{21} &amp;m_{22} &amp;m_{23}\\ m_{31} &amp;m_{32} &amp;m_{33}\\ \end{bmatrix} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix}_{world} = \frac{1}{Z_{cam}} M \begin{bmatrix} X \\ Y \\ Z \end{bmatrix}_{world} \tag{2} \end{align}\] 其中 \(M\) 为相机内参及外参，所以 IPM 需要预先标定相机的内外参，尤其是外参 \(R\)，表示与地面平行的世界坐标系与相机成像平面的相机坐标系之间的旋转关系。 基于(2)，可以求出世界坐标系下两条平行 \(z\) 轴的平行直线在图像坐标系下的交点，即消失点(Vanishing Point)。假设世界坐标系下平行 \(z\) 轴的直线表示为，点 \((x_a,x_b,x_c)\) 及方向向量 \(k(0,0,1)\)，那么可得该直线上任意一点投影到图像坐标系下表示，当 \(k\) 趋向于无穷大时，即可得到消失点坐标： \[\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \frac{1}{Z_{cam}} M \begin{bmatrix} x_a \\ x_b \\ x_c + k \end{bmatrix}_{world} = \begin{bmatrix} \frac{m_{11}x_a+m_{12}x_b+m_{13}(x_c+k)}{m_{31}x_a+m_{32}x_b+m_{33}(x_c+k)} \\ \frac{m_{21}x_a+m_{22}x_b+m_{23}(x_c+k)}{m_{31}x_a+m_{32}x_b+m_{33}(x_c+k)} \\ 1 \end{bmatrix} \overset{k\to\infty}{\simeq} \begin{bmatrix} \frac{m_{13}}{m_{33}} \\ \frac{m_{23}}{m_{33}} \\ 1 \end{bmatrix} \tag{3} \] 有了图像坐标系下的消失点坐标以后，我们就可以选定需要作仿射变换的 ROI 梯形区域(仿射到俯视图后，梯形变矩形)。选定梯形四个角点后，根据像素距离关系，定义俯视图下其对应的矩形框四个像素坐标点，这样能得到四组(1)方程组，由最小二乘即可得到仿射变换的矩阵 A。更详细的代码原理可见[2]。 直接 IPM 需要标定相机内外参，并且有一个较强的假设：路面是平坦的。所以时间一长标定参数，尤其是外参会失效，而且距离越远，路面的不平坦导致的逆透视变换误差也会增大。但对于 ADAS 系统来说，车道偏离预警(LDW，Lane Departure Warnings) 中车道线的检测距离在 50m 已经能满足要求。 按照之前的项目经验，LDW 系统完成度可以很高，基本思路就是 IPM，parsing(segmentation)，clustering，hough，optimization 等几个步骤(这里就不能说得太细了)，更多的精力可能在指标设计及 cornercase 优化上。唯一对用户不太友好的地方就是安装时要进行相机外参(尤其是 pitch 角)的标定，当然标定方法比较简单，我们假设相机坐标系与路面平行，所以仿射函数是固定的，用户只要看路面经过仿射后，两条 \(z\) 方向的直线是否平行即可。相对于 Mobileye 这种标定巨麻烦的产品，这种标定方式算是非常友好了。此外还可以用自动外参标定方法，脑洞也可以开出很多，效果嘛看具体环境了，需要作谨慎的收敛判断。 2.2. 学习映射 对于 L4 自动驾驶，以上方法检测的车道线不管是精度还是可靠性，都远远不够。如果有高精度地图，那么这些问题都有方法来消除。当然，如果有高精度地图，且自定位准确，也就不需要车道线检测了，所以这里讨论，在无高精度地图下，但是有激光点云数据，我们如何通过学习的方法解决上述问题。 这里主要介绍[3]的思路。如图 1. 所示，整个算法有两个网络组成，Lane Prediction 网络是做车道线检测；另一个网络是作地面估计(Ground Height Estimation)。地面估计网络的输入是历史 N 帧的栅格点云，点云经过 ego-motion 补偿到当前本车位置，点云只对运动物体会存在变形，而网络正好需要忽视运动物体。 得到了俯视图下稠密的地面估计后，就可以将前视图的图像投影到俯视图下了。具体的过程为：取地面估计的三维点，投影到图像上，然后双线性插值取得图像像素值，填充至俯视图上。这种仿射变换是借助 3D 点信息完成的，俯视图上获得的地面信息与实际物理尺寸是一致的(IPM 法并不一致)。 其实这里估计出来的地面高度就是个简陋的高精度地图，所以这种方案理论上就能消除上述问题。并且，投影的过程采用了可求导的映射方程(differentiable warping function)，所以整个算法可以端到端的训练。 关于可求导的映射方程，这里借鉴了 DeepMind 的 Spatial Transformer Networks[4] 的思想。传统卷积网络只对较小的位移有位移不变性，而 STN 引入 2D/3D 仿射变换，显示得将特征层变换到有利于分类的形态，这样整个网络就具有了仿射(位移，旋转，裁剪，尺度，歪斜)不变性。如图 2. 所示，STN 有三部分构成： Localisation Net，对于 2D 仿射，回归预测出仿射变换矩阵 \(\theta \in \mathbb{R}_{2\times 3}\); Grid Generator，根据仿射变换矩阵及仿射变换前后特征图的大小，建立仿射前后坐标映射关系； Sampler，根据坐标映射关系设计可求导的插值采样方法(如双线性)，从输入特征中采样出特征值填入仿射后的特征图中； 这里不需要回归仿射变换矩阵 \(\theta\)，预测的地面高度即可作为 Grid Generator，然后采用可求导的 Sampler，这个模块就可以嵌入到网络中，进行端到端的训练。 3. 其它思考 既然 STN 专门是用来作仿射变换的，那么是否可以在不借助激光点云的情况下，用前视图图像直接回归出仿射变换到俯视图的仿射矩阵 \(\theta\) ？理论上是可行的，但是训练过程不一定能收敛，需要精心设计训练过程，以及针对斜坡会有一定的距离误差。 4. 参考文献 [0] awesome-lane-detection [1] Wang, Jun, et al. &quot;An approach of lane detection based on inverse perspective mapping.&quot; 17th International IEEE Conference on Intelligent Transportation Systems (ITSC). IEEE, 2014. [2] LDW 原理及代码 [3] Bai, Min, et al. &quot;Deep Multi-Sensor Lane Detection.&quot; 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2018. [4] Jaderberg, Max, Karen Simonyan, and Andrew Zisserman. &quot;Spatial transformer networks.&quot; Advances in neural information processing systems. 2015.]]></content>
      <categories>
        <category>lane detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Lane Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Multi-Task Learning Using Uncertainty to Weigh Losses"]]></title>
    <url>%2Fpaperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses%2F</url>
    <content type="text"><![CDATA[深度学习网络中的不确定性(Uncertainty)是一个比较重要的问题，本文[1]讨论了其中一种不确定性在多任务训练中的应用。目前关于深度学习不确定性的研究基本出自本文作者及其团队，后续我会较系统得整理其研究成果，这篇文章先只讨论一个较为实用的应用。 1. 不确定性概述 在贝叶斯模型中，可以建模两类不确定性[2]： 认知不确定性(Epistemic Uncertainty)，描述模型因为缺少训练数据而存在的未知，可通过增加训练数据解决； 偶然不确定性(Aleatoric Uncertainty)，描述了数据不能解释的信息，可通过提高数据的精度来消除； 数据依赖地或异方差不确定性(Data-dependent or Heteroscedastic Uncertainty)，与模型输入数据有关，可作为模型预测输出； 任务依赖地或同方差不确定性(Task-dependent or Homoscedastic Uncertainty)，与模型输入数据无关，且不是模型的预测输出，不同任务有不同的值； 本文讨论同方差不确定性，其描述了不同任务间的相关置信度，所以可用同方差不确定性来设计不同任务的 \(Loss\) 权重项。 2. 为什么需要设计不同任务的 \(Loss\) 权重项 如图 1. 所示，多任务学习能提高单任务的性能，但是要充分发挥多任务的性能，那么得精心调节各任务的 \(Loss\) 权重。当任务多的时候，人工搜索最优的权重项则显得费时费力，依靠模型的同方差不确定性，我们可以自动学习权重项。 3. 多任务似然建模 下面推倒基于同方差不确定性的最大化高斯似然过程。设模型权重 \(\mathbf{W}\)，输入 \(\mathbf{x}\)，输出为 \(\mathbf{f^W(x)}\)。对于回归任务，定义模型输出为高斯似然形式： \[p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) = \mathcal{N}\left(\mathbf{f^W(x)}, \sigma ^2\right) \tag{1}\] 其中 \(\sigma\) 为观测噪声方差，描述了模型输出中含有多大的噪声。对于分类任务，玻尔兹曼分布下的模型输出概率分布为： \[p\left(\mathbf{y}\vert\mathbf{f^W(x)},\sigma\right) = \mathrm{Softmax}\left(\frac{1}{\sigma ^2}\mathbf{f^W(x)}\right) \tag{2}\] 由此对于多任务，模型输出的联合概率分布为： \[p\left(\mathbf{y}_1,\dots,\mathbf{y}_K\vert\mathbf{f^W(x)}\right) = p\left(\mathbf{y}_1\vert\mathbf{f^W(x)}\right) \dots p\left(\mathbf{y}_K\vert\mathbf{f^W(x)}\right) \tag{3}\] 对于回归任务，\(log\)似然函数： \[\mathrm{log}p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) \propto -\frac{1}{2\sigma ^2} \Vert \mathbf{y-f^W(x)} \Vert ^2 - \mathrm{log}\sigma \tag{4}\] 对于分类任务，\(log\)似然函数： \[\mathrm{log}p\left(\mathbf{y}=c\vert\mathbf{f^W(x)}, \sigma\right) = \frac{1}{2\sigma ^2}f_c^{\mathbf{W}}(\mathbf{x})- \mathrm{log}\sum_{c&#39;} \mathrm{exp}\left(\frac{1}{\sigma^2}f^{\mathbf{W}}_{c&#39;}(\mathbf{x}) \right) \tag{5}\] 现同时考虑回归与分类任务，则多任务的联合 \(Loss\)： \[\begin{align} \mathcal{L}(\mathbf{W}, \sigma _1, \sigma _2) &amp;= -\mathrm{log}p\left(\mathrm{y_1,y_2}=c\vert\mathbf{f^W(x)} \right) \\ &amp;= -\mathrm{log}\mathcal{N}\left(\mathbf{y_1};\mathbf{f^W(x)}, \sigma_1^2\right) \cdot \mathrm{Softmax}\left(\mathbf{y_2}=c;\mathbf{f^W(x)},\sigma_2\right) \\ &amp;= \frac{1}{2\sigma_1^2}\Vert \mathbf{y}_1-\mathbf{f^W(x)}\Vert ^2 + \mathrm{log}\sigma_1 - \mathrm{log}p\left(\mathbf{y}_2=c\vert\mathbf{f^W(x)},\sigma_2\right) \\ &amp;= \frac{1}{2\sigma_1^2}\mathcal{L}_1(\mathbf{W}) +\frac{1}{\sigma_2^2}\mathcal{L}_2(\mathbf{W}) + \mathrm{log}\sigma_1 + \mathrm{log}\frac{\sum_{c&#39;}\mathrm{exp}\left(\frac{1}{\sigma_2^2}f_{c&#39;}^{\mathbf{W}}(x)\right)}{\left(\sum_{c&#39;}\mathrm{exp}\left(f_{c&#39;}^{\mathbf{W}}(x) \right) \right)^{\frac{1}{\sigma_2^2}}} \\ &amp;\approx \frac{1}{2\sigma_1^2}\mathcal{L}_1(\mathbf{W}) +\frac{1}{\sigma_2^2}\mathcal{L}_2(\mathbf{W}) + \mathrm{log}\sigma_1 + \mathrm{log}\sigma_2 \tag{6} \end{align}\] 由此得到两个权重项，任务噪声 \(\sigma\) 越大，则该任务的误差权重越小。实际应用中，为了数值稳定，令 \(s:=\mathrm{log}\sigma^2\): \[\mathcal{L}(\mathbf{W}, s_1, s_2) = \frac{1}{2}\mathrm{exp}(-s_1)\mathcal{L}_1(\mathbf{W}) + \mathrm{exp}(-s_2)\mathcal{L}_2(\mathbf{W}) + \mathrm{exp}(\frac{1}{2}s_1) + \mathrm{exp}(\frac{1}{2}s_2) \tag{7}\] 对于更多任务的模型，根据任务类型也很容易扩展，网络自动学习权重项 \((s_1,s_2,...,s_n)\)。 4. 实验结果 如图 2. 所示，作者设计了同时作语义分割、实例分割、深度估计的网络，由图 3. 可知，用任务的不确定性来加权任务的 \(Loss\)，效果显著。 5. 参考文献 [1] Kendall, Alex, Yarin Gal, and Roberto Cipolla. &quot;Multi-task learning using uncertainty to weigh losses for scene geometry and semantics.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. [2] Kendall, Alex, and Yarin Gal. &quot;What uncertainties do we need in bayesian deep learning for computer vision?.&quot; Advances in neural information processing systems. 2017.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>paper reading</tag>
        <tag>Uncertainty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Multi-Task Multi-Sensor Fusion for 3D Object Detection""]]></title>
    <url>%2Fpaperreading-MT-MS-Fusion-for-3D-Object-Detection%2F</url>
    <content type="text"><![CDATA[本文[1]提出了一种 3D 检测的多任务多传感器融合方法。输入数据为图像以及点云，输出为地面估计，2D/3D检测，稠密深度图。为了让其它任务来帮助提升 3D 检测效果，作者设计了很多方法，工作还是比较细致且系统。 整个算法框架如图 1. 所示。点云数据还是在俯视图(BEV)下进行栅格化处理，高度切割是在地面估计归一化后的基础上来做，因为要 3D 定位的目标都是在地面上的；另一方面，图像与投影到前视图的点云数据进行合并，作为网络的输入数据。 网络结构上作者提出了两种俯视图与前视图特征融合策略：1. Point-wise feature fusion; 2. ROI-wise feature fusion. 这也是文章比较重要的一个贡献点。 文章所提的 3D 检测方法大多数细节技巧并无新意，这里主要讨论分析文章中与传统方法不太一样的两大贡献点： 1. 俯视图与前视图特征融合策略； 2. 其它两个任务对检测任务提升的作用。 1. 俯视图与前视图特征融合策略 由于网络输入有俯视图与前视图两个数据流，所以如何将这两个数据流进行特征级别的融合就显得尤为重要，文章提出了两种方式，backbone 网络级别的 point-wise feature fusion 以及第二阶段 ROI-wise feature fusion。 1.1. Point-wise Feature Fusion 3D 检测主体还是在俯视图下来做的，相比前视图对 3D 检测的处理，俯视图 3D 检测有天然的优势。因此，如何有效地将前视图的特征融合到俯视图的特征中，就显得尤为重要（俯视图特征融合到前视图相对比较简单）。 如图 2. 所示，像素点级别的特征融合方式有两个模块，Multi-scale Fusion 以及 Continuous Fusion。Multi-scale Fusion 我们比较熟悉，可以采用类似 FPN 的结构实现。这里主要讨论 Continuous Fusion 模块。 Continuous Fusion 源自作者的另一篇文章[2]。如图 3. 所示，该文检测框架基本就是本文的主干，其中 Fusion Layers 就是 Continuous Fusion 模块。而 continuous fusion 前身是作者团队提出的 Deep Parametric Continuous Convolution[3]。 Deep Parametric Continuous Convolution 传统的卷积只能作用于网格结构(gird-structured)的数据上，为了能处理点云这种非网格结构的数据，[3]提出了带参数的卷积(Parametric Continuous Convolution)。对于第 \(i\) 个需要计算的特征位置，其特征值 \(\mathrm{h}_i \in \mathbb{R}^N\) 数学形式为： \[ \mathrm{h}_i=\sum_j \mathbf{MLP}(x_i-x_j)\cdot \mathrm{f}_j \] 其中 \(j\) 表示第 \(i\) 个点周围的点，\(\mathrm{f}_j \in \mathbb{R}^N\) 为输入特征，\(x_j\in \mathbb{R}^3\) 是点的坐标值。多层感知机 \(\mathbf{MLP}\) 则起到了参数核函数的作用，将 \(\mathbb{R}^{J\times 3}\) 映射为 \(\mathbb{R}^{J\times N}\) 空间，用作特征计算的权重值。 Continuous Fusion Layer Continuous Fusion 则没有显示得计算卷积权重的过程，这样使得特征提取能力更强，而且计算效率更高，不用存储权重值。其数学描述为： \[ \mathrm{h}_i=\sum_j \mathbf{MLP}(\mathrm{concat}[\mathrm{f}_j,x_i-x_j]) \] 多层感知机 \(\mathbf{MLP}\) 直接将 \(\mathbb{R}^{J\times (N+3)}\) 映射到 \(\mathbb{R}^{J\times M}\) 空间，最后再做一个 element-wise 的相加即得空间为 \(\mathbb{R}^{M}\) 的特征输出(这个和 PointNet 几乎一模一样，本质就是将每个点的特征空间升维，然后用对称函数(pooling, sum)消除无序点的影响, 只是这里输入的点的特征空间 \(N\) 可能已经很大了)。 具体步骤如图 4. 所示： 将点云投影到图像坐标系，在图像特征图上用双线性插值求取每个点对应的图像特征向量； 俯视图下对于每个需要求取特征的像素点，采样邻近的 \(K\) 个物理点，然后应用 Continuous Fusion，得到该像素点的特征向量； 1.2. ROI-wise Feature Fusion 在俯视图上获得 3D 检测框后(见图 1.)，将其分别投影到图像特征图以及点云特征图上，图像特征图上用 ROIAlign 提取出目标框内的图像特征；点云特征图上用类似方法提取出带方向的目标框内的点云特征，两种特征合并到一起，再用网络进行 2D/3D 目标框的优化回归。 如图 5. 所示，点云特征图上的目标框是带有一定方向的，准确提取特征时会有一些问题。由于旋转框有周期性，所以将目标框分成两种情况来考虑，这样提取的特征就没有奇异性了，如图 5.2 所示。此外 3D 优化回归是在目标框旋转后的坐标系下进行的。 2. 多任务对检测任务的提升作用 2.1. 地面估计 俯视图下点云进行栅格化手工提取特征之前，作者作了一个地面归一化的操作。地面估计是在栅格分辨率下进行的，所以自然能对点云的每个栅格进行地面归一化。作者认为自动驾驶 3D 检测的目标都是在地面上的，所以地面的先验知识应该有助于 3D 定位，与 HDNET[4] 思想类似。而在线地面估计(地面估计是建图的其中一个任务)不依赖离线地图，能提高系统鲁棒性。 如图 6.,8 所示，地面估计的加入，确实使得 3D 检测性能有所提升。 2.2. 深度估计 由于前视图输入的是图像以及点云的投影图，所以可进一步通过网络预测稠密的前视深度图。作者对点云的投影图作了精心的设计，这里不做展开，有可能直接投影的 \((x,y,z)\) 3 通道的投影图也够用。 获得了前视稠密深度图后，可将其反投影到点云俯视图下，这样稀疏的点云会变得更加稠密，更有利于图像到点云的 Point-wise Feature Fusion。这里作者只在邻近取不到点云的时候用这反投影的伪雷达点(pseudo LiDARP)。如图 7. 所示，在该数据集上效果提升还是比较明显，而 Kitti 上不太明显，因为两者的相机与雷达配置不太一样。在 TOR4D 数据集上，远距离的车上点云数量更小，所以该技术效果较好。 3. 其它细节 Loss 设计为： \[ Loss = L_{cls} + \lambda(L_{box}+L_{r2d}+L_{r3d}) + \gamma L_{depth} \] 其中 \(\lambda\) 与 \(\gamma\) 为权重项，\(L_{box}\) 为俯视图下预测的 3D 框，\(L_{r2d},L_{r3d}\) 为优化回归的 2D/3D 框。每一项的 Loss 计算方式与传统无异。 本文方法与其它方法对比如图 9. 所示。 4. 参考文献 [1] Liang, Ming, et al. &quot;Multi-Task Multi-Sensor Fusion for 3D Object Detection.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019. [2] Liang, Ming, et al. &quot;Deep continuous fusion for multi-sensor 3d object detection.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018. [3] Wang, Shenlong, et al. &quot;Deep parametric continuous convolutional neural networks.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. [4] Yang, Bin, Ming Liang, and Raquel Urtasun. &quot;Hdnet: Exploiting hd maps for 3d object detection.&quot; Conference on Robot Learning. 2018.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Traveling-in-Serbia-Montenegro-Bosnia]]></title>
    <url>%2Ftraveling-in-Serbia-Montenegro-Bosnia%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://leijie.oss-cn-shenzhen.aliyuncs.com/travel/Serbia-Montenegro-Bosnia.mp4","pic":"https://leijie.oss-cn-shenzhen.aliyuncs.com/travel/Serbia-Montenegro-Bosnia.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Fast and Furious"]]></title>
    <url>%2Fpaperreading-Fast-and-Furious%2F</url>
    <content type="text"><![CDATA[动态目标状态估计传统的做法是将其分解为目标检测，目标跟踪，目标运动预测三个子问题进行链式求解，这回导致上游模块的误差在下游模块中会传递并放大。考虑到跟踪与预测能帮助提升检测的性能，比如对于遮挡或远距离目标，跟踪与预测能减少检测的漏检(FN)；而误检(FP)则可通过时域相关信息消除，由此本文[1]提出了一种联合 3D 检测，跟踪，运动预测的多任务网络。 1. Model Architecture 1.1. Data Representation 雷达坐标系下，每帧点云限定范围为\((x_{min}, x_{max}, y_{min}, y_{max}, z_{min}, z_{max})\)，那么在分辨率 \(r = (dx,dy,dz)\) 下进行栅格化，可得到体素 \((C, H, W) = (\frac{z_{max}-z_{min}}{dz}, \frac{y_{max}-y_{min}}{dy}, \frac{x_{max}-x_{min}}{dx})\), 如果体素中有点云那么该体素值置为1，否则置为0，这样就得到了俯视图下的伪图像。 此外将历史 \(T-1\) 帧点云先转换到当前本体坐标系(需要 ego motion 信息)，然后串成一起，就获得 \((T, C, H, W) \) 维的模型数据输入表示。 1.2. Model Formulation 实际输入网络的应该是 \((N, T, C, H, W) \) 维的数据，首先需要经过一个 fusion 层将数据映射到 \((N, C', H', W') \) 维，然后用一个类似与 SSD 结构的 backbone+head 网络即可。 1.2.1. Fusion 本文提出了两种融合方式： Early Fusion 如图 1. 所示，直接在 T 维度上进行一维卷积，卷积 \(kernel_ size = T\)，由此得到 \((N, C, H, W) \) 维的特征。 Late Fusion 如图 1. 所示，通过两次 3D 卷积将 \(T=5\) 变换到 \(T=1\)，\(kernel size = (3, 3, 3)\),由此也得到 \((N, C, H, W) \) 维的特征。 相比 Early Fusion，Late fusion 有更深的特征提取。 1.2.2. Backbone+Head backbone 采用 VGG16 结构，图 1. 可见。 head 采用类似 SSD 检测头的形式。anchor 也是有不同比例不同尺寸的矩形组成(另一种方法是，由于俯视图下同种类别的尺寸相似性，所以针对不同类别采用同一尺寸的 anchor 即够用)，角度回归则采用 \(cos, sin\) 形式。 如图 2. 所示，检测头有两个分之分支，第一个输出预测的分类 score map(n 个预测的 score map 是共享的)，第二个输出 n 个预测的 3D 框编码信息。 1.3. Decoding Tracklets 由于有检测及预测的信息，所以可用简单的方法解析出跟踪 ID。历史的预测框信息可认为是当前的跟踪框，所以就自然得在 MOT 问题里进行求解。这里可直接计算跟踪框(历史预测框)与当前检测框的 overlap 误差项，然后将重合度高的目标框标记为同一 ID 即可。 1.4. Loss Function 总的误差由分类误差与回归误差构成： \[\xi = \sum\left(\alpha \cdot \xi_{cla} + \sum_{i=t,t+1,...,t+n}\xi_{reg}^t\right)\] 这两项误差具体计算与传统的并无很大差别，此外作者还用了 OHEM 的策略，来平衡正负样本量巨大的差异。 2. Experimental Evaluation 作者用了比 kitti 大的数据集，图 3. 所示，late fusion 比 early fusion 效果好一点，但是 late fusion 需要 3D 卷积。其它实验结果可参见文章。 [1] Luo, Wenjie, Bin Yang, and Raquel Urtasun. &quot;Fast and furious: Real time end-to-end 3d detection, tracking and motion forecasting with a single convolutional net.&quot; Proceedings of the IEEE conference on Computer Vision and Pattern Recognition. 2018.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-PointPillars]]></title>
    <url>%2Fpaperreading-PointPillars%2F</url>
    <content type="text"><![CDATA[1. VoxelNet-&gt;SECOND-&gt;PointPillars 相比于图像，激光点云数据是 3D 的，且有稀疏性，所以对点云的前期编码预处理尤其重要，目前大多数算法都是在鸟瞰图下进行点云物体检测，由此对点云的编码预处理主要有两大类方法： 以一定的分辨率将点云体素化，每个垂直列中的体素集合被编码成一个固定长度，手工制作的特征，最终形成一个三维的伪图像，以此为代表的方法有 MV3D，AVOD，PIXOR，Complex YOLO； PointNet 无序点云处理方式，以此为代表的方法 Frustum PointNet[1], VoxelNet[2]，SECOND[3]，后两者是在鸟瞰图下进行编码的，需要 3D 卷积运算； 本文提出的 PointPillar[4] 是延续 VoxelNet，SECOND 的工作，VoxelNet 将 PointNet(PointNet-系列论文详读) 思想引入体素化后的体素特征编码中，然后采用 3D 卷积做特征提取，再用传统的 2D 卷积进行目标检测；SECOND 则考虑到点云特征的稀疏性，用 2D 稀疏卷积代替传统卷积，速度得到了很大的提示。而 PointPillar 则在体素的垂直列上不做分割，从而移除了 3D 卷积的操作，其优点有： 无手工编码的过程，利用了点云的所有信息，且无需要调节的参数； 运算均为 2D 卷积，高效； 可迁移至其它点云数据； 这三篇工作框架结构基本一致，由三部分组成： 特征编码网络(Encoder，作特征编码)，在鸟瞰图下，将点云编码为稀疏的伪图像； 卷积中间网络(Middle，作特征提取)，将伪图像用 backbone 网络进行特征提取； 区域生成网络(RPN)，也可以是 SSD FPN 等检测头的改进，用于分类和回归 3D 框，与图像检测不一样的地方是，点云鸟瞰图下的最后一层特征层不能很小； 如图 1. 所示，本文 Pointpillar 主要的工作集中在特征编码网络，所以以下主要介绍其特征编码网络方式，以及实现细节。 2. 特征编码 Pointpillar 只对 \(x-y\) 平面作 \(H\times W\) 栅格化，栅格化后形成 \(H\times W=P\) 个柱子(Pillar)，每个柱子采样出 \(N\) 个点，每个点编码为 \(D=9\) 维的向量：\(\{x,y,z,r,x_c,y_c,z_c,x_p,y_p \}\)，其中 \(\{x_c,y_c,z_c\}\) 为该点与柱子内所有点的均值点的距离，\(x_p,y_p \) 为该点与柱子中心的距离。综上最后形成\((D,P,N )\) 维的张量，然后用 PointNet 网络输出 \((C,P,N )\) 维的张量，最后用 \(MAX\) 操作输出 \((C,P) = (C,H,W)\) 的伪图像。 3. 实现细节 特征编码 只取有点的柱子，所以 \(P &lt; H\times W\) 计算量较大，需要并行加速，我复现的时候是将柱子信息离线存下来的 pointpillar 方式可能只比高度体素采样方式效果高一点 训练 针对不同的类别设定唯一尺寸的 anchor，角度上旋转 90 度，所以每个点上每个类别是有两个 anchor 正负样本严重不均衡，所以需要 OHEM 或者 focalloss 技术 [1] Qi, Charles R., et al. &quot;Frustum pointnets for 3d object detection from rgb-d data.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. [2] Zhou, Yin, and Oncel Tuzel. &quot;Voxelnet: End-to-end learning for point cloud based 3d object detection.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. [3] Yan, Yan, Yuxing Mao, and Bo Li. &quot;Second: Sparsely embedded convolutional detection.&quot; Sensors 18.10 (2018): 3337. [4] Lang, Alex H., et al. &quot;PointPillars: Fast encoders for object detection from point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PointNet 系列论文详读]]></title>
    <url>%2FPointNet-%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E8%AF%A6%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[写了半天，发现还是网上一篇文章整理的好，直接上传递门吧：PointNet 系列论文解读]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔曼滤波器在三维目标状态估计中的应用]]></title>
    <url>%2F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%9B%AE%E6%A0%87%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[目前主流的三维目标的状态估计方法（也可称为 MOT 问题）主要包括三部分：1. 检测，出单帧三维目标信息；2. 跟踪，前后帧数据关联出 ID 信息；3. 滤波，平滑估计状态信息。这里的“跟踪”只是狭义地指出 ID 的过程，“滤波”也就是综述 Multiple-Object-Tracking-A-Literature-Review 中提到的 Inference 过程。Inference 过程还可以是基于优化的方法，本文我们主要讨论在自动驾驶中估计动态障碍物状态的扩展卡尔曼滤波方法。 1. 扩展卡尔曼滤波 文章卡尔曼滤波详解中已经详细推导了卡尔曼滤波相关原理，这里摘抄如下。非线性系统： \[\left\{\begin{array}{l} 运动方程:\quad x_k=f(x_{k-1},u_k)+w_k \\ 测量方程:\quad z_k=h(x_k)+v_k \end{array}\tag{1}\right.\] 滤波的两个步骤： 预测（Predict） 计算先验： \[\begin{align} \bar{x} _k&amp;=f(\hat{x} _{k-1},u _k) \tag{2}\\ \bar{P} _k&amp;=F\hat{P} _kF^T+Q _k \tag{3} \end{align}\] 更新（Update） 先计算卡尔曼增益： \[K_k=\bar{P}_kH_k^T(H_k\bar{P}_kH_k^T+R_k)^{-1} \tag{4}\] 再计算后验概率分布： \[\begin{align} \hat{x}_k &amp;=\bar{x}_k+K(z_k-h(\bar{x})) \tag{5}\\ \hat{P}_k &amp;=(I-KH_k)\bar{P}_k \tag{6} \end{align}\] 2. 非线性系统构建 要构建三维目标状态估计系统，我们得分析状态量 \(x_k\)，测量量 \(z_k\)，输入量 \(u_k\)，状态转移函数（运动学方程）\(f(\cdot)\)，观测函数 \(h(\cdot)\)，以及雅克比矩阵 \(F\)，\(H\) 各是什么。 如图1所示，我们严格限定要构建的非线性系统场景：动态目标的状态估计。对于自动驾驶中的动态目标状态估计，我们关心的状态量有水平面上目标物理位置，朝向，速度，转向速度，加速度，记为： \[x_k=\begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi}\\ a\end{bmatrix}\tag{7}\] 目前主流的 3D 检测方法，能出位置，尺寸，朝向。所以测量量： \[z_k=\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix}\tag{8}\] 以上针对的是目标三维状态估计，如果是本车的状态估计，那么测量量可能可以加上本车的速度等（故限定场景）。文章 [paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving" 的 3.2.1 章节中提到过一种车辆运动学模型，该模型定义了输入量：方向盘比率以及加速度（实际使用中均设为0，类似下述质点模型中的 CTRV 模型）；并增加了状态量：方向盘转角。虽然那篇文章处理的场景与本篇讨论的一致，但是那篇文章采用的是优化方法，方向盘转角可作为优化参数进行求解；而本篇讨论的滤波迭代方法，则很难确定方向盘转角。所以该模型虽然能更好的描述目标，但是可能并不是更有效的（实际中可做实验对比），这里引出几种质点模型。 [1]中介绍了几种非线性车辆质点模型：CHCV(Constant Heading and Constant Velocity)，CTRV(Constant Turn Rate and Velocity)，CTRA(Constant Turn Rate and Acceleration)，此外应该还有 CHA(Constant Heading and Acceleration)。这些模型均没有考虑输入量，即： \[u_k=\mathbb{0}\tag{9}\] 这里我们依次介绍各模型（为了完整性，重写文章 [paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving" 中的前转向车运动学模型），并导出状态转移函数（运动学方程）\(f(\cdot)\)，观测函数 \(h(\cdot)\)，以及雅克比矩阵 \(F\)，\(H\)。 2.1. CHCV(Constant Heading and Constant Velocity) 该模型下，目标车辆的朝向及速度不变，即 \(\dot{\psi}=0\)。则容易写出，在时间 \(\Delta T\) 内，运动方程\(f(\cdot)\)为： \[\begin{align} &amp; \begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi}\end{bmatrix} _k= \begin{bmatrix} x+v\,cos(\psi)\Delta T\\ y+v\,sin(\psi)\Delta T\\ \psi\\ v\\ 0\end{bmatrix} _{k-1} \\ \iff &amp;\begin{bmatrix} x\\ y\\ \psi\\ v\\ \end{bmatrix} _k= \begin{bmatrix} x+v\,cos(\psi)\Delta T\\ y+v\,sin(\psi)\Delta T\\ \psi\\ v\\ \end{bmatrix} _{k-1} \tag{10} \end{align}\] 观测方程\(h(\cdot)\)也可得到： \[\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix} _k= \begin{bmatrix} 1 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \psi\\ v\\ \end{bmatrix} _{k} \tag{11} \] 由此得到雅克比矩阵： \[\begin{align}F&amp;= \begin{bmatrix} 1 &amp;0 &amp;-v\,sin(\psi)\Delta T &amp;cos(\psi)\Delta T\\ 0 &amp;1 &amp;v\,cos(\psi)\Delta T &amp;sin(\psi)\Delta T\\ 0 &amp;0 &amp;1 &amp;0\\ 0 &amp;0 &amp;0 &amp;1 \end{bmatrix} \tag{12} \\ H&amp;=\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0\\ \end{bmatrix} \tag{13} \end{align}\] 2.2. CTRV(Constant Turn Rate and Velocity) 该模型下，目标车辆的(朝向)转向速度及线速度不变，即 \(a=0\)。则分别在 \(x,y\) 方向上，位移积分为： \[\left\{\begin{array}{l} x=\int_0^{\Delta T} v\,cos(\dot{\psi}t+\psi)dt=\frac{v}{\dot{\psi}}sin(\dot{\psi}t+\psi)\vert_0^{\Delta T}&amp;= \frac{v}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) \\ y=\int_0^{\Delta T} v\,sin(\dot{\psi}t+\psi)dt=-\frac{v}{\dot{\psi}}cos(\dot{\psi}t+\psi)\vert_0^{\Delta T}&amp;=\frac{v}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\ \end{array}\tag{14}\right.\] 由此得到运动方程\(f(\cdot)\)为： \[\begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi}\end{bmatrix} _k= \begin{bmatrix} x+\frac{v}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi))\\ y+\frac{v}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\ \psi+\dot{\psi}\Delta T\\ v\\ \dot{\psi}\end{bmatrix} _{k-1} \tag{15} \] 观测方程则还是线性方程： \[\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix} _k= \begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi} \end{bmatrix} _{k} \tag{16} \] 由此得到雅克比矩阵： \[\begin{align}F&amp;= \begin{bmatrix} 1 &amp;0 &amp;\frac{v}{\dot{\psi}}(cos(\dot{\psi}+\psi)-cos(\psi)) &amp;\frac{1}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) &amp;\frac{v\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{v}{\dot{\psi}^2}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) \\ 0 &amp;1 &amp;\frac{v}{\dot{\psi}}(sin(\dot{\psi}+\psi)-sin(\psi)) &amp;\frac{1}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) &amp;\frac{v\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{v}{\dot{\psi}^2}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\ 0 &amp;0 &amp;1 &amp;0 &amp;\Delta T\\ 0 &amp;0 &amp;0 &amp;1 &amp;0\\ 0 &amp;0 &amp;0 &amp;0 &amp;1\\ \end{bmatrix} \tag{17} \\ H&amp;=\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \tag{18} \end{align}\] 2.3. CTRA(Constant Turn Rate and Acceleration) 该模型下，目标车辆的(朝向)转向速度及线加速度不变。\(x,y\) 方向上的位移积分为： \[\left\{\begin{array}{l} x&amp;=&amp;\int_0^{\Delta T} (v+at)\,cos(\dot{\psi}t+\psi)dt= \frac{a}{\dot{\psi}^2}cos(\dot{\psi}t+\psi)+\frac{v+at}{\dot{\psi}}sin(\dot{\psi}t+\psi)\vert_0^{\Delta T}\\ &amp;=&amp; \frac{a}{\dot{\psi}^2}cos(\dot{\psi}\Delta T+\psi)+\frac{v+a\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}cos(\psi)-\frac{v}{\dot{\psi}}sin(\psi)\\ y&amp;=&amp;\int_0^{\Delta T} (v+at)\,sin(\dot{\psi}t+\psi)dt= \frac{a}{\dot{\psi}^2}sin(\dot{\psi}t+\psi)-\frac{v+at}{\dot{\psi}}cos(\dot{\psi}t+\psi)\vert_0^{\Delta T}\\ &amp;=&amp; \frac{a}{\dot{\psi}^2}sin(\dot{\psi}\Delta T+\psi)-\frac{v+a\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}sin(\psi)+\frac{v}{\dot{\psi}}cos(\psi)\\ \end{array}\tag{19}\right.\] 由此得到运动方程\(f(\cdot)\)为： \[\begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi}\\ a\end{bmatrix} _k= \begin{bmatrix} x+\frac{a}{\dot{\psi}^2}cos(\dot{\psi}\Delta T+\psi)+\frac{v+a\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}cos(\psi)-\frac{v}{\dot{\psi}}sin(\psi)\\ y+\frac{a}{\dot{\psi}^2}sin(\dot{\psi}\Delta T+\psi)-\frac{v+a\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}sin(\psi)+\frac{v}{\dot{\psi}}cos(\psi) \\ \psi+\dot{\psi}\Delta T\\ v+a\Delta T\\ \dot{\psi}\\ a\end{bmatrix} _{k-1} \tag{20} \] 观测方程则还是线性方程： \[\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix} _k= \begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \psi\\ v\\ \dot{\psi}\\ a\end{bmatrix} _{k} \tag{21} \] 同理可得到雅克比矩阵，由于页面限制，这里不再写出。 2.4. CHA(Constant Heading and Acceleration) 该模型下，此时目标车辆的朝向及线加速度不变，即 \(\dot{\psi}=0\)。\(x,y\) 方向上的位移积分为： \[\left\{\begin{array}{l} x=\int_0^{\Delta T} (v+at)\,cos(\psi)dt= \left(vt+\frac{1}{2}at^2\right)cos(\psi)\vert_0^{\Delta T}&amp;= \left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi) \\ y=\int_0^{\Delta T} (v+at)\,sin(\psi)dt= \left(vt+\frac{1}{2}at^2\right)sin(\psi)\vert_0^{\Delta T}&amp;= \left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi) \\ \end{array}\tag{22}\right.\] 由此得到运动方程\(f(\cdot)\)为： \[\begin{bmatrix} x\\ y\\ \psi\\ v\\ a\end{bmatrix} _k= \begin{bmatrix} x+\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi)\\ y+\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi) \\ \psi\\ v+a\Delta T\\ a\end{bmatrix} _{k-1} \tag{23} \] 观测方程则还是线性方程： \[\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix} _k= \begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \psi\\ v\\ a\end{bmatrix} _{k} \tag{24} \] 由此得到雅克比矩阵： \[\begin{align}F&amp;= \begin{bmatrix} 1 &amp;0 &amp;-\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi) &amp;\Delta Tcos(\psi) &amp;\frac{1}{2}\Delta T^2cos(\psi) \\ 0 &amp;1 &amp;\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi) &amp;\Delta Tsin(\psi) &amp;\frac{1}{2}\Delta T^2sin(\psi)\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ 0 &amp;0 &amp;0 &amp;1 &amp;\Delta T \\ 0 &amp;0 &amp;0 &amp;0 &amp;1 \end{bmatrix} \tag{25} \\ H&amp;=\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \tag{26} \end{align}\] 2.5. 前转向车模型 这里给出文章 [paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving" 中的前转向车运动学模型，推导过程可见文章。这里令方向盘角度比率 \(\gamma\) 以及加速度 \(a\) 为 0，所以本质上也是个 CTRV 模型。 引入状态变量方向盘/车轮角度 \(\delta\)（与朝向转速 \(\psi\) 类似），运动方程\(f(\cdot)\)为： \[\begin{bmatrix} x\\ y\\ \psi\\ v\\ \delta\end{bmatrix} _k= \begin{bmatrix} x+cos(\psi)v\Delta T\\ y+sin(\psi)v\Delta T \\ \psi+\frac{tan(\delta)}{L}v\Delta T\\ v\\ \delta\end{bmatrix} _{k-1} \tag{27} \] 观测方程则还是线性方程： \[\begin{bmatrix} x\\ y\\ \psi\\ \end{bmatrix} _k= \begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \psi\\ v\\ \delta\end{bmatrix} _{k} \tag{28} \] 由此得到雅克比矩阵： \[\begin{align}F&amp;= \begin{bmatrix} 1 &amp;0 &amp;-sin(\psi)v\Delta T &amp;cos(\psi)\Delta T &amp;0 \\ 0 &amp;1 &amp;cos(\psi)v\Delta T &amp;sin(\psi)\Delta T &amp;0 \\ 0 &amp;0 &amp;1 &amp;\frac{tan(\delta)}{L}\Delta T &amp;\frac{v}{Lcos^2(\delta)}\Delta T\\ 0 &amp;0 &amp;0 &amp;1 &amp;0\\ 0 &amp;0 &amp;0 &amp;0 &amp;1\\ \end{bmatrix} \tag{29} \\ H&amp;=\begin{bmatrix} 1 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;1 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;1 &amp;0 &amp;0\\ \end{bmatrix} \tag{30} \end{align}\] 3. 状态及参数初始化 以上介绍了四个质点模型以及一个前转向模型，当然还有更复杂的模型，但是对于目标车辆的状态估计，由于观测量有限，而且也不能知道输入量（如果 V2X 能够实现，那就知道目标车辆的更多状态信息了），所以这些模型也基本够用。 模型构建好之后，为了迭代，还需初始化各个状态量及协方差参数矩阵。初始化值不对，会导致迭代发散，这里初始化就会有几个问题： 无法观测的状态量较难初始化，如转向速度，线加速度等； 观测不稳定的状态量较难初始化，如目标有截断的情况下； 协方差矩阵较难初始化，如状态量的协方差矩阵； 前两个问题需要在工程实践中优化；最后一个问题（非常重要）可以让检测网络同时出预测值的不确定性(Uncertainty)，这也是深度学习中一个较为系统性的工作，后面文章再做介绍。 [1] https://github.com/balzer82/Kalman]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔曼滤波详解]]></title>
    <url>%2F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[状态估计问题是指，基于初始状态信息，一系列观测量，一系列输入量，以及系统的运动模型和观测模型，来计算系统在某时刻的真实状态的估计值。卡尔曼滤波及其相关卡尔曼滤波算法是状态估计的重要方法。本文介绍卡尔曼滤波(Kalman Filter)，扩展卡尔曼滤波(Extended Kalman Filter)。 1. 卡尔曼滤波 1.1. 线性高斯系统 卡尔曼滤波是线性高斯系统的最优无偏估计，定义离散线性高斯系统： \[\left\{\begin{array}{l} 运动方程:\quad x_k=A_kx_{k-1}+B_ku_k+w_k\\ 测量方程:\quad z_k=C_kx_k+v_k \end{array}\tag{1}\right.\] 其中矩阵 \(A_k\) 为转移矩阵（transition matrix），设矩阵 \(B_k=I\) 为控制矩阵，矩阵 \(C_k\) 为观测矩阵(observation matrix)。并且所有状态和噪声均满足高斯分布： \[\begin{align} 过程噪声: \quad &amp; w_k \sim N(0,Q_k)\\ 测量噪声: \quad &amp; v_k \sim N(0,R_k) \end{align}\] 卡尔曼滤波估计线性高斯系统的状态分为两个步骤： 预测（Predict） 计算先验： \[\begin{align} \bar{x}_ k &amp;=A_ k\hat{x}_ {k-1}+u_ k \tag{2}\\ \bar{P}_ k &amp;=A_ k\hat{P}_ {k-1}A_ k^T+Q_ k \tag{3} \end{align}\] 更新（Update） 先计算卡尔曼增益： \[K_k=\bar{P}_kC_k^T(C_k\bar{P}_kC_k^T+R_k)^{-1} \tag{4}\] 再计算后验概率分布： \[\begin{align} \hat{x}_k &amp;=\bar{x}_k+K(z_k-C_k\bar{x}) \tag{5}\\ \hat{P}_k &amp;=(I-KC_k)\bar{P}_k \tag{6} \end{align}\] 以下通过三种方式来推导出卡尔曼滤波器。 1.2. 通过 MAP/贝叶斯推断推导[1][2][3] 状态估计问题的概率解释就是用 \(0\) 到 \(k\) 的数据（包括初始状态，观测量，输入量）来估计当前时刻的状态分布：\(P(x_k\vert x_0,u_{1:k},z_{1:k})\)。根据贝叶斯法则： \[P(x_k\vert x_0,u_{1:k},z_{1:k}) \propto P(z_k\vert x_k)P(x_k\vert x_0,u_{1:k},z_{1:k-1})\tag{7}\] 这三项分别为后验概率，似然，先验概率。所以状态估计可转换为该后验概率最大化（Maximize a Posterior，MAP）问题。MAP 相当于最大化似然与先验的乘积。似然由测量方程给出，先验有运动方程给出。先验部分如果考虑历史所有信息，那么可以用非线性优化框架来解；如果只考虑一阶马尔科夫性，那么就是卡尔曼滤波方法，前述线性高斯系统就满足一阶马尔科夫性。 该系统下，假设已知 \(k-1\) 时刻的后验状态估计 \(\hat{x}_ {k-1}\) 及其协方差 \(\hat{P}_ {k-1}\)，现在要根据 \(k\) 时刻的输入和观测数据，确定 \(x_k\) 的后验分布。这里以 \((\hat{\cdot})\) 表示后验分布，\((\bar{\cdot})\) 表示先验分布。 卡尔曼滤波器首先通过(1)中的运动方程确定 \(x_k\) 的先验分布，即预测过程。将 \(k-1\) 时刻的分布通过运动方程传递，对于均值有： \[\begin{align} \bar{x}_k &amp;=E[x_k]=E[A_kx_{k-1}+u_k+w_k]\\ &amp;=A_kE[x_{k-1}]+u_k+E[w_k]\\ &amp;=A_k\hat{x}_{k-1}+u_k \end{align}\] 对于协方差有： \[\begin{align} \bar{P}_k &amp;=E\left[(x_k-E[x_k])(x_k-E[x_k])^T\right]\\ &amp;=E\left[(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)\cdot(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)^T\right]\\ &amp;=A_kE\left[(x _{k-1}-\hat{x} _{k-1})\cdot(x _{k-1}-\hat{x} _{k-1})^T\right]A_k^T+E[w_kw_k^T]\\ &amp;=A_k\hat{P} _{k-1}A _{k-1}^T+Q _k \end{align}\] 由此可得预测过程： \[\begin{align} &amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(A_k\hat{x}_{k-1}+u_k,A_k\hat{P}_{k-1}A_k^T+Q_k\right)\tag{8}\\ \iff &amp;公式 (2),(3) \end{align}\] 另一方面，通过(1)中的观测方程，可以得到在某个状态下观测数据应该为： \[P(z_k\vert x_k)=N(C_kx_k,R)\tag{9}\] 由公式(7)可知，状态的后验概率分布由预测量以及测量量融合得到，这个融合的过程是两个高斯状的概率分布进行相乘，即 \(x_k\) 的后验概率： \[N(\hat{x}_k,\hat{P}_k)=N(C_kx_k,R)\cdot N(\bar{x}_k,\bar{P}_k)\tag{10}\] 比较该式指数部分即可得到更新过程： \[\begin{align} &amp; (x_k-\hat{x}_k)^T\hat{P}_k^{-1}(x_k-\hat{x}_k)=(z_k-C_kx_k)^TR^{-1}(z_k-C_kx_k)+(x_k-\bar{x}_k)^T\bar{P}_k^{-1}(x_k-\bar{x}_k)\\ \iff &amp; \left\{\begin{array}{l} 二次项系数:\quad \hat{P}_k^{-1}=C_k^TR^{-1}C_k+\bar{P}_k^{-1}\\ 一次项系数:\quad 2\hat{x}_k^T\hat{P}_k^{-1}x_k=2z_k^TR^{-1}C_kx_k+2\bar{x}_k^T\bar{P}_k^{-1}x_k \end{array}\right. \tag{11} \\ \iff &amp; \left\{\begin{array}{l} I=\hat{P}_kC_k^TR^{-1}C_k+\hat{P}_k\bar{P}_k^{-1}\\ \hat{x}_k=\hat{P}_kC_k^TR^{-1}z_k+\hat{P}_k\bar{P}_k^{-1}\bar{x}_k \end{array}\right. 令 K=\hat{P}_kC_k^TR^{-1} \\ \iff &amp; \left\{\begin{array}{l} I=KC_k+\hat{P}_k\bar{P}_k^{-1}\\ \hat{x}_k=Kz_k+(I-KC_k)\bar{x}_k \end{array}\right. \\ \iff &amp; 式 (4),(5),(6) \end{align}\] 对于更新过程，[3]中提出了另一种更加形象的证明方法。如图1所示，容易得到小车模型的运动方程： \[\begin{bmatrix} x _k\\ \dot{x} _k\\ \end{bmatrix}= \begin{bmatrix} 1 &amp; \Delta k\\ 0 &amp; 1\\ \end{bmatrix} \begin{bmatrix} x _{k-1}\\ \dot{x} _{k-1}\\ \end{bmatrix}+ \begin{bmatrix} \frac{(\Delta k)^2}{2}\\ \Delta k\\ \end{bmatrix}a_k \] 其中 \(a_k\) 为加速度输入量，对比式(1)也容易得到转移矩阵与控制矩阵。预测过程的证明方式与上述一致，下面简述其更新过程的证明，详见[3]。 如图1所示，红色区域代表预测量 \({x}_k\) 的概率分布高斯函数；蓝色代表测量量 \(z_k\) 概率分布的高斯函数，测量装置为左侧的 ToF 装置，单位为秒。绿色代表状态的后验概率分布 \(_k\)，由预测量的概率(先验)与测量量的概率(似然)相乘得到。由式(10)可知，两个高斯函数相乘还是高斯函数（但是是尺度变化的高斯函数，Scaled Gaussian[4]），上面的证明过程直接比较二次项与一次项，这里是直接写出新的高斯分布均值方差与另两个高斯分布均值方差的关系，本质上都是比较自变量前面的系数，非系数是不相等的，还有 Scaled 项。由此可得到更新过程。要注意的是，高斯分布相乘时，要注意单位的转换(即需要满足式(10)的单位形式)，这里的观察矩阵就是基于测量装置的测量单位(秒)与状态单位(米，米/秒)的转换值。 2. 扩展卡尔曼滤波 2.1. 非线性非高斯系统 通常系统（如 SLAM）的运动方程和观测方程是非线性函数，写成一般形式： \[\left\{\begin{array}{l} 运动方程:\quad x_k=f(x_{k-1},u_k)+w_k\\ 测量方程:\quad z_k=h(x_k)+v_k \end{array}\tag{12}\right.\] 扩展卡尔曼滤波估计非线性系统的状态与卡尔曼滤波类似，也分为两个步骤： 预测（Predict） 计算先验： \[\begin{align} \bar{x} _k&amp;=f(\hat{x} _{k-1},u _k) \tag{13}\\ \bar{P} _k&amp;=F\hat{P} _kF^T+Q _k \tag{14} \end{align}\] 更新（Update） 先计算卡尔曼增益： \[K_k=\bar{P}_kH_k^T(H_k\bar{P}_kH_k^T+R_k)^{-1} \tag{15}\] 再计算后验概率分布： \[\begin{align} \hat{x}_k &amp;=\bar{x}_k+K(z_k-h(\bar{x})) \tag{16}\\ \hat{P}_k &amp;=(I-KH_k)\bar{P}_k \tag{17} \end{align}\] 2.2. 通过 MAP/贝叶斯推断推导[1][2] 在某个点附件考虑运动方程与观测方程的一阶泰勒展开，只保留一阶项，即线性部分，然后按照线性系统进行推导。在 \(k\) 时刻，将运动方程和观测方程在 \(\hat{x}_ {k-1},\hat{P}_ {k-1}\) 处进行线性化： \[\left\{\begin{array}{l} 运动方程:\quad x_k\approx f(\hat{x}_{k-1},u_k)+F(x_{k-1}-\hat{x}_{k-1})+w_k\\ 测量方程:\quad z_k\approx h(\bar{x}_k)+H(x_k-\bar{x}_k)+v_k \end{array}\tag{18}\right.\] 其中 \(F=\left.\frac{\partial f}{\partial x_{k-1}}\right\arrowvert_{\hat{x}_ {k-1}}\)， \(H=\left.\frac{\partial h}{\partial x_k}\right\arrowvert_{\bar{x}_ k}\)。 由此可得预测过程: \[\begin{align} &amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(f(\hat{x}_{k-1},u_k),F\hat{P}_{k-1}F^T+Q_k\right)\tag{19}\\ \iff &amp;公式 (13),(14) \end{align}\] 另一方面，通过(18)中的观测方程，可以得到在某个状态下观测数据应该为： \[P(z_k\vert x_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R)\tag{20}\] 由贝叶斯公式，可得 \(x_k\) 的后验概率： \[N(\hat{x}_k,\hat{P}_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R))\cdot N(\bar{x}_k,\bar{P}_k)\tag{21}\] 类似卡尔曼推导过程，由此可得到更新过程式(15)，(16)，(17)。 [1] 高翔, 张涛, 颜沁睿, 刘毅, 视觉SLAM十四讲：从理论到实践, 电子工业出版社, 2017 [2] T. D. Barfoot. State Estimation for Robotics. Cambridge University Press, 2017. [3] Faragher, Ramsey. &quot;Understanding the basis of the Kalman filter via a simple and intuitive derivation.&quot; IEEE Signal processing magazine 29.5 (2012): 128-132. [4] Bromiley, Paul. &quot;Products and convolutions of Gaussian probability density functions.&quot; Tina-Vision Memo 3.4 (2003): 1.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KLT 光流算法详解]]></title>
    <url>%2FKLT%2F</url>
    <content type="text"><![CDATA[光流（Optical Flow）是物体在三维空间中的运动（运动场）在二维图像平面上的投影，由物体与相机的相对速度产生，反映了微小时间内物体对应的图像像素的运动方向和速度。 KLT 是基于光流原理的一种特征点跟踪算法，本文首先介绍光流原理，然后介绍 KLT 及相关 KLT 变种算法。 1. Optical Flow 光流法假设： 亮度恒定，图像中物体的像素亮度在连续帧之间不会发生变化； 短距离(短时)运动，相邻帧之间的时间足够短，物体运动较小； 空间一致性，相邻像素具有相似的运动； 记 \(I(x,y,t)\) 为 \(t\) 时刻像素点 \((x,y)\) 的像素值，那么根据前两个假设，可得到： \[I(x,y,t)=I(x+dx,y+dy,t+dt)\] 一阶泰勒展开： \[I(x+dx,y+dy,t+dt)=I(x,y,t)+\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt\] 由此可得： \[\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt=0 \iff \frac{\partial I}{\partial x}\frac{dx}{dt}+\frac{\partial I}{\partial y}\frac{dy}{dt}=-\frac{\partial I}{\partial t}\] 记 \(\left(\frac{dx}{dt},\frac{dy}{dt}\right)=(u,v)\)，即为所要求解的像素光流；\(\left(\frac{\partial I}{\partial x},\frac{\partial I}{\partial y}\right)=(I_x,I_y)\) 为像素灰度空间微分；\(\frac{\partial I}{\partial t}=I_x\) 为像素坐标点的时间灰度微分。整理成矩阵形式： \[\begin{bmatrix} I_x &amp;I_y\\ \end{bmatrix} \begin{bmatrix} u\\ v\\ \end{bmatrix}=-I_t \] 该式表示相同坐标位置的时间灰度微分是空间灰度微分与这个位置上相对于观察者的速度的乘积。由空间一致性假设，对于周围多个点，有： \[\begin{bmatrix} I_{x1} &amp;I_{y1}\\ I_{x2} &amp;I_{y2}\\ I_{x3} &amp;I_{y3}\\ \vdots &amp;\vdots \\ \end{bmatrix} \begin{bmatrix} u\\ v\\ \end{bmatrix}=- \begin{bmatrix} I_{t1}\\ I_{t2}\\ \vdots\\ \end{bmatrix} \iff A\vec{u}=b \] 这是标准的线性方程组，可用最小二乘法求解 \(\vec{u}=\left(A^ TA\right)^ {-1}A^ Tb\)，也可以迭代求解。这种方式得到的光流，称为 Lucas-Kanade 算法。 2. KLT KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。由光流假设，在很短时间 \(\tau\) 内，前后两帧图像满足： \[J(A\mathrm{x}+d)=I(\mathrm{x}), 其中 A=1+D=1+\begin{bmatrix} d_{xx} &amp; d_{xy}\\ d_{yx} &amp; d_{yy}\\ \end{bmatrix}\] 像素位移(displacement)向量满足仿射运动模型(Affine Motion) \(=Dx+d\)，其中 \(D\) 称为变形矩阵(Deformation Matrix)，\(d\) 称为位移向量(Displacement Vector)。\(D\) 表示两个像素窗口块运动后的变形量，所以当窗口较小时，会比较难估计。通常 \(D\) 可以用来衡量两个像素窗口的相似度，即衡量特征点有没有漂移。而对于光流跟踪量，一般只考虑平移模型(Translation Model)： \[J(\mathrm{x}+d)=I(\mathrm{x})\] 为了普遍性，我们用仿射运动模型来推到 KLT 算法原理。在像素窗口下，构造误差函数： \[\epsilon=\iint_W [J(A\mathrm{x}+d)-I(x)]^2 w(\mathrm{x})d\mathrm{x}\] 其中 \(w(\mathrm{x})\) 是权重函数，可定义为高斯形式。上式分别对变量 \(D\) 和 \(d\) 求导： \[\left\{\begin{array}{l} \frac{\partial \epsilon}{\partial D}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,\mathrm{x}^T\,w\,d\mathrm{x}&amp;=0\\ \frac{\partial \epsilon}{\partial d}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}&amp;=0\\ \end{array}\right.\] 其中 \(g=\left(\frac{\partial J}{\partial x},\frac{\partial J}{\partial y}\right)^ T\)。记光流 \(u=D\mathrm{x}+d\)，则对运动后的像素点进行泰勒展开： \[J(A\mathrm{x}+d)=J(x)+g^T(u)\] 仿射运动模型结果可见[1][5]，这里给出平移运动模型结果。令 \(D=0\)： \[\begin{align} &amp;\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}=0\\ \iff &amp;\iint_W[J(\mathrm{x})-I(\mathrm{x})]g\,w\,d\mathrm{x}=-\iint_Wg^T\,\mathrm{d}\,g\,w\,d\mathrm{x}=-\left[\iint_Wg\,g^T\,w\,d\mathrm{x}\right]\mathrm{d}\\ \iff &amp;Z\mathrm{d}=e \end{align}\] 其中 \(Z\) 是 \(2\times 2\) 矩阵，\(e\) 是 \(2\times 1\) 向量。这是线性方程组优化问题，当 \(Z\) 可逆时，这个方程可容易求解。因为推导过程用到了泰勒展开，所以只有当像素位移较小时，才成立。实际操作中，一般迭代式的来求解，每次用上次结果做初始化，进一步求解(In a Newton-Raphson Fasion)。 3. Pyramidal Iterative KLT 以上标准的迭代式 KLT 计算过程只在位移较小时成立（泰勒展开），所以需要更优的金字塔式迭代求解。图像金字塔有多重定义方式，这里定义： \[\begin{align} I^L(x,y)&amp;=\frac{1}{4}I^{L-1}(2x,2y)\\ &amp;+\frac{1}{8}\left(I^{L-1}(2x-1,2y)+I^{L-1}(2x+1,2y)+I^{L-1}(2x,2y-1)+I^{L-1}(2x,2y+1)\right)\\ &amp;+\frac{1}{16}\left(I^{L-1}(2x-1,2y-1)+I^{L-1}(2x+1,2y+1)+I^{L-1}(2x-1,2y+1)+I^{L-1}(2x+1,2y-1)\right) \end{align}\] 特征点跟踪有两个关键指标：准确性(accuracy)，以及鲁棒性(robustness)。大的窗口，对大的运动量比较鲁棒，但是为了提高准确性，又不得不减小窗口。所以窗口的选择需要权衡跟踪准确性与鲁棒性。金字塔迭代 KLT 则能有效弱化窗口的局限性。这里介绍平移模型下金字塔迭代 KLT 算法，仿射模型算法过程可见[1][5]。 定义金字塔迭代 KLT 算法的目标：图像 \(I\) 中某坐标点 \(\mathrm{x}\)，在图像 \(J\) 中找到其对应点 \(\mathrm{}\)。算法流程为： 建立图像金字塔：\(\{I^ L\}_ {L=0,...,L_m}\)，\(\{J^ L\}_ {L=0,...,L_m}\) 初始化光流在金字塔之间的传递值：\(g^ {L_m}=[g_x^ {L_m},g_y^ {L_m}]^ T=[0,0]^ T\) for \(L=L_m\) down to 0 with step of -1 计算图像 \(I^ L\) 中的 \(\mathrm{x}\) 坐标: \(\mathrm{x}^ L=[x,y]^ T=\mathrm{x}/2^ L\) 计算空间梯度矩阵 \(Z\) 初始化 KLT 迭代值：\(v^ 0=[0,0]^ T\) for \(k=1\) to \(K\) with step of 1 or until \(\Vert\eta^ k\Vert\) &lt; accuracy threshold 计算图像差矩阵 \(I^ L(\mathrm{x}^ L)-J^ L(\mathrm{x}^ L)=I^ L(x,y)-J^ L(x+g_x^ L+v_x^ {k-1},y+g_y^ L+v_y^ {k-1})\) 计算图像差矩阵 \(e_k\) 计算光流 \(\eta^ k=Z^ {-1}e_k\) 更新下次迭代的初值 \(v^ k=v^ {k-1}+\eta^ k\) end of for-loop on k 第 \(L\) 层金字塔下光流为：\(\mathrm{d}^ L=v^ K\) 初始化第 \(L-1\) 层金字塔的光流： \(g^ {L-1}=[g_x^ {L-1}, g_y^ {L-1}]^ T=2(g^ L+\mathrm{d}^ L)\) end of for-loop on L 最终的光流结果：\(\mathrm{d}=g^ 0+\mathrm{d}^ 0\) 对应的 \(J\) 上的坐标点为：\(\hat{\mathrm{x}}=\mathrm{x}+\mathrm{d}\) 4. Feature Selection 在特征点跟踪之前，特征点的选择也很重要，以上计算过程中，我们期望 \(Z\) 可逆，也就是其最小特征值要足够大。如果已经提取了角点，则可进一步做选择。因此特征点选择准则为： 计算图像每个像素(或已提取的角点)的 \(Z\) 矩阵，及其最小的特征值 \(\lambda_m\) 从所有 \(\lambda_m\) 中取最大值为 \(\lambda_{max}\) 保留 \(\lambda_m\) 大于一定百分比(10%) \(\lambda_{max}\) 的像素(角点) 在这些像素(角点)中，保留局部最大值 视计算能力，保留其中的子集 以上特征点提取的过程类似于 Harris 角点。要注意的是选择特征计算 \(Z\) 时，\(3\times3\) 窗口足够，但是跟踪时，一般大于 \(3\times3\)。 5. Dissimilarity 相似性度量决定该特征点是否已经漂移而不能使用了，即外点检测(Outlier Detection)，所以非常重要。相比于平移模型，仿射模型对特征点的相似性度量更有效果。在长距离跟踪下，相似性度量可能解决不了是否漂移的问题，但是好的相似性度量能从一开始就剔除漂移的特征点。此外，也可用其它更高层面的外点检测技术替代。 [1] Shi, Jianbo, and Carlo Tomasi. Good features to track. Cornell University, 1993. [2] Birchfield, Stan. &quot;Derivation of kanade-lucas-tomasi tracking equation.&quot; unpublished notes (1997). [3] Bouguet, J.-Y.. “Pyramidal implementation of the lucas kanade feature tracker.” (2000). [4] Suhr, Jae Kyu. &quot;Kanade-lucas-tomasi (klt) feature tracker.&quot; Computer Vision (EEE6503) (2009): 9-18. [5] Bouguet, Jean-Yves. &quot;Pyramidal implementation of the affine lucas kanade feature tracker description of the algorithm.&quot; Intel Corporation 5.1-10 (2001): 4.]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>tracking</tag>
        <tag>ADAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Visual Odometry Part I&II"]]></title>
    <url>%2F%5Bpaper_reading%5D-Visual_Odometry_Part_I_II%2F</url>
    <content type="text"><![CDATA[1. Overview of VO SFM(Structure from Motion) 是解决从一堆图片中将场景以及相机姿态进行 3-D 重建的问题，最后的场景以及相机姿态可以通过离线优化方法（bundle adjustment）来 refine。VO &amp; VSLAM 都属于 SFM 的特殊情况，SfM 处理的图像时间上可以是无序的，而 VO &amp; VSLAM 则要求图像时间上有序。VO 只关心轨迹的局部一致性，而 VSLAM 关心全局轨迹和地图的一致性。VO 可以作为 VSLAM 的一个模块，用于重建相机的增量运动，Bundle Adjustment 可以用来 refine 相机的轨迹。如果用户只对相机路径感兴趣，不需要环境地图，且需要较高的实时性，那么一般 VO 就能满足需求。 视觉里程计（VO）最早应用于 NASA 火星地面探测器，相比于车轮里程计的优势： 不受车轮打滑的影响； 不受拐弯影响，拐弯时左右轮速度不一样； 更加准确，相对位置误差大概在 0.1% 到 2%，可作为车轮里程计、GPS，IMU等其它测量装置的补充； 在某些领域是必须的，比如无法使用车轮里程计的无人机，GPS 失效的水下环境等； 根据视觉传感器数量，VO 可分为 Stereo VO，与 Monocular VO。当场景距离远远大于双目基线时，Stereo VO 也需要退化成 Monocular VO 来处理。 1.1. Stereo VO &amp; Monocular VO 特征点匹配可以通过特征跟踪（Feature Tracking）或特征检测（Feature Detect）再匹配两种方式实现。特征跟踪计算量小，但是容易漂移；特征检测再匹配计算量大，需要用 RANSAC 去除无匹配点，但是特征点不容易漂移。 Motion Estimation 可通过 3D-3D，3D-2D，2D-2D 三种方式实现。Stereo 系统可以获得每个点的深度信息，所以这三种方式都可以用来做相机的运动估计。实验表明，直接在原始的 2-D 点上进行相机运动的估计，更加准确（？存疑）。 之所以研究单目 VO，是因为当场景距离相机很远的时候（相对于双目的基线），双目就退化为单目了。单目 VO 中绝对深度（尺度）是未知的，刚开始两帧相机移动的距离通常设定为 1，之后的相对位姿都基于此。相关方法可分为： Feature-based Methods，用每一帧的特征点来估计运动。 Appearance-based Methods，用图像中所有的像素点或是子区域中的像素点来估计运动。 Hybrid Methods，结合以上两种形式。 第一种方法较好，运动估计用 five-point RANSAC 来求解。 1.2. Reducing the Drift 由于 VO 是一步步计算相机的运动轨迹然后作累加的，那么误差就有累积性，使得估计的运动轨迹会漂移。这可以用 Sliding Window(Windowed) Bundle Adjustment 局部优化方法来解决。也可以用 GPS 或 laser 或 IMU 融合来解决。Windowed Bundle Adjustment，是通过 m 个窗口下的信息来优化求解这 m 个相机位姿。 1.3. VO Versus V-SLAM V-SLAM 两大方法： Filtering Methods 概率法，以一定的概率分布融合所有图像信息； Keyframe Methods 关键帧法，使用全局 Bundle Adjustment 优化被选择的关键帧； VO 只关心相机轨迹的一致性，而 SLAM 关注轨迹与地图整体的一致性。SLAM 中两大问题是，检测 loop closure 的发生以及用这个约束来更好的优化当下的地图和轨迹。而 VO 只对历史中以往 n 个轨迹中的位姿进行优化（windowed bundle adjustment），这可以认为与 SLAM 中建立局部地图与轨迹是等价的。但是这两者的 philosophy 不同： VO 只关心局部轨迹的一致性，局部地图只是用来（在 bundle ajustment）更精确的估计局部轨迹； SLAM 关心整个地图的一致性，当然也包括轨迹，轨迹的精确性能使地图更加精确； VO 可以是 SLAM 的一个模块（相机运动轨迹的重建），SLAM 还需要一个闭环检测，以及一个全局的地图优化策略。V-SLAM 重建相机运动轨迹理论上比 VO 更精确（加入了更多的约束），但是不一定更鲁棒，因为闭环检测中的奇异值对地图的一致性有较大影响。此外 SLAM 更加复杂以及耗计算资源。VO 牺牲了全局一致性，来达到实时运行的目的，因为不需要记录所有的地图信息。 2. Formulation of the VO Problem 在时间 \(k\) 下，相机拍摄的图像集记为：\(I_{0:n}=\{I_0,...,I_k\}\)。相机在时间 \(k-1\) 与 \(k\) 的位姿转换矩阵为 \(T_{k,k-1}\in \mathbb{R}^{4\times 4}\)。VO 所要求解的问题就是 \(T=T_{1,0}T_{2,1}...T_{k,k-1}\)。由此可知 VO 是计算相邻帧的相机位姿，然后对之前 m 个位姿做一个局部优化从而估计更准确的轨迹。 大多数 VO 算法是基于特征点来估计运动的，特征点法的流程如图 1. 所示： Feature Detection(Extraction) and Matching/Feature Tracking 特征提取并与上一帧的特征进行匹配，或者直接用上一帧的特征在这一帧进行跟踪； Motion Estimation 在 \(k,k-1\) 帧之间求解 \(T_{k,k-1}\) 的过程，根据匹配的特征点对是 2D 还是 3D，运动估计可分为 3D-3D，3D-2D，2D-2D 三种方式实现； Local Optimization 在 \(k,k-m\) 帧用 Bundle Adjustment 迭代优化求解最优的局部轨迹； 本文会重点阐述 Camera Model[1]，Feature Detection and Matching[2]，Motion Estimation[1]，Robust Estimation[2]，Local Optimization[2]。 3. Camera Modeling and Calibration 相机模型及标定，另文详述。 4. Feature Detection and Matching/Feature Tracking 生成前后帧特征点的匹配对，有两种方法： feature tracking 用局部搜索的方法，较适用于相邻两帧视角变化不大的情况，会有漂移（drift）的现象； feature detection and matching 独立在每个图像上进行检测，然后用某种度量准则进行匹配。在视野变化较大的情况下，只能用这种方法； 4.1. Feature Tracking 主要采用 KLT（详见 KLT 算法详解）方法进行特征点跟踪。 4.2. Feature Detection and Matching 特征点包含特征检测子与特征描述子。一个好的特征点应该有如下性质： 可重复性(Repeatability)，不同图像下相同特征点可再次检测出； 可区别性(Distinctiveness)，不同特征点表达形式不一样，可以更好匹配； 高效率(Efficiency)，计算高效； 本地性(Locality)，特征仅与一小片图像区域有关； 定位准确(Localization Accuracy)，不同尺度下定位都要准确； 鲁棒性(Robustness)，对噪声，模糊，压缩有较好的鲁棒； 不变性(Invariance)，对光照(photometric)，旋转，尺度，投影畸变(geometric)有不变性； 4.2.1. Feature Detector 特征检测子（feature detector）的计算过程包含两步，首先将图像进行一个特征响应函数的变换，比如 Harris 中的 角点响应函数，SIFT 中的 DoG 变换；然后应用非极大值抑制，提取最小或最大值。 特征检测子可分为两类： 角点(corners) 角点检测子被定义为至少两个边缘相交的地方；角点计算快，定位精度高，但是区分度低，大尺度下定位精度低； 斑点(blobs) 斑点检测子被定义为一种与周围区域在亮度、颜色、纹理下不同的模式；区分度较高，但是速度较慢； 如图2. 所示，常用的角点检测子有 ORB 特征中的 FAST 关键点，Harris 角点等；常用的斑点检测子有 SIFT，SURF，CENSURE 等。 4.2.2. Feature Descriptor 有了特征检测子后，为了特征点匹配，还需要描述这个检测子，描述量称为特征描述子。描述子可分为以下几类： Appearance，检测子周围的像素信息 SSD 匹配，sum of squared difference，计算检测子周围像素亮度与其的误差和； NCC 匹配，normalized cross correlation，相比 SSD，有一定的光照不变性； Census Transform，将检测子周围的 patch 像素与其进行对比，合成 0,1 向量； Histogram of Local Gradient Orientations SIFT，光照，旋转，尺度，均具有不变性；不适用于角点，适用于斑点； Much Faster BRIEF，二进制描述子，用于 ORB；对于旋转和尺度有较强的区分性，并且提取以及比较速度都很快； 目前常用的 ORB 特征，采用的是 Oriented FAST 角点，以及 BRIEF 描述子。 4.2.3. Feature Matching 通过比较特征点中的描述子部分，来完成特征点的匹配。如果是 appearance 描述子，那么一般通过 SSD/NNC 来计算描述子之间的相似度，其它二进制描述子，可通过欧氏距离或汉明距离来度量。 基于相似性度量的特征匹配，最简单的就是暴力匹配，两组特征点挨个计算相似度。暴力匹配时间复杂度较高，通常我们采用快速近似最近邻算法（FLANN），也可以加入运动估计模型（通过 IMU 等装置获得的大致运动位姿）来缩小搜索范围。特殊的如果是双目系统，因为左右目图像都是矫正过的，所以左右目的特征点匹配可通过行矩阵搜索解决。 匹配结束后，我们还得进一步验证匹配的正确性，去除误匹配的情况。比如相互一致性验证，每个特征点只能匹配一个特征点。 实验表明特征点的分布也很影响匹配效果，特征应尽量均匀分布，可以将图像栅格化，然后对不同的栅格用不同的特征检测阈值即可，保证栅格之间特征数量相等。 5. Motion Estimation 5.1. 2D-2D 这种情况下特征点 \(f_{k-1},f_k\) 分别是在 2D 图像 \(I_{k-1},I_k\) 坐标系上。 对极约束推倒过程可详见这里。根据对极约束，可推导出同一 3D 点投影到两个相机视角图像下后，其坐标之间的关系： \[p_2^TK^{-T}t^{\wedge} RK^{-1}p_1=0\] 记本质矩阵(Essential Matrix)\(E=t^{\land} R\)，记基础矩阵(Fundamental Matrix)\(F=K^ {-T}EK^ {-1}\)。基础矩阵描述的是两幅图像对应点的像素坐标的关系；本质矩阵描述的是世界中的某点分别在两个相机坐标系下坐标的相对关系。 一般相机内参是已知的，所以我们求解本质矩阵。可采用五点法或者八点法来求解，五点法只能处理已知相机标定参数的情况，所以我们一般采用八点法来求解本质矩阵 \(E\)，大于八点即可用最小二乘求解线性方程。然后对本质矩阵进行奇异值分解，即可求出相机的位姿 \(R,t\)。 当选取的点共面时，基础矩阵的自由度下降，即出现退化的现象，这个时候需要同时求解单应矩阵\(H\)，选择重投影误差较小的那个作为最终的运动估计矩阵。 此外，还需计算当前运动的相对尺度，可由 3D 点的位置信息求解相对尺度。绝对尺度的求解需要三角化求解。 总结过程如下： 得到新的当前帧 \(I_K\); 提取当前帧的特征点，并与上一帧的特征进行匹配； 根据匹配的特征点对，计算本质矩阵\(E\)； 奇异值分解本质矩阵，得到相机运动 \(R_K,t_k\)； 该相邻帧的相机运动信息与之前相机运动信息进行累计； 重复 1.； 5.2. 3D-2D 这种情况下，特征点 \(f_{k-1}\) 是 3D 坐标点，\(f_k\) 是其投影到 2D 图像 \(I_K\) 上的匹配点。对于单目的情况，\(f_{k-1}\) 需要从相邻的前面帧中（比如 \(I_{k-2},I_{k-1}\)）三角化出 3D 坐标，然后与当前帧进行匹配，至少需要三帧的视角。3D-2D 比 3D-3D 更加精确，因为 3D-3D 直接优化相机运动，没有优化投影的过程。 该问题也称为 PnP(Perspective from n Points)。PnP 问题有很多种求解方法： P3P 只是用 3 个点对进行求解，容易受误匹配的影响； 直接线性变换 需要 6 对匹配点才能求解，如果大于 6 对，则可用 SVD 等方法求线性方程的最小二乘解； EPnP UPnP 非线性优化(Bundle Adjustment) 记 \(p_{k-1}^ i\) 为 \(k-1\) 时刻下第 \(i\) 个特征点在相机坐标系下的坐标，定义重投影的误差项： \[\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert uv^i_k-K \, T_{k,k-1} \, p_{k-1}^i \right\Vert^2\] 总结过程如下： 初始化，在 \(I_{k-2},I_{k-1}\) 两张图里提取特征并匹配，三角花得到特征点的 3D 坐标； 在 \(I_k\) 图像中提取特征点，并与上一帧的特征进行匹配； 用 PnP 求解相机运动； 在 \(I_{k-1},I_{k}\) 中三角化所有特征点； 重复 2.； 5.3. 3D-3D 这种情况下特征点都是 3D 坐标点，都需要三角花得到，可以使用一个立体视觉系统。 已知两组匹配好的 3D 点，可以用 ICP(Iterative Closest Point) 来求解位姿。ICP 有两种求解方式： 线性求解 非线性优化(类似 Bundle Adjustment) 定义重投影的误差项： \[\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert p_{k}^i - T_{k,k-1} \, p_{k-1}^i \right\Vert^2\] ICP 问题存在唯一解或无穷多解的情况，所以非线性优化时，只要找到极小值，那一定是全局最优解，这也意味着 ICP 非线性优化时可以任意选定初始值。 在匹配已知的情况下，ICP 问题是有解析解的。不过如果有些特征点观察不到深度，那么可以混合着使用 PnP 和 ICP 优化：对于深度已知的特征点，建模 3D-3D 误差，对于深度未知的特征点，建模 3D-2D 的重投影误差。两个误差项，用非线性优化求解。 5.4. Triangulation and Keyframe Selection 对于 stereo camera， 3D-2D 比 3D-3D 更准确；3D-2D 比 2D-2D 计算更快，前者是 P3P 问题，后者则至少需要 5 个点。当场景中物体相比基线很大时，那么立体视觉系统就失效了，这时候用单目视觉系统比较靠谱。 对于 monocular camera，2D-2D 比 3D-2D 看样子更好，因为避免了三角测量；然后实际中，3D-2D 用得更多，因为数据关联更快。 当两帧之间相隔很短时间时，可以认为基线非常小，这种情况，获得的深度信息不确定性很高，所以需要选择某些 keyframes 来计算。 6. Robust Estimation/Outlier Rejection 匹配的特征点可能因为噪音、遮挡、模糊、视角变化、光照变化等原因成为外点（outliers），这时候该匹配对对运动估计来说就是个外点，估计的时候应该想办法去除掉。 RANSAC 目前已是在含有噪声的数据中进行模型估计的标准方法。其思想是随机选取一些数据进行建模，涵盖数据最多的模型即被选择是最终模型。对于相机运动估计来说，模型就是相机的运动 \(R,t\)，数据就是特征匹配对。RANSAC 流程为： 初始化，记 A 为特征点对集； 从 A 中随机选取一些点对 s； 用 s 估计运动模型； 计算所有的点对与这个模型的距离误差，可使用 point-to-epipolar 距离或是 directional 误差(Sampson distance)； 统计距离误差小于一定阈值的点对的数量，并存储标记这些内点(inliers)； 重复 2.，直到达到最大迭代次数； 选取数量最多的内点点对集，用这些点估计最终模型； 为保证得到正确解，迭代次数要求： \[N=\frac{log(1-p)}{log(1-(1-\epsilon)^s)}\] 其中，\(p\) 表示得到正确解的概率，\(\epsilon\) 表示外点的百分比，\(s\) 表示每次模型估计取出的点数。如图 3. 所示，选出的点数越少，迭代次数就可以越少。这个角度来讲，五点法比八点法有优势，但是五点法的前提是相机都是标定过的。不过不考虑速度的话，还是选择更多的点，因为可以平滑噪声。 7. Local Optimization 每次估计的相机运动都有误差，随着运动的累计，误差也会累计。这就要求做局部最优化，消除轨迹的漂移。优化方式有 Pose-Graph Optimization（需要回环检测） 以及 Windowed Bundle Adjustment 两种，这里主要介绍 BA。定义误差函数： \[\xi=\mathop{\arg\min}\limits_{X^i,C_k} \sum_{i,k} \left\Vert uv_{k}^i - g(X^i,C_k) \right\Vert^2\] 其中 \(X^i\) 为世界坐标系下特征点的 3D 坐标，\(C_k = T_{1,0}...T_{k,k-1}\)，\(g(X^i,C_k)\)为特征点投影到图像的映射函数。该非线性问题可用 Newton-Gauss 或 LM 法解决。为了加速运算，如果 3D 特征点是准确的(如立体视觉获得的)，那么可以固定特征点的 3D 量，只优化相机的轨迹。 [1] Scaramuzza, Davide, and Friedrich Fraundorfer. &quot;Visual odometry [tutorial].&quot; IEEE robotics &amp; automation magazine 18.4 (2011): 80-92. [2] Fraundorfer, Friedrich, and Davide Scaramuzza. &quot;Visual odometry: Part ii: Matching, robustness, optimization, and applications.&quot; IEEE Robotics &amp; Automation Magazine 19.2 (2012): 78-90.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>VO</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving"]]></title>
    <url>%2F%5Bpaper_reading%5D-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving%2F</url>
    <content type="text"><![CDATA[本文[1]结合 Semantic SLAM 与 Learning-based 3D Det 技术，提出了一种用于自动驾驶的动态目标定位与本车状态估计的方法。本文系统性较强，集成了较多成熟的模块，对工程应用也有较强的指导意义。 如图 1. 所示，整个系统框架由三部分组成： 2D object detection and viewpoint classification，目标位姿通过 2D-3D 约束求解出来； feature extraction and matching，双目及前后帧的特征提取与匹配； ego-motion and object tracking，将语义信息及特征量加入到优化中，并且加入车辆动力学约束以获得平滑的运动估计。 1. Viewpoint Classification and 3D Box Inference 1.1. Viewpoint Classification 选用 Faster R-CNN 作为 2D 检测框架，在此基础上，加入车辆视野（viewpoint）分类分支。由图 2. 所示，水平视野分为八类，垂直视野分为两类，总共 16 类。 1.2. 3D Box Inference Based on Viewpoint 网络输出图像 2D 框以及目标车辆的视野类别（viewpoint），此时我们假设： 2D 框准确； 每种车辆的尺寸相同； 2D 框能紧密包围 3D 框； 在以上假设条件下，我们可以求得 3D 框，该 3D 框作为后续优化的初始值。约束方程的表示在论文中比较晦涩，在这里我做细致的推倒。 3D 框可表示为 \(\{x,y,z,\theta,w,h,l\}\)，其中 \(\{w,h,l\}\) 分别对应 \({x,y,z}\) 维度。如图 2.(b) 所示，这个视角下，四个 3D 框的顶点，可得四个约束方程。推倒过程为： \[\require{cancel} \begin{bmatrix} u_{min}\\ v_1\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{1}^{cam}\\ y_{1}^{cam}\\ z_{1}^{cam}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{1}^{obj}\\ y_{1}^{obj}\\ z_{1}^{obj}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} \frac{w}{2}\\ \frac{h}{2}\\ \frac{l}{2}\\ \end{bmatrix}\] 其中 \(K\) 为相机内参，做归一化处理消去；\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)^{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，②，③，④ 点都可以由此获得： \[\left\{\begin{array}{l} \require{cancel} \begin{bmatrix} u_{min}\\ v_1\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{1}^{cam}\\ y_{1}^{cam}\\ z_{1}^{cam}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{1}^{obj}\\ y_{1}^{obj}\\ z_{1}^{obj}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} \frac{w}{2}\\ \frac{h}{2}\\ \frac{l}{2}\\ \end{bmatrix}\\ \begin{bmatrix} u_{max}\\ v_2\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{2}^{cam}\\ y_{2}^{cam}\\ z_{2}^{cam}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{2}^{obj}\\ y_{2}^{obj}\\ z_{2}^{obj}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} -\frac{w}{2}\\ \frac{h}{2}\\ -\frac{l}{2}\\ \end{bmatrix}\\ \begin{bmatrix} u_3\\ v_{min}\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{3}^{cam}\\ y_{3}^{cam}\\ z_{3}^{cam}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{3}^{obj}\\ y_{3}^{obj}\\ z_{3}^{obj}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} \frac{w}{2}\\ -\frac{h}{2}\\ -\frac{l}{2}\\ \end{bmatrix}\\ \begin{bmatrix} u_4\\ v_{max}\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{4}^{cam}\\ y_{4}^{cam}\\ z_{4}^{cam}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{4}^{obj}\\ y_{4}^{obj}\\ z_{4}^{obj}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} -\frac{w}{2}\\ \frac{h}{2}\\ \frac{l}{2}\\ \end{bmatrix} \end{array}\right.\] 将 \(z\) 方向归一化后，进一步得到最终的四个约束式子： \[\left\{\begin{array}{l} u_{min}=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\ u_{max}=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ v_{min}=(y- \frac{h}{2}) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ v_{max}=(y+ \frac{h}{2}) / (z+ \frac{w}{2} sin\theta + \frac{l}{2} cos\theta) \end{array}\right.\] 以上四个方程可以闭式求解 3D 框 \({x,y,z,}\)。该方法将 3D 框的回归求解分解成了 2D 框回归，视野角分类以及解方程组的过程，强依赖于前面的三点假设，实际情况 3D 框与 2D 框不会贴的很紧。这个 3D 框结果只用来作后续的特征提取区域及最大后验概率估计的初始化。 2. Feature Extraction and Matching 这一部分做的是左右目及前后帧特征提取及匹配。选用 ORB 特征，目标区域由投影到图像的 3D 框确定。 目标区域内左右目的立体匹配 由于已知目标的距离及尺寸，所以只需要在一定小范围内进行特征点的行搜索匹配。 目标及背景区域下前后帧的时序匹配 首先进行 2D 框的关联，2D 框经过相机旋转补偿后，最小化关联框的中心点距离及框形状相似度值。然后在关联上的目标框区域以及背景区域里，分别作 ORB 特征的匹配，异常值在 RANSAC 下通过基础矩阵测试去除。 3. Ego-motion and Object Tracking 首先进行本车运动状态估计，可在传统 SLAM 框架下做，不同的是将动态障碍物中的特征点去除。有了本车的位姿后，再估计动态障碍物的运动状态。文中符号定义较为复杂，这里不做赘述。 3.1. Ego-motion Tracking 给定左目前后帧背景区域特征点的观测，本车状态估计可以通过极大似然估计（Maximum Likelihood Estimation）得到。MLE 可以转化为非线性最小二乘问题，也就是 Bundle Adjustment 过程，这是典型的 SLAM 问题。文中给出的误差方程： 需要求解的是本车位姿以及背景特征点坐标，这是后验概率，可转为似然函数求解，然后转化为非线性优化问题。可参考《视觉 SLAM 十四讲》(107-108)来理解。 3.2. Semantic Object Tracking 得到本车相机的位姿后，运动目标的状态估计可以通过最大后验概率估计（Maximum-a-posterior, MAP）得到。类似的，可转为非线性优化问题进行求解，联合优化每个车辆的位姿，尺寸，速度，方向盘转角，所有特征点 3D 位置。有四个 loss 项： \(r_Z,r_P,r_M,r_S\) 分别代表： Sparse Feature Observation 目标上的特征点重投影到左右目图像的误差，注意有左右目两个误差项； Semantic 3D Object Measurement 3D 框投影到图像上与 2D 框的尺寸约束投影误差，即 1.2 节中的形式，区别在车辆尺寸与位姿作为了优化项； Vehicle Motion Model 对于车辆，前后时刻的状态要有连续性，即误差最小； Point Cloud Alignment 为了减少 3D 框的整体偏移，引入特征点到 3D 观察面的最小距离误差； 这里只对车辆运动模型进行分析，其它几项基本在前文已经有描述或者比较常识化，就不展开，具体公式可参见论文。 由实验可知 Sparse Feature Observation 与 Point Cloud Alignment 对性能提升较明显，Motion Model 对困难情景性能才有提升。 3.2.1. Vehicle Motion Model [2] 中介绍了前转向车的两种模型：运动学模型(Kinematic Bicycle Model)，以及更复杂的动力学模型(Dynamic Bicycle Model)。运动学模型假设车辆不存在滑动，这在大多数情况下都是满足的，所以我们只介绍运动学模型。 如图 3. 所示，前后轮无滑动的约束下，可得方程组： \[\left\{\begin{array}{rl} \dot{x}_fsin(\theta+\delta)-\dot{y}_fcos(\theta+\delta)=&amp;0\\ \dot{x}sin(\theta)-\dot{y}cos(\theta)=&amp;0\\ x+Lcos(\theta)=&amp;x_f \quad\Rightarrow \quad \dot{x}-\dot{\theta}Lsin(\theta)=\dot{x}_f\\ y+Lsin(\theta)=&amp;y_f \quad\Rightarrow \quad \dot{y}+\dot{\theta}Lcos(\theta)=\dot{y}_f \end{array}\right.\] 由此可得到: \[\dot{x}sin(\theta+\delta)-\dot{y}cos(\theta+\delta)-\dot{\theta}Lcos(\delta)=0\] 用 \(\left(v \cdot cos(\theta),v\cdot sin(\theta)\right)\) 代替 \((\dot{x},\dot{y})\) 可得： \[\dot{\theta}=\frac{tan(\delta)}{L}\cdot v\] 最终可整理成矩阵形式： \[ \begin{bmatrix} \dot{x}\\ \dot{y}\\ \dot{\theta}\\ \dot{\delta}\\ \dot{v}\\ \end{bmatrix}= \begin{bmatrix} 0 &amp;0 &amp;0 &amp;0 &amp;cos(\theta)\\ 0 &amp;0 &amp;0 &amp;0 &amp;sin(\theta)\\ 0 &amp;0 &amp;0 &amp;0 &amp;\frac{tan(\delta)}{L}\\ 0 &amp;0 &amp;0 &amp;0 &amp;0\\ 0 &amp;0 &amp;0 &amp;0 &amp;0\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \theta\\ \delta\\ v\\ \end{bmatrix}+ \begin{bmatrix} 0 &amp;0\\ 0 &amp;0\\ 0 &amp;0\\ 1 &amp;0\\ 0 &amp;1\\ \end{bmatrix} \begin{bmatrix} \gamma\\ \alpha\\ \end{bmatrix} \] 其中 \(L\) 为车辆参数。观测量有： \((x,y,\theta)\) 为车辆的位置及朝向角； \(\delta\) 为方向盘/车轮转角； \(v\) 为车辆速度； 控制量有： \(\gamma\) 为方向盘角度比率； \(\alpha\) 为加速度； 本文的目的是要约束车辆时序上运动(速度及朝向)的平滑一致性，令控制量 \(\gamma,\alpha\) 为 0，然后可得状态量在相邻时刻的关系应满足： \[\left\{\begin{array}{l} \hat{x}^t=x^{t-1}+cos(\theta^{t-1})v^{t-1}\Delta t\\ \hat{y}^t=y^{t-1}+sin(\theta^{t-1})v^{t-1}\Delta t\\ \hat{\theta}^t=\theta^{t-1}+\frac{tan(\delta^{t-1})}{L}v^{t-1}\Delta t\\ \hat{\delta}^t=\delta^{t-1}\\ \hat{v}^t=v^{t-1} \end{array}\right.\] 由此可整理成论文中矩阵的形式及误差项： [1] Li, Peiliang, and Tong Qin. &quot;Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018. [2] Gu, Tianyu. Improved trajectory planning for on-road self-driving vehicles via combined graph search, optimization &amp; topology analysis. Diss. Carnegie Mellon University, 2017.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Stereo R-CNN based 3D Object Detection for Autonomous Driving"]]></title>
    <url>%2F%5Bpaper_reading%5D-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving%2F</url>
    <content type="text"><![CDATA[Learning 方法有什么致命缺点吗？我认为目前 Learning 方法还存在的较为棘手的问题是，有时候结果会出现非常低级的错误，或是说不可思议不合常理的 cornercases。所以我认为一个工程系统或是一个鲁棒的算法系统，在 Learning 之后做一个基于常理（如 geometry 约束或专家系统）的验证，能有效抑制这个问题。本文就是一个比较好的 learning+geometry 想结合的方法。 本文[1]基于图像语义及几何信息，通过 3D 目标的稀疏与密集约束，提出了一种准确的 3D 目标检测方法。根据输入数据的类型，作者将 3D 检测分为三大类： LiDAR-based，近期被研究的较多，基本是自动驾驶所必须的； Monocular-based，低成本方案； Stereo-based，相比 Monocular-based，有优势，但是研究较少； 本文就是 Stereo-based 3D 检测方案。不同于一般的 rgb+depth 作为输入的方案，本文直接将左右目 rgb 作为输入，没有显示地 depth 生成过程。工程上来说，这也极大地缩短了 3D Detection 的时延(latency)。 本文方法如图 1 所示，主要有三部分组成： Network，又有三部分构成： Stereo RPN Module，输出左右图的 RoI； Classification and Regression branches，输出目标类别，朝向，尺寸； Keypoint branch，输出左目目标的关键点； Sparse constraints，3D 框-2D 框的稀疏约束； Dense constraints，准确定位的关键模块； 1. Stereo R-CNN Network Stereo R-CNN 是在 Faster R-CNN 基础上，同时检测与关联左右目图像 2D 框的微小差异。 1.1. Stereo RPN 在传统 RPN 网络的基础上，本文先对左右图做 paramid features 提取，然后将不同尺度的特征 concatenate 一起，进入 RPN 网络。 关键的一点是 objectness classification与 stereo box regression 的真值框定义不一样。如图 2 所示， 对于 objectness classification，真值框定义为左右目真值框的外接合并（union GT box），一个 anchor 在与真值框的交并比（Intersection-over-Union）大于 0.7 时标记为正样本，小于 0.3 时标记为负样本。分类任务的候选框包含了左右目真值框区域的信息。 对于 stereo box regression，真值框定义为左右目分别的真值框。待回归的参数定义为 \([u, w, u', w', v, h]\)，分别为左目的水平位置及宽，右目的水平位置及宽，垂直位置及高。因为输入为矫正过的左右目图像，所以可认为左右目的垂直方向上已经对齐。 每个左右目的 proposal 都是通过同一个 anchor 产生的，自然左右目的 proposal 是关联的。通过 NMS 后，保留左右目都还存在的 proposal 关联对，取前 2000 个用于训练，测试时取前 300 个。 1.2. Stereo R-CNN 网络头包含两大部分： Stereo Regression 左右目的 proposal 关联对，分别在左右目的 feature 上进行 RoI Align 的操作，然后 concatenate 输入到全链接层。左右目的 RoI 对与真值框的 IoU 均大于 0.5 时定位正样本，左右目的 RoI 对与真值框的 IoU 有一个小于 0.5 且大于 0.1，则定位负样本。用四个分支分别预测： object class； stereo bounding boxes，与 stereo rpn 中一致，左右目的高度已对齐； dimension，先统计平均的尺寸，然后预测相对量； viewpoint angle，如图 3 所示，\(\theta\) 为相机坐标系下的朝向角，\(\beta\) 为相机中心点下的方位角(azimuth)，这三个目标在相机视野下是一样的，所以我们回归的量是视野角(viewpoint angle) \(\alpha=\theta+\beta\)，其中 \(\beta=arctan\left(-\frac{x}{z} \right) \)。并且为了连续性，回归量为 \([sin\,\alpha,cos\,\alpha]\)。 Keypoint Prediction 如图 4 所示，考虑 3D 框底部矩形的四个关键点，投影到图像平面后，最多只有一个关键点会在图像 2D 矩形框内。对左目图像进行关键点预测，类似 Mask R-CNN，在 6×28×28 的基础上，因为关键点只有图像坐标 u 方向才提供了额外的信息，所以对每列进行累加，最终输出 6×28 的向量。前 4 个通道代表每个关键点作为 perspective keypoint 投影到该 u 坐标下的概率；后 2 个通道代表该 u 坐标是左右边缘关键点(boundary keypoints)的概率。为了找出 perspective keypoint，softmax 应用于 4×28 的输出上；为了找出左右边缘关键点，softmax 分别应用于后两个 1×28 的输出上。训练的时候，4×28 中只有一个被赋予 perspective keypoint，忽略没有 perspective keypoint 的情况（遮挡等），然后最小化 cross-entropy loss；对于边缘关键点，则分别最小化 1×28 维度上的 cross-entropy loss，前景中也会被赋予边缘关键点。 2. 3D Box Estimation 已知关键点，2D 框，尺寸，朝向角，我们可以求解出 3D 框 \(\{x,y,z,\theta\}\)。求解目标是最小化 3D 框投影到 2D 框以及关键点的误差。如图 5 所示，已知 7 个观测量 \(z = \{u_l,v_t,u_r,v_b,u_l',u_r',u_p\}\)，分别代表左目 2D 框的左上坐标，右下坐标，右目 2D 框的左右 u 方向坐标，以及 perspective keypoint 的 u 方向坐标。在图 5 的情况下（其它视角下，注意符号变化），左上点投影关系如下： \[\require{cancel} \begin{bmatrix} u_l\\ v_t\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{cam}^{tl}\\ y_{cam}^{tl}\\ z_{cam}^{tl}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{obj}^{tl}\\ y_{obj}^{tl}\\ z_{obj}^{tl}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} -\frac{w}{2}\\ -\frac{h}{2}\\ -\frac{l}{2}\\ \end{bmatrix}\] 其中 \(K\) 为相机内参，\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)_{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，右下点为： \[\require{cancel} \begin{bmatrix} u_r\\ v_b\\ 1\\ \end{bmatrix}=K\cdot \begin{bmatrix} x_{cam}^{tl}\\ y_{cam}^{tl}\\ z_{cam}^{tl}\\ \end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot \begin{bmatrix} x_{obj}^{tl}\\ y_{obj}^{tl}\\ z_{obj}^{tl}\\ \end{bmatrix}=\begin{bmatrix} x\\ y\\ z\\ \end{bmatrix}+ \begin{bmatrix} cos\theta &amp; 0 &amp;sin\theta\\ 0 &amp; 1 &amp; 0\\ -sin\theta &amp; 0 &amp; cos\theta\\ \end{bmatrix} \cdot \begin{bmatrix} \frac{w}{2}\\ \frac{h}{2}\\ -\frac{l}{2}\\ \end{bmatrix}\] 右目两个边缘点以及 perspective keypoint 点也可同样得到，由此可整理出 7 个方程组（论文中第一个公式符号有错）： \[\left\{\begin{array}{l} u_l=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ v_t=(y- \frac{h}{2}) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ u_r=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\ v_b=(y+ \frac{h}{2}) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\ u&#39;_l=(x-b- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ u&#39;_r=(x-b+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\ u_p=(x+ \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\ \end{array}\right.\] 其中 \(b\) 为双目的基线长(baseline)。以上方程组可用 Gauss-Newton 法求解。 3. Dense 3D Box Alignment 以上得到的目标 3D 位置是 object-level 求解得到的，利用像素信息，还可以进行优化精确求解。首先在图像 2D 目标框内扣取一块 RoI，要使 RoI 能较为确定的在目标上，扣取方式定义为： 目标一半以下区域； perspective keypoint 与边缘关键点包围区域； 关键点预测的时候只预测了 u 方向的坐标，边缘关键点无 v 方向的信息，看起来会使某些背景像素被划入为目标像素，更好的方法是加入 instance segmentation 信息。定义误差函数为： \[E=\sum_{i=0}^N e_i=\sum_{i=0}^N \left\| I_l(u_i,v_i)-I_r(u_i-\frac{b}{z+\Delta z_i},v_i)\right\|\] 可由三角测量关系 \(z=\) 推出。上式中，\(z_i=z_i-z\) 表示某个像素点 \(i\) 所对应的 3D 点与目标中心点之间的距离。最小化总误差即可求得最优的中心点距离 \(z\)。优化过程可以用 coarse-to-fine 的策略，先以 0.5m 的精度找 50 步，再以 0.05m 的精度找 20 次。 这个 dense alignment 模块是独立的，可以应用到任意的左右目 3D 检测的后处理中。因为目标 RoI 是物理约束，所以这个方法避免了深度估计中不连续、病态的问题，且对光照是鲁棒的，因为每个像素都会对估计起作用。这里，本文只做了中心点的 align，尺寸，甚至朝向角是否能加入优化? 4. Other Details [1] Li, Peiliang, Xiaozhi Chen, and Shaojie Shen. &quot;Stereo R-CNN based 3D Object Detection for Autonomous Driving.&quot; arXiv preprint arXiv:1902.09738 (2019).]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT Metrics in Academia and Industry]]></title>
    <url>%2FMOT-Metrics-in-Academia-and-Industry%2F</url>
    <content type="text"><![CDATA[MOT 是一个比较基本的技术模块，在视频监控中，常用于行人行为分析、姿态估计等任务的前序模块；在自动驾驶中，MOT 是动态目标状态估计的重要环节。在学术界，MOT 算法性能的评价准则已经较为完善，其指标主要关注，尽可能地覆盖所有性能维度，以及指标的简洁性（上一篇有较多介绍，the CLEAR MOT Metrics）。而工业界则尚无统一的标准，实际的指标需求情况也比学术界复杂。 指标的计算过程可由三部分组成，真值过滤(Filter)，匹配构建(Establishing Correspondences)与指标计算(Calculating Metrics)。其中真值过滤，更多的是工程细节，学术界没有文章对这一部分进行讨论研究。本文首先介绍学术界各评价指标详情，然后讨论工业界需要的评价指标又是怎样的。 1. Metrics in Academia 在学术界，因为数据集质量较高，噪声相对较小，匹配构建中距离的度量偏向于严格且简单的方式。对于区域(框)跟踪器，采用重叠区域来度量；对于点跟踪器，采用中心点的欧式距离来度量。指标汇总如下： A. 检测指标 \(\lozenge\) 准确性(Accuracy) Recall = \(\frac{TP}{GT}\)； Precision = \(\frac{TP}{TP+FP}\)； FAF/FPPI[1][2] ，Average False Alarms per Frame；False Positive Per Image; MODA[3]，Multipe Object Detection Precision，整合了 FN 与 FP，设 \(c_m, c_f\) 分别为 FN，FP 的权重： \[MODA=1-\frac{\sum_{t=1}^{N_frames}(c_m(fn_t)+c_f(fp_t))}{\sum_{t=1}^{N_frames}gt_t}\] \(\lozenge\) 精确性(Precision) MODP[3]，Multiple Object Detection Accuracy， \[MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; dist}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}\] 其中 \(N_{mapped}^{(t)}\) 为第 \(t\) 帧匹配的目标数；\(dist\) 为距离度量方法，如框的交并比度量法： \[Mapped Overlap Ratio = \frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|}\] B. 跟踪指标 \(\lozenge\) 准确性(Accuracy) IDS[4]，ID switch，a tracked target changes its ID with another target(预测关联真值)； MOTA[5]，Multiple Object Tracking Accuracy，整合了 FN，FP，ID-Switch： \[MOTA=1-\frac{\sum_{t=1}^{N_{frames}} \;\; (c_m(fn_t)+c_f(fp_t)+c_s(ID-SWITCHES_t))}{\sum_{t=1}^{N_{frames}} \;\; gt_t}\] 其中权重方程一般可设为：\(c_m=c_f=1, \quad c_s=log_{10}\)； \(\lozenge\) 精确性(Precision) MOTP[5]，Multiple Object Tracking Precision， \[MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; \left(\frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|} \right)}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}\] TDE[6]，Distance between the ground-truth annotation and the tracking result；像素级别的误差计算，适用于人群跟踪； OSPA[7][8]，Optimal Subpattern assignment，由定位 (localization) 误差及基数 (cardinality) 误差构成，对于第 \(t\) 帧： \[e^t=\left[\frac{1}{n^t}\left( \mathop{\min}_{\pi\in\Pi_n} \sum_{i=1}^{m^t} d^{(c)}(x_i^t,y_{\pi(i)}^t)^p + (n^t-m^t)\cdot c^p \right) \right]^{1/p}\] 其中，\(n^t\) 为目标真值与算法输出中数量较大者。\(\Pi_n\) 为从 \(n^t\) 中取出的 \(m\) 个目标。\(p\) 为距离指数范数。其中定位截断误差为： \[d^{(c)}(x_i^t,y_{\pi(i)}^t) = \mathop{\min}\left(c,d(x_i^t,y_{\pi(i)}^t)\right)\] \(c\) 为截断参数。定位误差又由距离误差和标签误差组成： \[d(x_i^t,y_{\pi(i)}^t=\parallel x_i^t-y_{\pi(i)}^t\parallel + \alpha \; \bar{\delta}(l_x, l_y)\] 其中 \(\alpha\in[0,c]\)，为标签误差的权重系数。如果 \(l_x=l_y\)，\(\bar{\delta}(l_x, l_y)=0\)，否则 \(\bar{\delta}(l_x, l_y)=1\). \(\lozenge\) 完整性(Completeness) MT[9]，Mostly Tracked，真值轨迹长度被跟踪大于80%的比例； ML[9]，Mostly Lost，真值轨迹长度被跟踪小于20%的比例； PT[9]，Partially Tracked，\(1-MT-ML\); FM[9]，Fragments，ID of a target changed along a GT trajectory, or no ID(真值关联预测)； \(\lozenge\) 鲁棒性(Robustne) RS[10]，Recover from short term occlusion; RL[10]，Recover from long term occlusion; 2. Metrics in Industry 工业界的数据噪声较大，传感器配置也比较多样，不同的产品（传感器+算法），对 MOT 性能维度要求也不一样。更重要的是，评价指标应该从功能层面进行定义，在模块层面 (MOT) 进行调整及细化。可以说，工业界是以学术界为基础来设计 MOT 指标的，不同的产品没有统一的标准，但有比较通用的设计准则。 这里以自动驾驶/辅助驾驶中动态目标状态估计模块为例，模块详细分析日后再写。该模块的基本输入为： 传感器数据，可以是图像，激光等； 自定位系统，可以是基于视觉的 VO，基于视觉-IMU 的 VINS等； 其中自定位系统能使目标状态估计在世界坐标系（惯性系）下优化，否则只能在本体（ego）非惯性系下优化，会减少一些约束量。该功能的基本输出为： 位置，本体坐标系下目标的三维位置，\(x,y,z\)； 尺寸，目标的物理尺寸大小，包括立方体的长宽高；或者图像坐标系下的像素大小；或者图像/点云下目标的 mask，即分割后的目标； 朝向，一般只考虑目标的航向角； 速度，本体坐标系或世界坐标系下的三维速度，一般只考虑航向平面的速度； 其中朝向是非必须项，有了朝向后，能更有效地进行状态优化。该模块的子模块有（注意，MOT 只包含前三者）： 检测(Detection)，进行多目标检测； 跟踪(Tracking)，根据上一帧结果，进行多目标跟踪； 数据关联(Association)，检测结果与跟踪结果的融合，出目标的 tracklets，生成 ID； 状态估计(State Estimation)，不同的方法包括不同的部分； 工业界设计产品时，基本遵循自顶向下的策略：产品需求-功能需求-模块需求，层层推倒。所以我们设计评价准则时，一般会问几个问题： 该模块服务的产品功能，其需求及对应的指标是什么？ 要达到功能指标，本模块的输出需要哪些指标来评测？ 各个子模块对模块的影响是怎样的，对应需要增加哪些指标？ 这里提到了功能指标，模块指标，子模块指标三层概念。功能指标及部分模块指标是可以写入产品手册的，所以需要突出重点，易于理解；部分模块及子模块指标则主要是为了产品上工程优化迭代，这就要求这部分指标要相当细致，将模块的不足尽可能解耦，且完全暴露出来。以下通过两个例子来分析设计过程。 2.1. ADAS 中的 FCW 功能 FCW 基本功能要求为： 不允许误报，尽可能不漏报； 在 V km/h 下，以一定的刹车加速度 a，能避免与静止的前车相碰撞； 由以上两个功能需求，可确定必须的功能指标： （百公里）误报率； （百公里）漏报率； 观测距离，可由第二项功能要求推到出（人反应时间已知）； 相应的 MOT +状态估计模块输出的指标为各距离维度各类别维度下的： 误检率； 漏检率； ID Switch； 定位精度； 速度估计精度； 其中 MOT 主要涉及误检率，漏检率，ID Switch（直接影响状态估计模块）。这些指标的计算方式可以在学术界定义的基础上做进一步改进，比如漏检率，就需要体现出百公里漏报率的性能，所以可以考虑将连续 N 帧漏检的目标才归为漏检，分母可以定义为每多少帧。此外，要在各距离维度各类别维度下进行计算，这就涉及到过滤（filter）策略。对于 FCW 而言，首要关注的是本车前方近距离位置，距离维度上的功能重要程度要突显出来，类别维度也要区别对待，以便算法模块可以重点优化。 2.2. 自动驾驶中的动态障碍物检测功能 自动驾驶中动态障碍物检测的要求就高了，子模块也较为复杂，指标除了评估功能模块的性能，还需要指导迭代各子模块算法，包括本子模块的迭代比较，以及上下游模块相关指标的对比。 功能需求，我们简单列举几项： 不允许漏检，尽可能不误检； 前向，后向，侧向观测距离分别要达到 x, y, z； 相应的功能指标为： 漏检率； 误检率； 观测距离； 观测精度； 观测时延(delay)； MOT +状态估计模块输出的指标依然在各距离维度各类别维度下： 误检率； 漏检率； ID Switch； 定位精度； 尺寸，朝向，速度估计精度； 状态估计收敛时间； 一系列描述时序稳定性的指标； 与前述 FCW 功能类似，只是多了较多的指标。过滤操作也做的更加细致，我们还可以将目标做重要性等级划分，比如本车道前车多少米内，那指标基本都要达到 99%+；还可以将地面区域做重要性划分（比距离维度更加细致，可以认为是三维层面），周围几米内，那误检率肯定要非常低。除了过滤策略需要仔细设计外，匹配策略也需要进一步思考。如果传感器本身精度就有限，那么匹配策略就要相应放宽。还需注意的是引入过滤策略后，FP与FN计算的细微差别，比如有个过滤条件为去除目标像素面积小于一定阈值的目标集 A，观测值与真值匹配时，如果与 A 中的目标匹配上，那么不应该记为 FP，如果没匹配上 A 中的目标，那么 A 中地目标也不应该被记为 FN。这种类似的情况逻辑要思考清楚。 3. Summary 以上设计的出发点是，我们要承认算法的不完美性以及传感器的局限性，在工程领域，一定要首先解决主要矛盾，再打磨细节。本文还对以下内容未作进一步分析（以后有机会再写文细究）： 状态估计时序相关指标，描述估计的时序稳定性，也可以用于 MOT 的评估； 标注与过滤策略的关系，过滤策略往往依赖于标注策略； 各个指标的阈值确定，确定阈值也是产品中一件重要而又系统的事，有时候比指标设计更复杂； [1] Yang B, Huang C, Nevatia R. Learning affinities and dependencies for multi-target tracking using a CRF model[C]//CVPR 2011. IEEE, 2011: 1233-1240. [2] Choi W, Savarese S. Multiple target tracking in world coordinate with single, minimally calibrated camera[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 553-567. [3] Kasturi, Rangachar, et al. Framework for performance evaluation of face, text, and vehicle detection and tracking in video: Data, metrics, and protocol IEEE transactions on Pattern Analysis and Machine intelligence 31.2 (2008): 319-336. [4] Yamaguchi K, Berg A C, Ortiz L E, et al. Who are you with and where are you going?[C]//CVPR 2011. IEEE, 2011: 1345-1352. [5] Bernardin K, Stiefelhagen R. Evaluating multiple object tracking performance: the CLEAR MOT metrics[J]. Journal on Image and Video Processing, 2008, 2008: 1. [6] Kratz L, Nishino K. Tracking with local spatio-temporal motion patterns in extremely crowded scenes[C]//2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition. IEEE, 2010: 693-700. [7] Ristic B, Vo B N, Clark D, et al. A metric for performance evaluation of multi-target tracking algorithms[J]. IEEE Transactions on Signal Processing, 2011, 59(7): 3452-3457. [8] Schuhmacher D, Vo B T, Vo B N. A consistent metric for performance evaluation of multi-object filters[J]. IEEE transactions on signal processing, 2008, 56(8): 3447-3457. [9] Li Y, Huang C, Nevatia R. Learning to associate: Hybridboosted multi-target tracker for crowded scene[C]//2009 IEEE Conference on Computer Vision and Pattern Recognition. IEEE, 2009: 2953-2960. [10] Song B, Jeng T Y, Staudt E, et al. A stochastic graph evolution framework for robust multi-target tracking[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 605-619.]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT 评价指标-"Evaluating Multiple Object Tracking Performance, the CLEAR MOT Metrics"]]></title>
    <url>%2FMOT-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-Evaluating-Multiple-Object-Tracking-Performance-the-CLEAR-MOT-Metrics%2F</url>
    <content type="text"><![CDATA[这篇文章介绍了两个综合性指标 MOTA 以及 MOTP 的计算过程，这两个指标有优劣势，但是作为综合性指标至今在学术界仍广泛应用。本文主要介绍其设计思想及计算过程。 一个理想的 MOT 算法，我们期望每一帧： 准确检测目标的数量； 准确估计每个目标的状态，如位置，朝向，速度等； 准确估计每个目标的轨迹，即目标的 ID 不变性； 这就要求评价准则： 能评估目标定位的精度； 能反映目标轨迹的追踪能力，即同一个目标产生唯一的 ID； 此外，为了提高评价准则的实用性： 参数尽可能少，阈值可调； 易于理解，表现方式符合人们的直觉； 有较强的通用性，能评估各种跟踪算法； 指标个数少，但是能足够反映算法不同维度的性能； 假设第 \(t\) 帧，有目标集 \(\{o_1,...,o_n\}\)，跟踪算法的输出(hypotheses)：\(\{h_1,...h_m\}\)。根据上述设计准则，设计评价计算过程： 构建 \(h_j\) 与 \(o_i\) 的最优匹配； 对于每个匹配对，计算位置估计误差； 累加所有匹配对的误差，包括： 计算漏检数(FN)； 计算误检数(FP)； 计算 ID swith 次数，包括两个邻近目标的 ID 交换，以及遮挡后，同一目标的 ID 跳变； 由此可得到两大指标： tracking precision，目标位置的估计精度； tracking accuracy，包括 misses(FN), FP, mismatches(IDs), failures to recover； 下面分两块做细节分析，匹配构建 (Establishing Correspondences) 与评价指标 (Metrics)。 1. 匹配构建 算法估计与目标真值的匹配，大致还是基于匹配最近 object-hypothesis 的思想，没匹配上的估计就是 FP，没匹配上的真值就是 FN。但是这中间需要进一步考虑一些问题。 1.1. 有效匹配 如果算法估计 \(h_j\) 与目标 \(o_i\) 的最近距离 \(dist_{i,j}\) 超过了一定的阈值 \(T\)，那么这个匹配也是不合理的，因为这个距离误差加入到定位误差中是不合理的，所以只能说这个跟踪的结果不是这个目标。关于距离的度量： 区域（框）跟踪器，距离可用两者的重叠区域来度量，\(T\) 可以设为 0； 点跟踪器，距离可用两者中心点的欧氏距离来度量，\(T\) 可以根据目标的尺寸来设定； 1.2. 跟踪一致性 统计目标与算法输出的匹配跳变的次数，也就是目标 ID 的跳变数。文章还提到，当目标有两个有效地匹配时，选择之前的匹配，即使那个匹配的距离大于另一个匹配，这点当存在两个很近的目标时，可能会有问题，需要全局来看。 1.3. 匹配过程 对 \(t\) 帧，考虑 \(M_{t-1}\) 中所有匹配是否还依然有效，包括目标真值及算法输出是否还存在，如果都存在，那么距离是否超出阈值 \(T\)； 对于剩下的没找到匹配的真值目标，在唯一匹配以及阈值约束下，可采用匹配算法或者贪心算法来求解，使得距离误差的总和最小（文章的意思是排除了从上一帧继承的已有匹配，当目标密集时，这部分也应该加入进来优化）。统计当前帧目标真值匹配的跳变数 \(mme_t\)，作为 mismatch errors； 经过之前两步后，找到了所有的匹配，统计匹配个数为 \(c_t\)，计算匹配上的目标真值与算法输出的定位误差 \(d_t^i\)； 统计没有匹配上的算法输出 (hypotheses) 为 \(fp_t\)，没有匹配上的目标真值为 \(m_t\)，目标真值个数为 \(g_t\)； 每一帧重复步骤１，第一帧没有 mismatch； 2. 评价指标 基于以上的匹配策略，得出两个合理的指标： MOTP(multiple object tracking precision)，跟踪定位精度指标：\[MOTP=\frac{\sum_{i,t}d_t^i}{\sum_tc_t}\] MOTA(multiple object tracking accuracy)，综合了漏检率，误检率，以及 ID 跳变率：\[MOTA=1-\frac{\sum_t(m_t+fp_t+mme_t)}{\sum_tg_t}\]]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT 综述-'Multiple Object Tracking: A Literature Review']]></title>
    <url>%2FMOT-%E7%BB%BC%E8%BF%B0-Multiple-Object-Tracking-A-Literature-Review%2F</url>
    <content type="text"><![CDATA[之前做 MOT 还是沿着 SOT 的思路，这篇文章对 MOT 有一个很深入且很有框架性的综述，以下对这篇文章做一个提炼，并加入一些自己的想法。 MOT 作为一个中层任务，是一些高层任务的基础，比如行人的 pose estimation，action recognition，behavior analysis，车辆的 state estimation。单目标跟踪(SOT)主要关注 appearance model 以及 motion model 的设计，解决尺度、旋转、光照等影响因素。而 MOT 包含两个任务：目标数量以及目标ID，这就要求 MOT 还需要解决其它问题： frequent occlusions initialization and termination of tracks similar appearance interactions among multiple objects 1. 问题描述 多目标跟踪实际上是多参数估计问题。给定图像序列\(\{I_1,I_2,...,I_t,...\}\)，第\(t\)帧中目标个数为\(M_t\)，第\(t\)帧中所有目标的状态表示为\(S_t=\{s_t^ 1,s_t^ 2,...,s_t^ {M_t}\}\)，第\(i\)个目标的轨迹表示为\(s_{1:t}^ i=\{s_1^ i,s_2^ i,...,s_t^ i\}\)，所有图像中所有目标的状态序列为\(S_{1:t}=\{S_1,S_2,...,S_t\}\)。相应的，所有图像中所有目标观测到的状态序列为\(O_{1:t}=\{O_1,O_2,...,O_t\}\)。多目标跟踪的优化目标是求解最优的各目标状态，即求解一个后验概率问题，\[ \widehat{S}_{1:t}=\mathop{\arg\max}_{S_{1:t}}P(S_{1:t}|O_{1:t})\] 这种形式有两种实现方法： probabilistic inference 适合用于 online tracking 任务，Dynamic Model 为 \(P(S_t|S_{t-1})\)，Observation Model 为 \(P(O_t|S_t)\)，两步求解过程： \(\circ\) Predict: \(P(S_t|O_{1:t-1})=\int P(S_t|S_{t-1})dS_{t-1}\) \(\circ\) Update: \(P(S_t|O_{1:t}) \propto P(O_t|S_t)P(S_t|O_{1:t-1})\) deterministic optimization 适合用于 offline tracking 任务，直接利用多帧信息进行最优化求解。 2. 分类方法 initialization method 初始化方式分为： \(\circ\) Detection-Based Tracking，优势明显，除了只能处理特定的目标类型； \(\circ\) Detection-Free Tracking，能处理任何目标类型； processing mode 根据是否使用未来的观测，处理方式可分为： \(\circ\) online tracking，适合在线任务，缺点是观测量会比较少； \(\circ\) offline tracking，输出结果存在时延，理论上能获得全局最优解； type of output 根据问题求解方式输出是否存在随机性： \(\circ\) probabilistic inference，概率性推断； \(\circ\) deterministic inference，求解最大后验概率； 自动驾驶等在线任务主要关注 Detection-Based，online tracking。 3. 框架 MOT 主要考虑两个问题： 目标在不同帧之间的相似性度量，即对appearance, motion, interaction, exclusion, occlusion的建模； 恢复出目标的ID，即 inference 过程； 3.1. Appearance Model 3.1.1. Visual Representation 视觉表达即目标的特征表示方式： local features 本质上是点特征，点特征由 corner+descriptor(角点+描述子) 组成。KLT(good features to track)在 SOT 中应用广泛，用它可以生成短轨迹，估计相机运动位姿，运动聚类等；Optical Flow也是一种局部特征，在数据关联之前也可用于将检测目标连接到短轨迹中去。 region features 在一个块区域内提取特征，根据像素间作差的次数，可分为： zero-order, color histogram &amp; raw pixel template first-order, HOG &amp; level-set formulation(?) up-to-second-order, Region covariance matrix others 其它特征本质上也需要 local 或 region 的方式提取，只是原始信息并不是灰度或彩图。如 depth,probabilistic occupancy map, gait feature. Local features，比如颜色特征，在计算上比较高效，但是对遮挡，旋转比较敏感；Region features 里，HOG 对光照有一定的鲁棒性，但是对遮挡及形变效果较差；Region covariance matrix 更加鲁棒，但是需要更高的计算量；深度特征也比较有效，但是需要额外的获取深度信息的代价。 3.1.2. Statistical Measuring 有了目标的特征表示方式之后，就可以评价两个观察的目标的相似性。特征表示的线索(cue)可分为： single cue 因为只有一个线索，相似性(similarity)可以直接通过两个向量的距离转换得到。可以将距离指数化，高斯化。也可以将不相似度转为可能性，用协方差矩阵表示。 multiple cues 多线索，即多种特征的融合，能极大提高鲁棒性，融合的策略有： Boosting, 选取一系列的特征，用 boost 算法选取表达能力最强的特征； Concatenation, 各个特征直接在空间维度上串起来，形成一个 cue 的表达方式； Summation, 加权融合各个特征，形成一个 cue 的表达方式； Product, 各个特征相乘的方式，比如目标 \(s_0\) 的某个潜在匹配 \(s_1\) 的颜色，形状特征为 \(color\), \(shape\) 的概率为 \(p(color|s_0)\), \(p(shape|s_0)\), 假设特征独立，那么， \[p(s_1|s_0)=p(color, shape|s_0)=p(color|s_0)\cdot p(shape|s_0)\] Cascading, coarse-to-fine 的方式，逐步精细化搜索； 3.2. Motion Model 运动模型对关联两个 tracklets 比较管用，而 online tracking 任务，对输出的时延要求较高，所以其中一个 tracklet 可以任务就是当前帧与上一帧形成的轨迹，所以这里很难去计算两个 tracklets 的相似度。能看到的一个应用点就是，通过 motion model 模型，预测下一时刻目标的位置，作为一个线索项目。以下讨论的各模型主要是为了度量 tracklets 的相似性，从而做 tracklets 的匹配。 3.2.1. Linear Velocity Smoothness. N 帧 M 个目标轨迹: \(C_{dyn}=\sum_{t=1}^ {N-2}\sum_{i=1}^ {M}\parallel v_i^ t-v_i^ {t+1}\parallel^ 2\) Position Smoothness. \(G(p^ {tail}+v^ {tail}\Delta t-p^ {head}, \sum_p)\cdot G(p^ {head}-v^ {head}\Delta t-p^ {tail}, \sum_p)\) Acceleration Smoothness. 3.2.2. Non-linear 运动模型假设是非线性的，相似度计算还是按照以上高斯形式。引为中提到，非线性运动模型并不作为目标的惩罚因子，因为目标并不需要满足该模型，但是只要有目标满足，就降低惩罚系数。 3.3. Interaction Model 3.3.1. Social Force Models Individual Force fidelity, 目标不会改变它的目的地方向； constancy, 目标不会突然改变速度和方向； Group Force attraction, 目标间应该尽量靠近； repulsion, 目标间也得保留适当的距离； coherence, 同一个 group 里面的目标速度应该差不多； 3.3.2. Crowd Motion Pattern Models 当一个 group 比较密集的时候，单个目标的运动模型不太显著了，这时候群体的运动模型更加有效，可以用一些方法来构建群体运动模型。 3.4. Exclusion Model 3.4.1. Detection-level 同一帧两个检测量不能指向同一个目标。匹配 tracklets 时，可以将这一项作为惩罚项。不过目前的检测技术都做了 NMS，基本可以消除这种情况。 3.4.2. Trajectory-level 两个轨迹不能非常靠近。对于 online tracking 来说，就是 tracking 结果的两个量不能挨在一起，如果挨在一起，就说明有问题，比如遮挡，或跟丢。 3.5. Occlusion Handling Part-to-whole, 将目标分成栅格来处理； Hypothesize-and-test, Buffer-and-recover, 在遮挡产生前，记录一定量的观测，遮挡后恢复； Others 3.6. Inference 3.6.1. Probabilistic Inference 概率法只需要用到当前时刻之前的信息，所以适合用于 online tracking 任务。首先，如果假设一阶马尔科夫，当前目标的状态之依赖于前一时刻目标的状态，即 dynamic model： \[P(S_t|S_{1:t-1})=P(S_t|S_{t-1})\] 其次，观测是独立的，即当前目标的观测只由当前目标的状态决定，observation model： \[P(O_{1:t}|S_{1:t})=\prod_{i=1}^t P(O_t|S_t)\] dynamic model 对应的就是跟踪算法策略，observation model 是状态观测手段，包括检测方法。目标状态估计的迭代过程为： predict step 根据 dynamic model，由目标的上一状态预测当前状态的后验概率分布； update step 根据 observation model，更新当前目标状态的后验概率分布； 状态估计的过程伴随着噪音等因素的影响，常用的概率推断模型有： Kalman filter Extended Kalman filter Particle filter 3.6.2. Deterministic Optimization 确定性优化法需要至少一个时间窗口的观测量，所以适合 offline tracking 任务。优化方法有： Bipartite graph matching Dynamic Programming Min-cost max-flow network flow Conditional random field MWIS(Maximum-weight independent set) 4. 评价方法 评价方法是非常重要的，一方面对算法系统进行调参优化，另一方面比较各个不同算法的优劣。评价方法 (evaluation) 包括评价指标 (metrics) 以及数据集 (datasets)，多类别的数据集主要有： MOT Challenge KITTI 评价指标可分为： A. 检测指标 \(\lozenge\) 准确性(Accuracy) Recall &amp; Precision False Alarme per Frame(FAF) rate, from paper False Positive Per Image(FPPI), from paper MODA(Multiple Object Detection Accuracy), 包含了 false positive &amp; miss dets. from paper \(\lozenge\) 精确性(Precision) MODP(Multiple Object Detection Precision), 衡量检测框与真值框的位置对齐程度；from paper B. 跟踪指标 \(\lozenge\) 准确性(Accuracy) ID switches(IDs), from paper MOTA(Multiple Object Tracking Accuracy), 包含了FP，FN，mismatch；from paper \(\lozenge\) 精确性(Precision) MOTP(Multiple Object Tracking Precision), from paper TDE(Tracking Distance Error), from paper OSPA(optimal subpattern assignment), from paper \(\lozenge\) 完整性(Completeness) MT, the numbers of Mostly Tracked, from paper PT, the numbers of Partly Tracked ML, the numbers of Mostly Lost FM, the numbers of Fragmentation \(\lozenge\) 鲁棒性(Robustness) RS(Recover from Short-term occlusion), from paper RL(Recover from Long-term occlusion) 评价指标汇总： 5. 总结 5.1. 还存在的问题 MOT 算法模块较多，参数也较复杂，但是最依赖于检测模块的性能，所以算法间比较性能时，需要注意按模块进行变量控制。 5.2. 未来研究方向 MOT with video adaptation，检测模块式预先训练的，需要在线更新学习； MOT under multiple camera: \(\circ\) multiple views，不同视野相同场景信息的记录， \(\circ\) non-overlapping multi-camera，不同视野不同场景的 reidentification； Multiple 3D object tracking，能更准确预测位置，大小，更有效处理遮挡； MOT with scene understanding，拥挤场景，用场景理解来有效跟踪； MOT with deep learning MOT with other cv tasks，和其他任务融合，比如目标分割等；]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D Detection Paper List]]></title>
    <url>%2F3D-Detection-paper-list%2F</url>
    <content type="text"><![CDATA[这篇文章从输入数据类别上进行 3D Detection paper 的归类。 RGB RGB-D(双目，单目+点云) Lidar]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study Topic List]]></title>
    <url>%2Fstudy-topic-list%2F</url>
    <content type="text"><![CDATA[本文罗列了相关领域知识的学习资料。 1. Detection 1.1. 2D Detection 入门 amusi [Object Detection @handong](https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html#yolov3) Object Detection and Classification using R-CNNs Paper with Code 1.2. 3D Detection Paper with Code KITTI Leaderboard 2. Tracking 2.1. Single Object Tracking Paper with Code 2.2. Multi Object Tracking Paper with Code Paper List MOT Challenge 综述：Multiple Object Tracking: A Literature Review 综述：Online object tracking: A benchmark 综述：MOTChallenge 2015: Towards a benchmark for multi-target tracking 3. Computational Photography 2017年秋季的计算摄影学课程15-463 4. CNN ACC 5. SLAM 5.1. 理论知识 计算机视觉中的数学方法 Multiple View Geometry in Computer Vision Probabilistic Robotics(有中文版) State Estimation for Robotics(有中文版) 视觉SLAM十四讲 5.2. 综述 [Visual Odometry Part I: Fundamentals] [Visual Odometry Part II: Matching, Robustness, Optimization, Applications] Review of Visual Odometry: Types, Approaches, Challenges, and Applications Visual SLAM algorithms: a Survey from 2010 to 2016 Visual SLAM for Driverless Cars: a Brief Survey Visual Simultaneous Locations and Mapping: a Survey 5.3. 工具 ROS Opencv Camera Calibration Matlab Camera Calibration Toolbox ROS Wiki Camera Calibration 5.4. 算法 OpenSLAM 5.5. 其它资料 计算机视觉life Paper with Code]]></content>
  </entry>
</search>
