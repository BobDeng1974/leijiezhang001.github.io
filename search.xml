<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卡尔曼滤波详解]]></title>
    <url>%2F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[状态估计问题是指，基于初始状态信息，一系列观测量，一系列输入量，以及系统的运动模型和观测模型，来计算系统在某时刻的真实状态的估计值。卡尔曼滤波及其相关卡尔曼滤波算法是状态估计的重要方法。本文介绍卡尔曼滤波(Kalman Filter)，扩展卡尔曼滤波(Extended Kalman Filter)。 1.&ensp;卡尔曼滤波1.1.&ensp;线性高斯系统 卡尔曼滤波是线性高斯系统的最优无偏估计，定义离散线性高斯系统：$$\left\{\begin{array}{l}运动方程:\quad x_k=A_kx_{k-1}+B_ku_k+w_k\\测量方程:\quad z_k=C_kx_k+v_k\end{array}\tag{1}\right.$$其中矩阵 \(A_k\) 为转移矩阵（transition matrix），设矩阵 \(B_k=I\) 为控制矩阵，矩阵 \(C_k\) 为观测矩阵(observation matrix)。并且所有状态和噪声均满足高斯分布：$$\begin{align}过程噪声: \quad &amp; w_k \sim N(0,Q_k)\\测量噪声: \quad &amp; v_k \sim N(0,R_k)\end{align}$$卡尔曼滤波估计线性高斯系统的状态分为两个步骤： 预测（Predict）计算先验：$$\begin{align}\bar{x}_k &amp;=A_k\hat{x}_{k-1}+u_k \tag{2}\\\bar{P}_k &amp;=A_k\hat{P}_{k-1}A_k^T+Q_k \tag{3}\end{align}$$ 更新（Update）先计算卡尔曼增益：$$K_k=\bar{P}_kC_k^T(C_k\bar{P}_kC_k^T+R_k)^{-1} \tag{4}$$再计算后验概率分布：$$\begin{align}\hat{x}_k &amp;=\bar{x}_k+K(z_k-C_k\bar{x}) \tag{5}\\\hat{P}_k &amp;=(I-KC_k)\bar{P}_k \tag{6}\end{align}$$ 以下通过三种方式来推导出卡尔曼滤波器。 1.2.&ensp;通过 MAP/贝叶斯推断推导[1][2][3] 状态估计问题的概率解释就是用 \(0\) 到 \(k\) 的数据（包括初始状态，观测量，输入量）来估计当前时刻的状态分布：\(P(x_k\vert x_0,u_{1:k},z_{1:k})\)。根据贝叶斯法则：$$P(x_k\vert x_0,u_{1:k},z_{1:k}) \propto P(z_k\vert x_k)P(x_k\vert x_0,u_{1:k},z_{1:k-1})\tag{7}$$这三项分别为后验概率，似然，先验概率。所以状态估计可转换为该后验概率最大化（Maximize a Posterior，MAP）问题。MAP 相当于最大化似然与先验的乘积。似然由测量方程给出，先验有运动方程给出。先验部分如果考虑历史所有信息，那么可以用非线性优化框架来解；如果只考虑一阶马尔科夫性，那么就是卡尔曼滤波方法，前述线性高斯系统就满足一阶马尔科夫性。 该系统下，假设已知 \(k-1\) 时刻的后验状态估计 \(\hat{x} _{k-1}\) 及其协方差 \(\hat{P} _{k-1}\)，现在要根据 \(k\) 时刻的输入和观测数据，确定 \(x_k\) 的后验分布。这里以 \((\hat{\cdot})\) 表示后验分布，\((\bar{\cdot})\) 表示先验分布。 卡尔曼滤波器首先通过(1)中的运动方程确定 \(x_k\) 的先验分布，即预测过程。将 \(k-1\) 时刻的分布通过运动方程传递，对于均值有：$$\begin{align}\bar{x}_k &amp;=E[x_k]=E[A_kx_{k-1}+u_k+w_k]\\&amp;=A_kE[x_{k-1}]+u_k+E[w_k]\\&amp;=A_k\hat{x}_{k-1}+u_k\end{align}$$对于协方差有：$$\begin{align}\bar{P}_k &amp;=E\left[(x_k-E[x_k])(x_k-E[x_k])^T\right]\\&amp;=E\left[(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)\cdot(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)^T\right]\\&amp;=A_kE\left[(x _{k-1}-\hat{x} _{k-1})\cdot(x _{k-1}-\hat{x} _{k-1})^T\right]A_k^T+E[w_kw_k^T]\\&amp;=A_k\hat{P} _{k-1}A _{k-1}^T+Q _k\end{align}$$ 由此可得预测过程：$$\begin{align}&amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(A_k\hat{x}_{k-1}+u_k,A_k\hat{P}_{k-1}A_k^T+Q_k\right)\tag{8}\\\iff &amp;公式 (2),(3)\end{align}$$ 另一方面，通过(1)中的观测方程，可以得到在某个状态下观测数据应该为：$$P(z_k\vert x_k)=N(C_kx_k,R)\tag{9}$$由公式(7)可知，状态的后验概率分布由预测量以及测量量融合得到，这个融合的过程是两个高斯状的概率分布进行相乘，即 \(x_k\) 的后验概率：$$N(\hat{x}_k,\hat{P}_k)=N(C_kx_k,R)\cdot N(\bar{x}_k,\bar{P}_k)\tag{10}$$比较该式指数部分即可得到更新过程：$$\begin{align}&amp; (x_k-\hat{x}_k)^T\hat{P}_k^{-1}(x_k-\hat{x}_k)=(z_k-C_kx_k)^TR^{-1}(z_k-C_kx_k)+(x_k-\bar{x}_k)^T\bar{P}_k^{-1}(x_k-\bar{x}_k)\\\iff &amp;\left\{\begin{array}{l}二次项系数:\quad \hat{P}_k^{-1}=C_k^TR^{-1}C_k+\bar{P}_k^{-1}\\一次项系数:\quad 2\hat{x}_k^T\hat{P}_k^{-1}x_k=2z_k^TR^{-1}C_kx_k+2\bar{x}_k^T\bar{P}_k^{-1}x_k\end{array}\right. \tag{11} \\\iff &amp;\left\{\begin{array}{l}I=\hat{P}_kC_k^TR^{-1}C_k+\hat{P}_k\bar{P}_k^{-1}\\\hat{x}_k=\hat{P}_kC_k^TR^{-1}z_k+\hat{P}_k\bar{P}_k^{-1}\bar{x}_k\end{array}\right. 令 K=\hat{P}_kC_k^TR^{-1} \\\iff &amp;\left\{\begin{array}{l}I=KC_k+\hat{P}_k\bar{P}_k^{-1}\\\hat{x}_k=Kz_k+(I-KC_k)\bar{x}_k\end{array}\right. \\\iff &amp; 式 (4),(5),(6)\end{align}$$ 对于更新过程，[3]中提出了另一种更加形象的证明方法。如图1所示，容易得到小车模型的运动方程：$$\begin{bmatrix}x _k\\\dot{x} _k\\\end{bmatrix}=\begin{bmatrix}1 &amp; \Delta k\\0 &amp; 1\\\end{bmatrix}\begin{bmatrix}x _{k-1}\\\dot{x} _{k-1}\\\end{bmatrix}+\begin{bmatrix}\frac{(\Delta k)^2}{2}\\\Delta k\\\end{bmatrix}a_k$$其中 \(a_k\) 为加速度输入量，对比式(1)也容易得到转移矩阵与控制矩阵。预测过程的证明方式与上述一致，下面简述其更新过程的证明，详见[3]。 如图1所示，红色区域代表预测量 \(\bar{x}_k\) 的概率分布高斯函数；蓝色代表测量量 \(z_k\) 概率分布的高斯函数，测量装置为左侧的 ToF 装置，单位为秒。绿色代表状态的后验概率分布 \(\hat{x}_k\)，由预测量的概率(先验)与测量量的概率(似然)相乘得到。由式(10)可知，两个高斯函数相乘还是高斯函数（但是是尺度变化的高斯函数，Scaled Gaussian[4]），上面的证明过程直接比较二次项与一次项，这里是直接写出新的高斯分布均值方差与另两个高斯分布均值方差的关系，本质上都是比较自变量前面的系数，非系数是不相等的，还有 Scaled 项。由此可得到更新过程。要注意的是，高斯分布相乘时，要注意单位的转换(即需要满足式(10)的单位形式)，这里的观察矩阵就是基于测量装置的测量单位(秒)与状态单位(米，米/秒)的转换值。 2.&ensp;扩展卡尔曼滤波2.1.&ensp;非线性非高斯系统 通常系统（如 SLAM）的运动方程和观测方程是非线性函数，写成一般形式：$$\left\{\begin{array}{l}运动方程:\quad x_k=f(x_{k-1},u_k)+w_k\\测量方程:\quad z_k=h(x_k)+v_k\end{array}\tag{12}\right.$$扩展卡尔曼滤波估计非线性系统的状态与卡尔曼滤波类似，也分为两个步骤： 预测（Predict）计算先验：$$\begin{align}\bar{x} _k&amp;=f(\hat{x} _{k-1},u _k) \tag{13}\\\bar{P} _k&amp;=F\hat{P} _kF^T+Q _k \tag{14}\end{align}$$ 更新（Update）先计算卡尔曼增益：$$K_k=\bar{P}_kH_k^T(H_k\bar{P}_kH_k^T+R_k)^{-1} \tag{15}$$再计算后验概率分布：$$\begin{align}\hat{x}_k &amp;=\bar{x}_k+K(z_k-h(\bar{x})) \tag{16}\\\hat{P}_k &amp;=(I-KH_k)\bar{P}_k \tag{17}\end{align}$$ 2.2.&ensp;通过 MAP/贝叶斯推断推导[1][2] 在某个点附件考虑运动方程与观测方程的一阶泰勒展开，只保留一阶项，即线性部分，然后按照线性系统进行推导。在 \(k\) 时刻，将运动方程和观测方程在 \(\hat{x} _{k-1},\hat{P} _{k-1}\) 处进行线性化：$$\left\{\begin{array}{l}运动方程:\quad x_k\approx f(\hat{x}_{k-1},u_k)+F(x_{k-1}-\hat{x}_{k-1})+w_k\\测量方程:\quad z_k\approx h(\bar{x}_k)+H(x_k-\bar{x}_k)+v_k\end{array}\tag{18}\right.$$其中 \(F=\left.\frac{\partial f}{\partial x_{k-1}}\right\arrowvert_{\hat{x}_{k-1}}\)， \(H=\left.\frac{\partial h}{\partial x_k}\right\arrowvert_{\bar{x}_k}\)。 由此可得预测过程:$$\begin{align}&amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(f(\hat{x}_{k-1},u_k),F\hat{P}_{k-1}F^T+Q_k\right)\tag{19}\\\iff &amp;公式 (13),(14)\end{align}$$ 另一方面，通过(18)中的观测方程，可以得到在某个状态下观测数据应该为：$$P(z_k\vert x_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R)\tag{20}$$由贝叶斯公式，可得 \(x_k\) 的后验概率：$$N(\hat{x}_k,\hat{P}_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R))\cdot N(\bar{x}_k,\bar{P}_k)\tag{21}$$类似卡尔曼推导过程，由此可得到更新过程式(15)，(16)，(17)。 [1] 高翔, 张涛, 颜沁睿, 刘毅, 视觉SLAM十四讲：从理论到实践, 电子工业出版社, 2017[2] T. D. Barfoot. State Estimation for Robotics. Cambridge University Press, 2017.[3] Faragher, Ramsey. “Understanding the basis of the Kalman filter via a simple and intuitive derivation.” IEEE Signal processing magazine 29.5 (2012): 128-132.[4] Bromiley, Paul. “Products and convolutions of Gaussian probability density functions.” Tina-Vision Memo 3.4 (2003): 1.]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KLT 光流算法详解]]></title>
    <url>%2FKLT%2F</url>
    <content type="text"><![CDATA[光流（Optical Flow）是物体在三维空间中的运动（运动场）在二维图像平面上的投影，由物体与相机的相对速度产生，反映了微小时间内物体对应的图像像素的运动方向和速度。 KLT 是基于光流原理的一种特征点跟踪算法，本文首先介绍光流原理，然后介绍 KLT 及相关 KLT 变种算法。 1.&ensp;Optical Flow 光流法假设： 亮度恒定，图像中物体的像素亮度在连续帧之间不会发生变化； 短距离(短时)运动，相邻帧之间的时间足够短，物体运动较小； 空间一致性，相邻像素具有相似的运动； 记 \(I(x,y,t)\) 为 \(t\) 时刻像素点 \((x,y)\) 的像素值，那么根据前两个假设，可得到：$$I(x,y,t)=I(x+dx,y+dy,t+dt)$$一阶泰勒展开：$$I(x+dx,y+dy,t+dt)=I(x,y,t)+\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt$$由此可得：$$\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt=0 \iff \frac{\partial I}{\partial x}\frac{dx}{dt}+\frac{\partial I}{\partial y}\frac{dy}{dt}=-\frac{\partial I}{\partial t}$$记 \(\left(\frac{dx}{dt},\frac{dy}{dt}\right)=(u,v)\)，即为所要求解的像素光流；\(\left(\frac{\partial I}{\partial x},\frac{\partial I}{\partial y}\right)=(I_x,I_y)\) 为像素灰度空间微分；\(\frac{\partial I}{\partial t}=I_x\) 为像素坐标点的时间灰度微分。整理成矩阵形式：$$\begin{bmatrix}I_x &amp;I_y\\\end{bmatrix}\begin{bmatrix}u\\v\\\end{bmatrix}=-I_t$$该式表示相同坐标位置的时间灰度微分是空间灰度微分与这个位置上相对于观察者的速度的乘积。由空间一致性假设，对于周围多个点，有：$$\begin{bmatrix}I_{x1} &amp;I_{y1}\\I_{x2} &amp;I_{y2}\\I_{x3} &amp;I_{y3}\\\vdots &amp;\vdots \\\end{bmatrix}\begin{bmatrix}u\\v\\\end{bmatrix}=-\begin{bmatrix}I_{t1}\\I_{t2}\\\vdots\\\end{bmatrix} \iff A\vec{u}=b$$这是标准的线性方程组，可用最小二乘法求解 \(\vec{u}=\left(A^TA\right)^{-1}A^Tb\)，也可以迭代求解。这种方式得到的光流，称为 Lucas-Kanade 算法。 2.&ensp;KLT KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。由光流假设，在很短时间 \(\tau\) 内，前后两帧图像满足：$$J(A\mathrm{x}+d)=I(\mathrm{x}), 其中 A=1+D=1+\begin{bmatrix}d_{xx} &amp; d_{xy}\\d_{yx} &amp; d_{yy}\\\end{bmatrix}$$像素位移(displacement)向量满足仿射运动模型(Affine Motion) \(\delta=Dx+d\)，其中 \(D\) 称为变形矩阵(Deformation Matrix)，\(d\) 称为位移向量(Displacement Vector)。\(D\) 表示两个像素窗口块运动后的变形量，所以当窗口较小时，会比较难估计。通常 \(D\) 可以用来衡量两个像素窗口的相似度，即衡量特征点有没有漂移。而对于光流跟踪量，一般只考虑平移模型(Translation Model)：$$J(\mathrm{x}+d)=I(\mathrm{x})$$ 为了普遍性，我们用仿射运动模型来推到 KLT 算法原理。在像素窗口下，构造误差函数：$$\epsilon=\iint_W [J(A\mathrm{x}+d)-I(x)]^2 w(\mathrm{x})d\mathrm{x}$$其中 \(w(\mathrm{x})\) 是权重函数，可定义为高斯形式。上式分别对变量 \(D\) 和 \(d\) 求导：$$\left\{\begin{array}{l}\frac{\partial \epsilon}{\partial D}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,\mathrm{x}^T\,w\,d\mathrm{x}&amp;=0\\\frac{\partial \epsilon}{\partial d}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}&amp;=0\\\end{array}\right.$$其中 \(g=\left(\frac{\partial J}{\partial x},\frac{\partial J}{\partial y}\right)^T\)。记光流 \(u=D\mathrm{x}+d\)，则对运动后的像素点进行泰勒展开：$$J(A\mathrm{x}+d)=J(x)+g^T(u)$$仿射运动模型结果可见[1][5]，这里给出平移运动模型结果。令 \(D=0\)：$$\begin{align}&amp;\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}=0\\\iff &amp;\iint_W[J(\mathrm{x})-I(\mathrm{x})]g\,w\,d\mathrm{x}=-\iint_Wg^T\,\mathrm{d}\,g\,w\,d\mathrm{x}=-\left[\iint_Wg\,g^T\,w\,d\mathrm{x}\right]\mathrm{d}\\\iff &amp;Z\mathrm{d}=e\end{align}$$其中 \(Z\) 是 \(2\times 2\) 矩阵，\(e\) 是 \(2\times 1\) 向量。这是线性方程组优化问题，当 \(Z\) 可逆时，这个方程可容易求解。因为推导过程用到了泰勒展开，所以只有当像素位移较小时，才成立。实际操作中，一般迭代式的来求解，每次用上次结果做初始化，进一步求解(In a Newton-Raphson Fasion)。 3.&ensp;Pyramidal Iterative KLT 以上标准的迭代式 KLT 计算过程只在位移较小时成立（泰勒展开），所以需要更优的金字塔式迭代求解。图像金字塔有多重定义方式，这里定义：$$\begin{align}I^L(x,y)&amp;=\frac{1}{4}I^{L-1}(2x,2y)\\&amp;+\frac{1}{8}\left(I^{L-1}(2x-1,2y)+I^{L-1}(2x+1,2y)+I^{L-1}(2x,2y-1)+I^{L-1}(2x,2y+1)\right)\\&amp;+\frac{1}{16}\left(I^{L-1}(2x-1,2y-1)+I^{L-1}(2x+1,2y+1)+I^{L-1}(2x-1,2y+1)+I^{L-1}(2x+1,2y-1)\right)\end{align}$$ 特征点跟踪有两个关键指标：准确性(accuracy)，以及鲁棒性(robustness)。大的窗口，对大的运动量比较鲁棒，但是为了提高准确性，又不得不减小窗口。所以窗口的选择需要权衡跟踪准确性与鲁棒性。金字塔迭代 KLT 则能有效弱化窗口的局限性。这里介绍平移模型下金字塔迭代 KLT 算法，仿射模型算法过程可见[1][5]。 定义金字塔迭代 KLT 算法的目标：图像 \(I\) 中某坐标点 \(\mathrm{x}\)，在图像 \(J\) 中找到其对应点 \(\mathrm{\hat{x}}\)。算法流程为： 建立图像金字塔：\(\{I^L\}_{L=0,…,L_m}\)，\(\{J^L\}_{L=0,…,L_m}\)初始化光流在金字塔之间的传递值：\(g^{L_m}=[g_x^{L_m},g_y^{L_m}]^T=[0,0]^T\)for \(L=L_m\) down to 0 with step of -1 计算图像 \(I^L\) 中的 \(\mathrm{x}\) 坐标: \(\mathrm{x}^L=[x,y]^T=\mathrm{x}/2^L\)计算空间梯度矩阵 \(Z\)初始化 KLT 迭代值：\(v^0=[0,0]^T\)for \(k=1\) to \(K\) with step of 1 or until \(\Vert\eta^k\Vert\) &lt; accuracy threshold 计算图像差矩阵 \(I^L(\mathrm{x}^L)-J^L(\mathrm{x}^L)=I^L(x,y)-J^L(x+g_x^L+v_x^{k-1},y+g_y^L+v_y^{k-1})\)计算图像差矩阵 \(e_k\)计算光流 \(\eta^k=Z^{-1}e_k\)更新下次迭代的初值 \(v^k=v^{k-1}+\eta^k\) end of for-loop on k第 \(L\) 层金字塔下光流为：\(\mathrm{d}^L=v^K\)初始化第 \(L-1\) 层金字塔的光流： \(g^{L-1}=[g_x^{L-1}, g_y^{L-1}]^T=2(g^L+\mathrm{d}^L)\) end of for-loop on L最终的光流结果：\(\mathrm{d}=g^0+\mathrm{d}^0\)对应的 \(J\) 上的坐标点为：\(\hat{\mathrm{x}}=\mathrm{x}+\mathrm{d}\) 4.&ensp;Feature Selection 在特征点跟踪之前，特征点的选择也很重要，以上计算过程中，我们期望 \(Z\) 可逆，也就是其最小特征值要足够大。如果已经提取了角点，则可进一步做选择。因此特征点选择准则为： 计算图像每个像素(或已提取的角点)的 \(Z\) 矩阵，及其最小的特征值 \(\lambda_m\) 从所有 \(\lambda_m\) 中取最大值为 \(\lambda_{max}\) 保留 \(\lambda_m\) 大于一定百分比(10%) \(\lambda_{max}\) 的像素(角点) 在这些像素(角点)中，保留局部最大值 视计算能力，保留其中的子集 以上特征点提取的过程类似于 Harris 角点。要注意的是选择特征计算 \(Z\) 时，\(3\times3\) 窗口足够，但是跟踪时，一般大于 \(3\times3\)。 5.&ensp;Dissimilarity 相似性度量决定该特征点是否已经漂移而不能使用了，即外点检测(Outlier Detection)，所以非常重要。相比于平移模型，仿射模型对特征点的相似性度量更有效果。在长距离跟踪下，相似性度量可能解决不了是否漂移的问题，但是好的相似性度量能从一开始就剔除漂移的特征点。此外，也可用其它更高层面的外点检测技术替代。 [1] Shi, Jianbo, and Carlo Tomasi. Good features to track. Cornell University, 1993.[2] Birchfield, Stan. “Derivation of kanade-lucas-tomasi tracking equation.” unpublished notes (1997).[3] Bouguet, J.-Y.. “Pyramidal implementation of the lucas kanade feature tracker.” (2000).[4] Suhr, Jae Kyu. “Kanade-lucas-tomasi (klt) feature tracker.” Computer Vision (EEE6503) (2009): 9-18.[5] Bouguet, Jean-Yves. “Pyramidal implementation of the affine lucas kanade feature tracker description of the algorithm.” Intel Corporation 5.1-10 (2001): 4.]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>tracking</tag>
        <tag>ADAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Visual Odometry Part I&II"]]></title>
    <url>%2F%5Bpaper_reading%5D-Visual_Odometry_Part_I_II%2F</url>
    <content type="text"><![CDATA[1.&ensp;Overview of VO SFM(Structure from Motion) 是解决从一堆图片中将场景以及相机姿态进行 3-D 重建的问题，最后的场景以及相机姿态可以通过离线优化方法（bundle adjustment）来 refine。VO &amp; VSLAM 都属于 SFM 的特殊情况，SfM 处理的图像时间上可以是无序的，而 VO &amp; VSLAM 则要求图像时间上有序。VO 只关心轨迹的局部一致性，而 VSLAM 关心全局轨迹和地图的一致性。VO 可以作为 VSLAM 的一个模块，用于重建相机的增量运动，Bundle Adjustment 可以用来 refine 相机的轨迹。如果用户只对相机路径感兴趣，不需要环境地图，且需要较高的实时性，那么一般 VO 就能满足需求。 视觉里程计（VO）最早应用于 NASA 火星地面探测器，相比于车轮里程计的优势： 不受车轮打滑的影响； 不受拐弯影响，拐弯时左右轮速度不一样； 更加准确，相对位置误差大概在 0.1% 到 2%，可作为车轮里程计、GPS，IMU等其它测量装置的补充； 在某些领域是必须的，比如无法使用车轮里程计的无人机，GPS 失效的水下环境等； 根据视觉传感器数量，VO 可分为 Stereo VO，与 Monocular VO。当场景距离远远大于双目基线时，Stereo VO 也需要退化成 Monocular VO 来处理。 1.1.&ensp;Stereo VO &amp; Monocular VO 特征点匹配可以通过特征跟踪（Feature Tracking）或特征检测（Feature Detect）再匹配两种方式实现。特征跟踪计算量小，但是容易漂移；特征检测再匹配计算量大，需要用 RANSAC 去除无匹配点，但是特征点不容易漂移。 Motion Estimation 可通过 3D-3D，3D-2D，2D-2D 三种方式实现。Stereo 系统可以获得每个点的深度信息，所以这三种方式都可以用来做相机的运动估计。实验表明，直接在原始的 2-D 点上进行相机运动的估计，更加准确（？存疑）。 之所以研究单目 VO，是因为当场景距离相机很远的时候（相对于双目的基线），双目就退化为单目了。单目 VO 中绝对深度（尺度）是未知的，刚开始两帧相机移动的距离通常设定为 1，之后的相对位姿都基于此。相关方法可分为： Feature-based Methods，用每一帧的特征点来估计运动。 Appearance-based Methods，用图像中所有的像素点或是子区域中的像素点来估计运动。 Hybrid Methods，结合以上两种形式。 第一种方法较好，运动估计用 five-point RANSAC 来求解。 1.2.&ensp;Reducing the Drift 由于 VO 是一步步计算相机的运动轨迹然后作累加的，那么误差就有累积性，使得估计的运动轨迹会漂移。这可以用 Sliding Window(Windowed) Bundle Adjustment 局部优化方法来解决。也可以用 GPS 或 laser 或 IMU 融合来解决。Windowed Bundle Adjustment，是通过 m 个窗口下的信息来优化求解这 m 个相机位姿。 1.3.&ensp;VO Versus V-SLAM V-SLAM 两大方法： Filtering Methods概率法，以一定的概率分布融合所有图像信息； Keyframe Methods关键帧法，使用全局 Bundle Adjustment 优化被选择的关键帧； VO 只关心相机轨迹的一致性，而 SLAM 关注轨迹与地图整体的一致性。SLAM 中两大问题是，检测 loop closure 的发生以及用这个约束来更好的优化当下的地图和轨迹。而 VO 只对历史中以往 n 个轨迹中的位姿进行优化（windowed bundle adjustment），这可以认为与 SLAM 中建立局部地图与轨迹是等价的。但是这两者的 philosophy 不同： VO 只关心局部轨迹的一致性，局部地图只是用来（在 bundle ajustment）更精确的估计局部轨迹； SLAM 关心整个地图的一致性，当然也包括轨迹，轨迹的精确性能使地图更加精确； VO 可以是 SLAM 的一个模块（相机运动轨迹的重建），SLAM 还需要一个闭环检测，以及一个全局的地图优化策略。V-SLAM 重建相机运动轨迹理论上比 VO 更精确（加入了更多的约束），但是不一定更鲁棒，因为闭环检测中的奇异值对地图的一致性有较大影响。此外 SLAM 更加复杂以及耗计算资源。VO 牺牲了全局一致性，来达到实时运行的目的，因为不需要记录所有的地图信息。 2.&ensp;Formulation of the VO Problem 在时间 \(k\) 下，相机拍摄的图像集记为：\(I_{0:n}=\{I_0,…,I_k\}\)。相机在时间 \(k-1\) 与 \(k\) 的位姿转换矩阵为 \(T_{k,k-1}\in \mathbb{R}^{4\times 4}\)。VO 所要求解的问题就是 \(T=T_{1,0}T_{2,1}…T_{k,k-1}\)。由此可知 VO 是计算相邻帧的相机位姿，然后对之前 m 个位姿做一个局部优化从而估计更准确的轨迹。 大多数 VO 算法是基于特征点来估计运动的，特征点法的流程如图 1. 所示： Feature Detection(Extraction) and Matching/Feature Tracking特征提取并与上一帧的特征进行匹配，或者直接用上一帧的特征在这一帧进行跟踪； Motion Estimation在 \(k,k-1\) 帧之间求解 \(T_{k,k-1}\) 的过程，根据匹配的特征点对是 2D 还是 3D，运动估计可分为 3D-3D，3D-2D，2D-2D 三种方式实现； Local Optimization在 \(k,k-m\) 帧用 Bundle Adjustment 迭代优化求解最优的局部轨迹； 本文会重点阐述 Camera Model[1]，Feature Detection and Matching[2]，Motion Estimation[1]，Robust Estimation[2]，Local Optimization[2]。 3.&ensp;Camera Modeling and Calibration 相机模型及标定，另文详述。 4.&ensp;Feature Detection and Matching/Feature Tracking 生成前后帧特征点的匹配对，有两种方法： feature tracking用局部搜索的方法，较适用于相邻两帧视角变化不大的情况，会有漂移（drift）的现象； feature detection and matching独立在每个图像上进行检测，然后用某种度量准则进行匹配。在视野变化较大的情况下，只能用这种方法； 4.1.&ensp;Feature Tracking 主要采用 KLT（详见 KLT 算法详解）方法进行特征点跟踪。 4.2.&ensp;Feature Detection and Matching 特征点包含特征检测子与特征描述子。一个好的特征点应该有如下性质： 可重复性(Repeatability)，不同图像下相同特征点可再次检测出； 可区别性(Distinctiveness)，不同特征点表达形式不一样，可以更好匹配； 高效率(Efficiency)，计算高效； 本地性(Locality)，特征仅与一小片图像区域有关； 定位准确(Localization Accuracy)，不同尺度下定位都要准确； 鲁棒性(Robustness)，对噪声，模糊，压缩有较好的鲁棒； 不变性(Invariance)，对光照(photometric)，旋转，尺度，投影畸变(geometric)有不变性； 4.2.1.&ensp;Feature Detector 特征检测子（feature detector）的计算过程包含两步，首先将图像进行一个特征响应函数的变换，比如 Harris 中的 角点响应函数，SIFT 中的 DoG 变换；然后应用非极大值抑制，提取最小或最大值。 特征检测子可分为两类： 角点(corners)角点检测子被定义为至少两个边缘相交的地方；角点计算快，定位精度高，但是区分度低，大尺度下定位精度低； 斑点(blobs)斑点检测子被定义为一种与周围区域在亮度、颜色、纹理下不同的模式；区分度较高，但是速度较慢； 如图2. 所示，常用的角点检测子有 ORB 特征中的 FAST 关键点，Harris 角点等；常用的斑点检测子有 SIFT，SURF，CENSURE 等。 4.2.2.&ensp;Feature Descriptor 有了特征检测子后，为了特征点匹配，还需要描述这个检测子，描述量称为特征描述子。描述子可分为以下几类： Appearance，检测子周围的像素信息 SSD 匹配，sum of squared difference，计算检测子周围像素亮度与其的误差和； NCC 匹配，normalized cross correlation，相比 SSD，有一定的光照不变性； Census Transform，将检测子周围的 patch 像素与其进行对比，合成 0,1 向量； Histogram of Local Gradient Orientations SIFT，光照，旋转，尺度，均具有不变性；不适用于角点，适用于斑点； Much Faster BRIEF，二进制描述子，用于 ORB；对于旋转和尺度有较强的区分性，并且提取以及比较速度都很快； 目前常用的 ORB 特征，采用的是 Oriented FAST 角点，以及 BRIEF 描述子。 4.2.3.&ensp;Feature Matching 通过比较特征点中的描述子部分，来完成特征点的匹配。如果是 appearance 描述子，那么一般通过 SSD/NNC 来计算描述子之间的相似度，其它二进制描述子，可通过欧氏距离或汉明距离来度量。 基于相似性度量的特征匹配，最简单的就是暴力匹配，两组特征点挨个计算相似度。暴力匹配时间复杂度较高，通常我们采用快速近似最近邻算法（FLANN），也可以加入运动估计模型（通过 IMU 等装置获得的大致运动位姿）来缩小搜索范围。特殊的如果是双目系统，因为左右目图像都是矫正过的，所以左右目的特征点匹配可通过行矩阵搜索解决。 匹配结束后，我们还得进一步验证匹配的正确性，去除误匹配的情况。比如相互一致性验证，每个特征点只能匹配一个特征点。 实验表明特征点的分布也很影响匹配效果，特征应尽量均匀分布，可以将图像栅格化，然后对不同的栅格用不同的特征检测阈值即可，保证栅格之间特征数量相等。 5.&ensp;Motion Estimation5.1.&ensp;2D-2D 这种情况下特征点 \(f_{k-1},f_k\) 分别是在 2D 图像 \(I_{k-1},I_k\) 坐标系上。 对极约束推倒过程可详见这里。根据对极约束，可推导出同一 3D 点投影到两个相机视角图像下后，其坐标之间的关系：$$p_2^TK^{-T}t^{\wedge} RK^{-1}p_1=0$$记本质矩阵(Essential Matrix)\(E=t^{\land} R\)，记基础矩阵(Fundamental Matrix)\(F=K^{-T}EK^{-1}\)。基础矩阵描述的是两幅图像对应点的像素坐标的关系；本质矩阵描述的是世界中的某点分别在两个相机坐标系下坐标的相对关系。 一般相机内参是已知的，所以我们求解本质矩阵。可采用五点法或者八点法来求解，五点法只能处理已知相机标定参数的情况，所以我们一般采用八点法来求解本质矩阵 \(E\)，大于八点即可用最小二乘求解线性方程。然后对本质矩阵进行奇异值分解，即可求出相机的位姿 \(R,t\)。 当选取的点共面时，基础矩阵的自由度下降，即出现退化的现象，这个时候需要同时求解单应矩阵\(H\)，选择重投影误差较小的那个作为最终的运动估计矩阵。 此外，还需计算当前运动的相对尺度，可由 3D 点的位置信息求解相对尺度。绝对尺度的求解需要三角化求解。 总结过程如下： 得到新的当前帧 \(I_K\); 提取当前帧的特征点，并与上一帧的特征进行匹配； 根据匹配的特征点对，计算本质矩阵\(E\)； 奇异值分解本质矩阵，得到相机运动 \(R_K,t_k\)； 该相邻帧的相机运动信息与之前相机运动信息进行累计； 重复 1.； 5.2.&ensp;3D-2D 这种情况下，特征点 \(f_{k-1}\) 是 3D 坐标点，\(f_k\) 是其投影到 2D 图像 \(I_K\) 上的匹配点。对于单目的情况，\(f_{k-1}\) 需要从相邻的前面帧中（比如 \(I_{k-2},I_{k-1}\)）三角化出 3D 坐标，然后与当前帧进行匹配，至少需要三帧的视角。3D-2D 比 3D-3D 更加精确，因为 3D-3D 直接优化相机运动，没有优化投影的过程。 该问题也称为 PnP(Perspective from n Points)。PnP 问题有很多种求解方法： P3P只是用 3 个点对进行求解，容易受误匹配的影响； 直接线性变换需要 6 对匹配点才能求解，如果大于 6 对，则可用 SVD 等方法求线性方程的最小二乘解； EPnP UPnP 非线性优化(Bundle Adjustment)记 \(p_{k-1}^i\) 为 \(k-1\) 时刻下第 \(i\) 个特征点在相机坐标系下的坐标，定义重投影的误差项：$$\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert uv^i_k-K \, T_{k,k-1} \, p_{k-1}^i \right\Vert^2$$ 总结过程如下： 初始化，在 \(I_{k-2},I_{k-1}\) 两张图里提取特征并匹配，三角花得到特征点的 3D 坐标； 在 \(I_k\) 图像中提取特征点，并与上一帧的特征进行匹配； 用 PnP 求解相机运动； 在 \(I_{k-1},I_{k}\) 中三角化所有特征点； 重复 2.； 5.3.&ensp;3D-3D 这种情况下特征点都是 3D 坐标点，都需要三角花得到，可以使用一个立体视觉系统。 已知两组匹配好的 3D 点，可以用 ICP(Iterative Closest Point) 来求解位姿。ICP 有两种求解方式： 线性求解 非线性优化(类似 Bundle Adjustment)定义重投影的误差项：$$\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert p_{k}^i - T_{k,k-1} \, p_{k-1}^i \right\Vert^2$$ ICP 问题存在唯一解或无穷多解的情况，所以非线性优化时，只要找到极小值，那一定是全局最优解，这也意味着 ICP 非线性优化时可以任意选定初始值。 在匹配已知的情况下，ICP 问题是有解析解的。不过如果有些特征点观察不到深度，那么可以混合着使用 PnP 和 ICP 优化：对于深度已知的特征点，建模 3D-3D 误差，对于深度未知的特征点，建模 3D-2D 的重投影误差。两个误差项，用非线性优化求解。 5.4.&ensp;Triangulation and Keyframe Selection 对于 stereo camera， 3D-2D 比 3D-3D 更准确；3D-2D 比 2D-2D 计算更快，前者是 P3P 问题，后者则至少需要 5 个点。当场景中物体相比基线很大时，那么立体视觉系统就失效了，这时候用单目视觉系统比较靠谱。 对于 monocular camera，2D-2D 比 3D-2D 看样子更好，因为避免了三角测量；然后实际中，3D-2D 用得更多，因为数据关联更快。 当两帧之间相隔很短时间时，可以认为基线非常小，这种情况，获得的深度信息不确定性很高，所以需要选择某些 keyframes 来计算。 6.&ensp;Robust Estimation/Outlier Rejection 匹配的特征点可能因为噪音、遮挡、模糊、视角变化、光照变化等原因成为外点（outliers），这时候该匹配对对运动估计来说就是个外点，估计的时候应该想办法去除掉。 RANSAC 目前已是在含有噪声的数据中进行模型估计的标准方法。其思想是随机选取一些数据进行建模，涵盖数据最多的模型即被选择是最终模型。对于相机运动估计来说，模型就是相机的运动 \(R,t\)，数据就是特征匹配对。RANSAC 流程为： 初始化，记 A 为特征点对集； 从 A 中随机选取一些点对 s； 用 s 估计运动模型； 计算所有的点对与这个模型的距离误差，可使用 point-to-epipolar 距离或是 directional 误差(Sampson distance)； 统计距离误差小于一定阈值的点对的数量，并存储标记这些内点(inliers)； 重复 2.，直到达到最大迭代次数； 选取数量最多的内点点对集，用这些点估计最终模型； 为保证得到正确解，迭代次数要求：$$N=\frac{log(1-p)}{log(1-(1-\epsilon)^s)}$$其中，\(p\) 表示得到正确解的概率，\(\epsilon\) 表示外点的百分比，\(s\) 表示每次模型估计取出的点数。如图 3. 所示，选出的点数越少，迭代次数就可以越少。这个角度来讲，五点法比八点法有优势，但是五点法的前提是相机都是标定过的。不过不考虑速度的话，还是选择更多的点，因为可以平滑噪声。 7.&ensp;Local Optimization 每次估计的相机运动都有误差，随着运动的累计，误差也会累计。这就要求做局部最优化，消除轨迹的漂移。优化方式有 Pose-Graph Optimization（需要回环检测） 以及 Windowed Bundle Adjustment 两种，这里主要介绍 BA。定义误差函数：$$\xi=\mathop{\arg\min}\limits_{X^i,C_k} \sum_{i,k} \left\Vert uv_{k}^i - g(X^i,C_k) \right\Vert^2$$其中 \(X^i\) 为世界坐标系下特征点的 3D 坐标，\(C_k = T_{1,0}…T_{k,k-1}\)，\(g(X^i,C_k)\)为特征点投影到图像的映射函数。该非线性问题可用 Newton-Gauss 或 LM 法解决。为了加速运算，如果 3D 特征点是准确的(如立体视觉获得的)，那么可以固定特征点的 3D 量，只优化相机的轨迹。 [1] Scaramuzza, Davide, and Friedrich Fraundorfer. “Visual odometry [tutorial].” IEEE robotics &amp; automation magazine 18.4 (2011): 80-92.[2] Fraundorfer, Friedrich, and Davide Scaramuzza. “Visual odometry: Part ii: Matching, robustness, optimization, and applications.” IEEE Robotics &amp; Automation Magazine 19.2 (2012): 78-90.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>paper reading</tag>
        <tag>VO</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving"]]></title>
    <url>%2F%5Bpaper_reading%5D-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving%2F</url>
    <content type="text"><![CDATA[本文[1]结合 Semantic SLAM 与 Learning-based 3D Det 技术，提出了一种用于自动驾驶的动态目标定位与本车状态估计的方法。本文系统性较强，集成了较多成熟的模块，对工程应用也有较强的指导意义。 如图 1. 所示，整个系统框架由三部分组成： 2D object detection and viewpoint classification，目标位姿通过 2D-3D 约束求解出来； feature extraction and matching，双目及前后帧的特征提取与匹配； ego-motion and object tracking，将语义信息及特征量加入到优化中，并且加入车辆动力学约束以获得平滑的运动估计。 1.&ensp;Viewpoint Classification and 3D Box Inference1.1.&ensp;Viewpoint Classification 选用 Faster R-CNN 作为 2D 检测框架，在此基础上，加入车辆视野（viewpoint）分类分支。由图 2. 所示，水平视野分为八类，垂直视野分为两类，总共 16 类。 1.2.&ensp;3D Box Inference Based on Viewpoint 网络输出图像 2D 框以及目标车辆的视野类别（viewpoint），此时我们假设： 2D 框准确； 每种车辆的尺寸相同； 2D 框能紧密包围 3D 框； 在以上假设条件下，我们可以求得 3D 框，该 3D 框作为后续优化的初始值。约束方程的表示在论文中比较晦涩，在这里我做细致的推倒。 3D 框可表示为 \(\{x,y,z,\theta,w,h,l\}\)，其中 \(\{w,h,l\}\) 分别对应 \(\{x,y,z\}\) 维度。如图 2.(b) 所示，这个视角下，四个 3D 框的顶点，可得四个约束方程。推倒过程为：$$\require{cancel}\begin{bmatrix}u_{min}\\v_1\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{1}^{cam}\\y_{1}^{cam}\\z_{1}^{cam}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{1}^{obj}\\y_{1}^{obj}\\z_{1}^{obj}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}\frac{w}{2}\\\frac{h}{2}\\\frac{l}{2}\\\end{bmatrix}$$其中 \(K\) 为相机内参，做归一化处理消去；\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)^{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，②，③，④ 点都可以由此获得：$$\left\{\begin{array}{l}\require{cancel}\begin{bmatrix}u_{min}\\v_1\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{1}^{cam}\\y_{1}^{cam}\\z_{1}^{cam}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{1}^{obj}\\y_{1}^{obj}\\z_{1}^{obj}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}\frac{w}{2}\\\frac{h}{2}\\\frac{l}{2}\\\end{bmatrix}\\\begin{bmatrix}u_{max}\\v_2\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{2}^{cam}\\y_{2}^{cam}\\z_{2}^{cam}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{2}^{obj}\\y_{2}^{obj}\\z_{2}^{obj}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}-\frac{w}{2}\\\frac{h}{2}\\-\frac{l}{2}\\\end{bmatrix}\\\begin{bmatrix}u_3\\v_{min}\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{3}^{cam}\\y_{3}^{cam}\\z_{3}^{cam}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{3}^{obj}\\y_{3}^{obj}\\z_{3}^{obj}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}\frac{w}{2}\\-\frac{h}{2}\\-\frac{l}{2}\\\end{bmatrix}\\\begin{bmatrix}u_4\\v_{max}\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{4}^{cam}\\y_{4}^{cam}\\z_{4}^{cam}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{4}^{obj}\\y_{4}^{obj}\\z_{4}^{obj}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}-\frac{w}{2}\\\frac{h}{2}\\\frac{l}{2}\\\end{bmatrix}\end{array}\right.$$ 将 \(z\) 方向归一化后，进一步得到最终的四个约束式子：$$\left\{\begin{array}{l}u_{min}=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\u_{max}=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\v_{min}=(y- \frac{h}{2}) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\v_{max}=(y+ \frac{h}{2}) / (z+ \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\end{array}\right.$$以上四个方程可以闭式求解 3D 框 \(\{x,y,z,\theta\}\)。该方法将 3D 框的回归求解分解成了 2D 框回归，视野角分类以及解方程组的过程，强依赖于前面的三点假设，实际情况 3D 框与 2D 框不会贴的很紧。这个 3D 框结果只用来作后续的特征提取区域及最大后验概率估计的初始化。 2.&ensp;Feature Extraction and Matching 这一部分做的是左右目及前后帧特征提取及匹配。选用 ORB 特征，目标区域由投影到图像的 3D 框确定。 目标区域内左右目的立体匹配由于已知目标的距离及尺寸，所以只需要在一定小范围内进行特征点的行搜索匹配。 目标及背景区域下前后帧的时序匹配首先进行 2D 框的关联，2D 框经过相机旋转补偿后，最小化关联框的中心点距离及框形状相似度值。然后在关联上的目标框区域以及背景区域里，分别作 ORB 特征的匹配，异常值在 RANSAC 下通过基础矩阵测试去除。 3.&ensp;Ego-motion and Object Tracking 首先进行本车运动状态估计，可在传统 SLAM 框架下做，不同的是将动态障碍物中的特征点去除。有了本车的位姿后，再估计动态障碍物的运动状态。文中符号定义较为复杂，这里不做赘述。 3.1.&ensp;Ego-motion Tracking 给定左目前后帧背景区域特征点的观测，本车状态估计可以通过极大似然估计（Maximum Likelihood Estimation）得到。MLE 可以转化为非线性最小二乘问题，也就是 Bundle Adjustment 过程，这是典型的 SLAM 问题。文中给出的误差方程：需要求解的是本车位姿以及背景特征点坐标，这是后验概率，可转为似然函数求解，然后转化为非线性优化问题。可参考《视觉 SLAM 十四讲》(107-108)来理解。 3.2.&ensp;Semantic Object Tracking 得到本车相机的位姿后，运动目标的状态估计可以通过最大后验概率估计（Maximum-a-posterior, MAP）得到。类似的，可转为非线性优化问题进行求解，联合优化每个车辆的位姿，尺寸，速度，方向盘转角，所有特征点 3D 位置。有四个 loss 项：\(r_Z,r_P,r_M,r_S\) 分别代表： Sparse Feature Observation目标上的特征点重投影到左右目图像的误差，注意有左右目两个误差项； Semantic 3D Object Measurement3D 框投影到图像上与 2D 框的尺寸约束投影误差，即 1.2 节中的形式，区别在车辆尺寸与位姿作为了优化项； Vehicle Motion Model对于车辆，前后时刻的状态要有连续性，即误差最小； Point Cloud Alignment为了减少 3D 框的整体偏移，引入特征点到 3D 观察面的最小距离误差； 这里只对车辆运动模型进行分析，其它几项基本在前文已经有描述或者比较常识化，就不展开，具体公式可参见论文。 由实验可知 Sparse Feature Observation 与 Point Cloud Alignment 对性能提升较明显，Motion Model 对困难情景性能才有提升。 3.2.1.&ensp;Vehicle Motion Model [2] 中介绍了前转向车的两种模型：运动学模型(Kinematic Bicycle Model)，以及更复杂的动力学模型(Dynamic Bicycle Model)。运动学模型假设车辆不存在滑动，这在大多数情况下都是满足的，所以我们只介绍运动学模型。 如图 3. 所示，前后轮无滑动的约束下，可得方程组：$$\left\{\begin{array}{rl}\dot{x}_fsin(\theta+\delta)-\dot{y}_fcos(\theta+\delta)=&amp;0\\\dot{x}sin(\theta)-\dot{y}cos(\theta)=&amp;0\\x+Lcos(\theta)=&amp;x_f \quad\Rightarrow \quad \dot{x}-\dot{\theta}Lsin(\theta)=\dot{x}_f\\y+Lsin(\theta)=&amp;y_f \quad\Rightarrow \quad \dot{y}+\dot{\theta}Lcos(\theta)=\dot{y}_f\end{array}\right.$$由此可得到:$$\dot{x}sin(\theta+\delta)-\dot{y}cos(\theta+\delta)-\dot{\theta}Lcos(\delta)=0$$用 \(\left(v \cdot cos(\theta),v\cdot sin(\theta)\right)\) 代替 \((\dot{x},\dot{y})\) 可得：$$\dot{\theta}=\frac{tan(\delta)}{L}\cdot v$$最终可整理成矩阵形式：$$\begin{bmatrix}\dot{x}\\\dot{y}\\\dot{\theta}\\\dot{\delta}\\\dot{v}\\\end{bmatrix}=\begin{bmatrix}0 &amp;0 &amp;0 &amp;0 &amp;cos(\theta)\\0 &amp;0 &amp;0 &amp;0 &amp;sin(\theta)\\0 &amp;0 &amp;0 &amp;0 &amp;\frac{tan(\delta)}{L}\\0 &amp;0 &amp;0 &amp;0 &amp;0\\0 &amp;0 &amp;0 &amp;0 &amp;0\\\end{bmatrix}\begin{bmatrix}x\\y\\\theta\\\delta\\v\\\end{bmatrix}+\begin{bmatrix}0 &amp;0\\0 &amp;0\\0 &amp;0\\1 &amp;0\\0 &amp;1\\\end{bmatrix}\begin{bmatrix}\gamma\\\alpha\\\end{bmatrix}$$其中 \(L\) 为车辆参数。观测量有： \((x,y,\theta)\) 为车辆的位置及朝向角； \(\delta\) 为方向盘/车轮转角； \(v\) 为车辆速度； 控制量有： \(\gamma\) 为方向盘角度比率； \(\alpha\) 为加速度； 本文的目的是要约束车辆时序上运动(速度及朝向)的平滑一致性，令控制量 \(\gamma,\alpha\) 为 0，然后可得状态量在相邻时刻的关系应满足：$$\left\{\begin{array}{l}\hat{x}^t=x^{t-1}+cos(\theta^{t-1})v^{t-1}\Delta t\\\hat{y}^t=y^{t-1}+sin(\theta^{t-1})v^{t-1}\Delta t\\\hat{\theta}^t=\theta^{t-1}+\frac{tan(\delta^{t-1})}{L}v^{t-1}\Delta t\\\hat{\delta}^t=\delta^{t-1}\\\hat{v}^t=v^{t-1}\end{array}\right.$$由此可整理成论文中矩阵的形式及误差项： [1] Li, Peiliang, and Tong Qin. “Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving.” Proceedings of the European Conference on Computer Vision (ECCV). 2018.[2] Gu, Tianyu. Improved trajectory planning for on-road self-driving vehicles via combined graph search, optimization &amp; topology analysis. Diss. Carnegie Mellon University, 2017.]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[paper_reading]-"Stereo R-CNN based 3D Object Detection for Autonomous Driving"]]></title>
    <url>%2F%5Bpaper_reading%5D-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving%2F</url>
    <content type="text"><![CDATA[Learning 方法有什么致命缺点吗？我认为目前 Learning 方法还存在的较为棘手的问题是，有时候结果会出现非常低级的错误，或是说不可思议不合常理的 cornercases。所以我认为一个工程系统或是一个鲁棒的算法系统，在 Learning 之后做一个基于常理（如 geometry 约束或专家系统）的验证，能有效抑制这个问题。本文就是一个比较好的 learning+geometry 想结合的方法。 本文[1]基于图像语义及几何信息，通过 3D 目标的稀疏与密集约束，提出了一种准确的 3D 目标检测方法。根据输入数据的类型，作者将 3D 检测分为三大类： LiDAR-based，近期被研究的较多，基本是自动驾驶所必须的； Monocular-based，低成本方案； Stereo-based，相比 Monocular-based，有优势，但是研究较少； 本文就是 Stereo-based 3D 检测方案。不同于一般的 rgb+depth 作为输入的方案，本文直接将左右目 rgb 作为输入，没有显示地 depth 生成过程。工程上来说，这也极大地缩短了 3D Detection 的时延(latency)。 本文方法如图 1 所示，主要有三部分组成： &ensp;Network，又有三部分构成： Stereo RPN Module，输出左右图的 RoI； Classification and Regression branches，输出目标类别，朝向，尺寸； Keypoint branch，输出左目目标的关键点； &ensp;Sparse constraints，3D 框-2D 框的稀疏约束； &ensp;Dense constraints，准确定位的关键模块； 1.&ensp;Stereo R-CNN Network Stereo R-CNN 是在 Faster R-CNN 基础上，同时检测与关联左右目图像 2D 框的微小差异。 1.1.&ensp;Stereo RPN 在传统 RPN 网络的基础上，本文先对左右图做 paramid features 提取，然后将不同尺度的特征 concatenate 一起，进入 RPN 网络。 关键的一点是 objectness classification与 stereo box regression 的真值框定义不一样。如图 2 所示， 对于 objectness classification，真值框定义为左右目真值框的外接合并（union GT box），一个 anchor 在与真值框的交并比（Intersection-over-Union）大于 0.7 时标记为正样本，小于 0.3 时标记为负样本。分类任务的候选框包含了左右目真值框区域的信息。 对于 stereo box regression，真值框定义为左右目分别的真值框。待回归的参数定义为 \([\Delta u, \Delta w, \Delta u’, \Delta w’, \Delta v, \Delta h]\)，分别为左目的水平位置及宽，右目的水平位置及宽，垂直位置及高。因为输入为矫正过的左右目图像，所以可认为左右目的垂直方向上已经对齐。 每个左右目的 proposal 都是通过同一个 anchor 产生的，自然左右目的 proposal 是关联的。通过 NMS 后，保留左右目都还存在的 proposal 关联对，取前 2000 个用于训练，测试时取前 300 个。 1.2.&ensp;Stereo R-CNN 网络头包含两大部分： &ensp;Stereo Regression左右目的 proposal 关联对，分别在左右目的 feature 上进行 RoI Align 的操作，然后 concatenate 输入到全链接层。左右目的 RoI 对与真值框的 IoU 均大于 0.5 时定位正样本，左右目的 RoI 对与真值框的 IoU 有一个小于 0.5 且大于 0.1，则定位负样本。用四个分支分别预测： object class； stereo bounding boxes，与 stereo rpn 中一致，左右目的高度已对齐； dimension，先统计平均的尺寸，然后预测相对量； viewpoint angle，如图 3 所示，\(\theta\) 为相机坐标系下的朝向角，\(\beta\) 为相机中心点下的方位角(azimuth)，这三个目标在相机视野下是一样的，所以我们回归的量是视野角(viewpoint angle) \(\alpha=\theta+\beta\)，其中 \(\beta=arctan\left(-\frac{x}{z} \right) \)。并且为了连续性，回归量为 \([sin\,\alpha,cos\,\alpha]\)。 &ensp;Keypoint Prediction如图 4 所示，考虑 3D 框底部矩形的四个关键点，投影到图像平面后，最多只有一个关键点会在图像 2D 矩形框内。对左目图像进行关键点预测，类似 Mask R-CNN，在 6×28×28 的基础上，因为关键点只有图像坐标 u 方向才提供了额外的信息，所以对每列进行累加，最终输出 6×28 的向量。前 4 个通道代表每个关键点作为 perspective keypoint 投影到该 u 坐标下的概率；后 2 个通道代表该 u 坐标是左右边缘关键点(boundary keypoints)的概率。为了找出 perspective keypoint，softmax 应用于 4×28 的输出上；为了找出左右边缘关键点，softmax 分别应用于后两个 1×28 的输出上。训练的时候，4×28 中只有一个被赋予 perspective keypoint，忽略没有 perspective keypoint 的情况（遮挡等），然后最小化 cross-entropy loss；对于边缘关键点，则分别最小化 1×28 维度上的 cross-entropy loss，前景中也会被赋予边缘关键点。 2.&ensp;3D Box Estimation 已知关键点，2D 框，尺寸，朝向角，我们可以求解出 3D 框 \(\{x,y,z,\theta\}\)。求解目标是最小化 3D 框投影到 2D 框以及关键点的误差。如图 5 所示，已知 7 个观测量 \(z = \{u_l,v_t,u_r,v_b,u’_l,u’_r,u_p\}\)，分别代表左目 2D 框的左上坐标，右下坐标，右目 2D 框的左右 u 方向坐标，以及 perspective keypoint 的 u 方向坐标。在图 5 的情况下（其它视角下，注意符号变化），左上点投影关系如下：$$\require{cancel}\begin{bmatrix}u_l\\v_t\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{cam}^{tl}\\y_{cam}^{tl}\\z_{cam}^{tl}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{obj}^{tl}\\y_{obj}^{tl}\\z_{obj}^{tl}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}-\frac{w}{2}\\-\frac{h}{2}\\-\frac{l}{2}\\\end{bmatrix}$$其中 \(K\) 为相机内参，\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)_{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，右下点为：$$\require{cancel}\begin{bmatrix}u_l\\v_t\\1\\\end{bmatrix}=K\cdot\begin{bmatrix}x_{cam}^{tl}\\y_{cam}^{tl}\\z_{cam}^{tl}\\\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot\begin{bmatrix}x_{obj}^{tl}\\y_{obj}^{tl}\\z_{obj}^{tl}\\\end{bmatrix}=\begin{bmatrix}x\\y\\z\\\end{bmatrix}+\begin{bmatrix}cos\theta &amp; 0 &amp;sin\theta\\0 &amp; 1 &amp; 0\\-sin\theta &amp; 0 &amp; cos\theta\\\end{bmatrix} \cdot\begin{bmatrix}\frac{w}{2}\\\frac{h}{2}\\-\frac{l}{2}\\\end{bmatrix}$$右目两个边缘点以及 perspective keypoint 点也可同样得到，由此可整理出 7 个方程组（论文中第一个公式符号有错）：$$\left\{\begin{array}{l}u_l=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\v_t=(y- \frac{h}{2}) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\u_r=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\v_b=(y+ \frac{h}{2}) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\u’_l=(x-b- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\u’_r=(x-b+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\u_p=(x+ \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\\end{array}\right.$$其中 \(b\) 为双目的基线长(baseline)。以上方程组可用 Gauss-Newton 法求解。 3.&ensp;Dense 3D Box Alignment 以上得到的目标 3D 位置是 object-level 求解得到的，利用像素信息，还可以进行优化精确求解。首先在图像 2D 目标框内扣取一块 RoI，要使 RoI 能较为确定的在目标上，扣取方式定义为： 目标一半以下区域； perspective keypoint 与边缘关键点包围区域； 关键点预测的时候只预测了 u 方向的坐标，边缘关键点无 v 方向的信息，看起来会使某些背景像素被划入为目标像素，更好的方法是加入 instance segmentation 信息。定义误差函数为：$$E=\sum_{i=0}^N e_i=\sum_{i=0}^N \left\| I_l(u_i,v_i)-I_r(u_i-\frac{b}{z+\Delta z_i},v_i)\right\|$$可由三角测量关系 \(z=\frac{bf}{d}\) 推出。上式中，\(\Delta z_i=z_i-z\) 表示某个像素点 \(i\) 所对应的 3D 点与目标中心点之间的距离。最小化总误差即可求得最优的中心点距离 \(z\)。优化过程可以用 coarse-to-fine 的策略，先以 0.5m 的精度找 50 步，再以 0.05m 的精度找 20 次。 这个 dense alignment 模块是独立的，可以应用到任意的左右目 3D 检测的后处理中。因为目标 RoI 是物理约束，所以这个方法避免了深度估计中不连续、病态的问题，且对光照是鲁棒的，因为每个像素都会对估计起作用。这里，本文只做了中心点的 align，尺寸，甚至朝向角是否能加入优化? 4.&ensp;Other Details [1] Li, Peiliang, Xiaozhi Chen, and Shaojie Shen. “Stereo R-CNN based 3D Object Detection for Autonomous Driving.” arXiv preprint arXiv:1902.09738 (2019).]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT Metrics in Academia and Industry]]></title>
    <url>%2FMOT-Metrics-in-Academia-and-Industry%2F</url>
    <content type="text"><![CDATA[MOT 是一个比较基本的技术模块，在视频监控中，常用于行人行为分析、姿态估计等任务的前序模块；在自动驾驶中，MOT 是动态目标状态估计的重要环节。在学术界，MOT 算法性能的评价准则已经较为完善，其指标主要关注，尽可能地覆盖所有性能维度，以及指标的简洁性（上一篇有较多介绍，the CLEAR MOT Metrics）。而工业界则尚无统一的标准，实际的指标需求情况也比学术界复杂。 指标的计算过程可由三部分组成，真值过滤(Filter)，匹配构建(Establishing Correspondences)与指标计算(Calculating Metrics)。其中真值过滤，更多的是工程细节，学术界没有文章对这一部分进行讨论研究。本文首先介绍学术界各评价指标详情，然后讨论工业界需要的评价指标又是怎样的。 1.&ensp;Metrics in Academia 在学术界，因为数据集质量较高，噪声相对较小，匹配构建中距离的度量偏向于严格且简单的方式。对于区域(框)跟踪器，采用重叠区域来度量；对于点跟踪器，采用中心点的欧式距离来度量。指标汇总如下：A.&ensp;检测指标 \(\lozenge\) 准确性(Accuracy) Recall = \(\frac{TP}{GT}\)； Precision = \(\frac{TP}{TP+FP}\)； FAF/FPPI[1][2] ，Average False Alarms per Frame；False Positive Per Image; MODA[3]，Multipe Object Detection Precision，整合了 FN 与 FP，设 \(c_m, c_f\) 分别为 FN，FP 的权重：$$MODA=1-\frac{\sum_{t=1}^{N_frames}(c_m(fn_t)+c_f(fp_t))}{\sum_{t=1}^{N_frames}gt_t}$$ \(\lozenge\) 精确性(Precision) MODP[3]，Multiple Object Detection Accuracy，$$MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; dist}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}$$其中 \(N_{mapped}^{(t)}\) 为第 \(t\) 帧匹配的目标数；\(dist\) 为距离度量方法，如框的交并比度量法：$$Mapped Overlap Ratio = \frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|}$$ B.&ensp;跟踪指标 \(\lozenge\) 准确性(Accuracy) IDS[4]，ID switch，a tracked target changes its ID with another target(预测关联真值)； MOTA[5]，Multiple Object Tracking Accuracy，整合了 FN，FP，ID-Switch：$$MOTA=1-\frac{\sum_{t=1}^{N_{frames}} \;\; (c_m(fn_t)+c_f(fp_t)+c_s(ID-SWITCHES_t))}{\sum_{t=1}^{N_{frames}} \;\; gt_t}$$其中权重方程一般可设为：\(c_m=c_f=1, \quad c_s=log_{10}\)； \(\lozenge\) 精确性(Precision) MOTP[5]，Multiple Object Tracking Precision，$$MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; \left(\frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|} \right)}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}$$ TDE[6]，Distance between the ground-truth annotation and the tracking result；像素级别的误差计算，适用于人群跟踪； OSPA[7][8]，Optimal Subpattern assignment，由定位 (localization) 误差及基数 (cardinality) 误差构成，对于第 \(t\) 帧：$$e^t=\left[\frac{1}{n^t}\left( \mathop{\min}_{\pi\in\Pi_n} \sum_{i=1}^{m^t} d^{(c)}(x_i^t,y_{\pi(i)}^t)^p + (n^t-m^t)\cdot c^p \right) \right]^{1/p}$$其中，\(n^t\) 为目标真值与算法输出中数量较大者。\(\Pi_n\) 为从 \(n^t\) 中取出的 \(m\) 个目标。\(p\) 为距离指数范数。其中定位截断误差为：$$d^{(c)}(x_i^t,y_{\pi(i)}^t) = \mathop{\min}\left(c,d(x_i^t,y_{\pi(i)}^t)\right)$$\(c\) 为截断参数。定位误差又由距离误差和标签误差组成：$$d(x_i^t,y_{\pi(i)}^t=\parallel x_i^t-y_{\pi(i)}^t\parallel + \alpha \; \bar{\delta}(l_x, l_y)$$其中 \(\alpha\in[0,c]\)，为标签误差的权重系数。如果 \(l_x=l_y\)，\(\bar{\delta}(l_x, l_y)=0\)，否则 \(\bar{\delta}(l_x, l_y)=1\). \(\lozenge\) 完整性(Completeness) MT[9]，Mostly Tracked，真值轨迹长度被跟踪大于80%的比例； ML[9]，Mostly Lost，真值轨迹长度被跟踪小于20%的比例； PT[9]，Partially Tracked，\(1-MT-ML\); FM[9]，Fragments，ID of a target changed along a GT trajectory, or no ID(真值关联预测)； \(\lozenge\) 鲁棒性(Robustne) RS[10]，Recover from short term occlusion; RL[10]，Recover from long term occlusion; 2.&ensp;Metrics in Industry 工业界的数据噪声较大，传感器配置也比较多样，不同的产品（传感器+算法），对 MOT 性能维度要求也不一样。更重要的是，评价指标应该从功能层面进行定义，在模块层面 (MOT) 进行调整及细化。可以说，工业界是以学术界为基础来设计 MOT 指标的，不同的产品没有统一的标准，但有比较通用的设计准则。 这里以自动驾驶/辅助驾驶中动态目标状态估计模块为例，模块详细分析日后再写。该模块的基本输入为： 传感器数据，可以是图像，激光等； 自定位系统，可以是基于视觉的 VO，基于视觉-IMU 的 VINS等；其中自定位系统能使目标状态估计在世界坐标系（惯性系）下优化，否则只能在本体（ego）非惯性系下优化，会减少一些约束量。该功能的基本输出为： 位置，本体坐标系下目标的三维位置，\(x,y,z\)； 尺寸，目标的物理尺寸大小，包括立方体的长宽高；或者图像坐标系下的像素大小；或者图像/点云下目标的 mask，即分割后的目标； 朝向，一般只考虑目标的航向角； 速度，本体坐标系或世界坐标系下的三维速度，一般只考虑航向平面的速度； 其中朝向是非必须项，有了朝向后，能更有效地进行状态优化。该模块的子模块有（注意，MOT 只包含前三者）： 检测(Detection)，进行多目标检测； 跟踪(Tracking)，根据上一帧结果，进行多目标跟踪； 数据关联(Association)，检测结果与跟踪结果的融合，出目标的 tracklets，生成 ID； 状态估计(State Estimation)，不同的方法包括不同的部分； 工业界设计产品时，基本遵循自顶向下的策略：产品需求-功能需求-模块需求，层层推倒。所以我们设计评价准则时，一般会问几个问题： 该模块服务的产品功能，其需求及对应的指标是什么？ 要达到功能指标，本模块的输出需要哪些指标来评测？ 各个子模块对模块的影响是怎样的，对应需要增加哪些指标？ 这里提到了功能指标，模块指标，子模块指标三层概念。功能指标及部分模块指标是可以写入产品手册的，所以需要突出重点，易于理解；部分模块及子模块指标则主要是为了产品上工程优化迭代，这就要求这部分指标要相当细致，将模块的不足尽可能解耦，且完全暴露出来。以下通过两个例子来分析设计过程。 2.1.&ensp;ADAS 中的 FCW 功能 FCW 基本功能要求为： 不允许误报，尽可能不漏报； 在 V km/h 下，以一定的刹车加速度 a，能避免与静止的前车相碰撞； 由以上两个功能需求，可确定必须的功能指标： （百公里）误报率； （百公里）漏报率； 观测距离，可由第二项功能要求推到出（人反应时间已知）； 相应的 MOT +状态估计模块输出的指标为各距离维度各类别维度下的： 误检率； 漏检率； ID Switch； 定位精度； 速度估计精度； 其中 MOT 主要涉及误检率，漏检率，ID Switch（直接影响状态估计模块）。这些指标的计算方式可以在学术界定义的基础上做进一步改进，比如漏检率，就需要体现出百公里漏报率的性能，所以可以考虑将连续 N 帧漏检的目标才归为漏检，分母可以定义为每多少帧。此外，要在各距离维度各类别维度下进行计算，这就涉及到过滤（filter）策略。对于 FCW 而言，首要关注的是本车前方近距离位置，距离维度上的功能重要程度要突显出来，类别维度也要区别对待，以便算法模块可以重点优化。 2.2.&ensp;自动驾驶中的动态障碍物检测功能 自动驾驶中动态障碍物检测的要求就高了，子模块也较为复杂，指标除了评估功能模块的性能，还需要指导迭代各子模块算法，包括本子模块的迭代比较，以及上下游模块相关指标的对比。 功能需求，我们简单列举几项： 不允许漏检，尽可能不误检； 前向，后向，侧向观测距离分别要达到 x, y, z； 相应的功能指标为： 漏检率； 误检率； 观测距离； 观测精度； 观测时延(delay)； MOT +状态估计模块输出的指标依然在各距离维度各类别维度下： 误检率； 漏检率； ID Switch； 定位精度； 尺寸，朝向，速度估计精度； 状态估计收敛时间； 一系列描述时序稳定性的指标； 与前述 FCW 功能类似，只是多了较多的指标。过滤操作也做的更加细致，我们还可以将目标做重要性等级划分，比如本车道前车多少米内，那指标基本都要达到 99%+；还可以将地面区域做重要性划分（比距离维度更加细致，可以认为是三维层面），周围几米内，那误检率肯定要非常低。除了过滤策略需要仔细设计外，匹配策略也需要进一步思考。如果传感器本身精度就有限，那么匹配策略就要相应放宽。还需注意的是引入过滤策略后，FP与FN计算的细微差别，比如有个过滤条件为去除目标像素面积小于一定阈值的目标集 A，观测值与真值匹配时，如果与 A 中的目标匹配上，那么不应该记为 FP，如果没匹配上 A 中的目标，那么 A 中地目标也不应该被记为 FN。这种类似的情况逻辑要思考清楚。 3.&ensp;Summary 以上设计的出发点是，我们要承认算法的不完美性以及传感器的局限性，在工程领域，一定要首先解决主要矛盾，再打磨细节。本文还对以下内容未作进一步分析（以后有机会再写文细究）： 状态估计时序相关指标，描述估计的时序稳定性，也可以用于 MOT 的评估； 标注与过滤策略的关系，过滤策略往往依赖于标注策略； 各个指标的阈值确定，确定阈值也是产品中一件重要而又系统的事，有时候比指标设计更复杂； [1] Yang B, Huang C, Nevatia R. Learning affinities and dependencies for multi-target tracking using a CRF model[C]//CVPR 2011. IEEE, 2011: 1233-1240.[2] Choi W, Savarese S. Multiple target tracking in world coordinate with single, minimally calibrated camera[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 553-567.[3] Kasturi, Rangachar, et al. Framework for performance evaluation of face, text, and vehicle detection and tracking in video: Data, metrics, and protocol IEEE transactions on Pattern Analysis and Machine intelligence 31.2 (2008): 319-336.[4] Yamaguchi K, Berg A C, Ortiz L E, et al. Who are you with and where are you going?[C]//CVPR 2011. IEEE, 2011: 1345-1352.[5] Bernardin K, Stiefelhagen R. Evaluating multiple object tracking performance: the CLEAR MOT metrics[J]. Journal on Image and Video Processing, 2008, 2008: 1.[6] Kratz L, Nishino K. Tracking with local spatio-temporal motion patterns in extremely crowded scenes[C]//2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition. IEEE, 2010: 693-700.[7] Ristic B, Vo B N, Clark D, et al. A metric for performance evaluation of multi-target tracking algorithms[J]. IEEE Transactions on Signal Processing, 2011, 59(7): 3452-3457.[8] Schuhmacher D, Vo B T, Vo B N. A consistent metric for performance evaluation of multi-object filters[J]. IEEE transactions on signal processing, 2008, 56(8): 3447-3457.[9] Li Y, Huang C, Nevatia R. Learning to associate: Hybridboosted multi-target tracker for crowded scene[C]//2009 IEEE Conference on Computer Vision and Pattern Recognition. IEEE, 2009: 2953-2960.[10] Song B, Jeng T Y, Staudt E, et al. A stochastic graph evolution framework for robust multi-target tracking[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 605-619.]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT 评价指标-"Evaluating Multiple Object Tracking Performance, the CLEAR MOT Metrics"]]></title>
    <url>%2FMOT-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-Evaluating-Multiple-Object-Tracking-Performance-the-CLEAR-MOT-Metrics%2F</url>
    <content type="text"><![CDATA[这篇文章介绍了两个综合性指标 MOTA 以及 MOTP 的计算过程，这两个指标有优劣势，但是作为综合性指标至今在学术界仍广泛应用。本文主要介绍其设计思想及计算过程。 一个理想的 MOT 算法，我们期望每一帧： 准确检测目标的数量； 准确估计每个目标的状态，如位置，朝向，速度等； 准确估计每个目标的轨迹，即目标的 ID 不变性； 这就要求评价准则： 能评估目标定位的精度； 能反映目标轨迹的追踪能力，即同一个目标产生唯一的 ID； 此外，为了提高评价准则的实用性： 参数尽可能少，阈值可调； 易于理解，表现方式符合人们的直觉； 有较强的通用性，能评估各种跟踪算法； 指标个数少，但是能足够反映算法不同维度的性能； 假设第 \(t\) 帧，有目标集 \(\{o_1,…,o_n\}\)，跟踪算法的输出(hypotheses)：\(\{h_1,…h_m\}\)。根据上述设计准则，设计评价计算过程： &ensp;构建 \(h_j\) 与 \(o_i\) 的最优匹配； &ensp;对于每个匹配对，计算位置估计误差； &ensp;累加所有匹配对的误差，包括：a. &ensp;计算漏检数(FN)；b. &ensp;计算误检数(FP)；c. &ensp;计算 ID swith 次数，包括两个邻近目标的 ID 交换，以及遮挡后，同一目标的 ID 跳变； 由此可得到两大指标： tracking precision，目标位置的估计精度； tracking accuracy，包括 misses(FN), FP, mismatches(IDs), failures to recover； 下面分两块做细节分析，匹配构建 (Establishing Correspondences) 与评价指标 (Metrics)。 1.&ensp;匹配构建 算法估计与目标真值的匹配，大致还是基于匹配最近 object-hypothesis 的思想，没匹配上的估计就是 FP，没匹配上的真值就是 FN。但是这中间需要进一步考虑一些问题。 1.1.&ensp;有效匹配 如果算法估计 \(h_j\) 与目标 \(o_i\) 的最近距离 \(dist_{i,j}\) 超过了一定的阈值 \(T\)，那么这个匹配也是不合理的，因为这个距离误差加入到定位误差中是不合理的，所以只能说这个跟踪的结果不是这个目标。关于距离的度量： 区域（框）跟踪器，距离可用两者的重叠区域来度量，\(T\) 可以设为 0； 点跟踪器，距离可用两者中心点的欧氏距离来度量，\(T\) 可以根据目标的尺寸来设定； 1.2.&ensp;跟踪一致性 统计目标与算法输出的匹配跳变的次数，也就是目标 ID 的跳变数。文章还提到，当目标有两个有效地匹配时，选择之前的匹配，即使那个匹配的距离大于另一个匹配，这点当存在两个很近的目标时，可能会有问题，需要全局来看。 1.3.&ensp;匹配过程 &ensp;对 \(t\) 帧，考虑 \(M_{t-1}\) 中所有匹配是否还依然有效，包括目标真值及算法输出是否还存在，如果都存在，那么距离是否超出阈值 \(T\)； &ensp;对于剩下的没找到匹配的真值目标，在唯一匹配以及阈值约束下，可采用匹配算法或者贪心算法来求解，使得距离误差的总和最小（文章的意思是排除了从上一帧继承的已有匹配，当目标密集时，这部分也应该加入进来优化）。统计当前帧目标真值匹配的跳变数 \(mme_t\)，作为 mismatch errors； &ensp;经过之前两步后，找到了所有的匹配，统计匹配个数为 \(c_t\)，计算匹配上的目标真值与算法输出的定位误差 \(d_t^i\)； &ensp;统计没有匹配上的算法输出 (hypotheses) 为 \(fp_t\)，没有匹配上的目标真值为 \(m_t\)，目标真值个数为 \(g_t\)； &ensp;每一帧重复步骤１，第一帧没有 mismatch； 2.&ensp;评价指标 基于以上的匹配策略，得出两个合理的指标： MOTP(multiple object tracking precision)，跟踪定位精度指标：$$MOTP=\frac{\sum_{i,t}d_t^i}{\sum_tc_t}$$ MOTA(multiple object tracking accuracy)，综合了漏检率，误检率，以及 ID 跳变率：$$MOTA=1-\frac{\sum_t(m_t+fp_t+mme_t)}{\sum_tg_t}$$]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOT 综述-'Multiple Object Tracking: A Literature Review']]></title>
    <url>%2FMOT-%E7%BB%BC%E8%BF%B0-Multiple-Object-Tracking-A-Literature-Review%2F</url>
    <content type="text"><![CDATA[之前做 MOT 还是沿着 SOT 的思路，这篇文章对 MOT 有一个很深入且很有框架性的综述，以下对这篇文章做一个提炼，并加入一些自己的想法。 MOT 作为一个中层任务，是一些高层任务的基础，比如行人的 pose estimation，action recognition，behavior analysis，车辆的 state estimation。单目标跟踪(SOT)主要关注 appearance model 以及 motion model 的设计，解决尺度、旋转、光照等影响因素。而 MOT 包含两个任务：目标数量以及目标ID，这就要求 MOT 还需要解决其它问题： frequent occlusions initialization and termination of tracks similar appearance interactions among multiple objects 1.&ensp;问题描述 多目标跟踪实际上是多参数估计问题。给定图像序列\(\{I_1,I_2,…,I_t,…\}\)，第\(t\)帧中目标个数为\(M_t\)，第\(t\)帧中所有目标的状态表示为\(S_t=\{s_t^1,s_t^2,…,s_t^{M_t}\}\)，第\(i\)个目标的轨迹表示为\(s_{1:t}^i=\{s_1^i,s_2^i,…,s_t^i\}\)，所有图像中所有目标的状态序列为\(S_{1:t}=\{S_1,S_2,…,S_t\}\)。相应的，所有图像中所有目标观测到的状态序列为\(O_{1:t}=\{O_1,O_2,…,O_t\}\)。多目标跟踪的优化目标是求解最优的各目标状态，即求解一个后验概率问题，$$ \widehat{S} _ {1:t}=\mathop{\arg\max}_{S_{1:t}}P(S_{1:t}|O_{1:t})$$这种形式有两种实现方法： probabilistic inference适合用于 online tracking 任务，Dynamic Model 为 \(P(S_t|S_{t-1})\)，Observation Model 为 \(P(O_t|S_t)\)，两步求解过程： \(\circ\) Predict: \(P(S_t|O_{1:t-1})=\int P(S_t|S_{t-1})dS_{t-1}\) \(\circ\) Update: \(P(S_t|O_{1:t}) \propto P(O_t|S_t)P(S_t|O_{1:t-1})\) deterministic optimization适合用于 offline tracking 任务，直接利用多帧信息进行最优化求解。 2.&ensp;分类方法 initialization method初始化方式分为： \(\circ\) Detection-Based Tracking，优势明显，除了只能处理特定的目标类型； \(\circ\) Detection-Free Tracking，能处理任何目标类型； processing mode根据是否使用未来的观测，处理方式可分为： \(\circ\) online tracking，适合在线任务，缺点是观测量会比较少； \(\circ\) offline tracking，输出结果存在时延，理论上能获得全局最优解； type of output根据问题求解方式输出是否存在随机性： \(\circ\) probabilistic inference，概率性推断； \(\circ\) deterministic inference，求解最大后验概率； 自动驾驶等在线任务主要关注 Detection-Based，online tracking。 3.&ensp;框架 MOT 主要考虑两个问题： 目标在不同帧之间的相似性度量，即对appearance, motion, interaction, exclusion, occlusion的建模； 恢复出目标的ID，即 inference 过程； 3.1.&ensp;Appearance Model3.1.1.&ensp;Visual Representation 视觉表达即目标的特征表示方式： local features本质上是点特征，点特征由 corner+descriptor(角点+描述子) 组成。KLT(good features to track)在 SOT 中应用广泛，用它可以生成短轨迹，估计相机运动位姿，运动聚类等；Optical Flow也是一种局部特征，在数据关联之前也可用于将检测目标连接到短轨迹中去。 region features在一个块区域内提取特征，根据像素间作差的次数，可分为： zero-order, color histogram &amp; raw pixel template first-order, HOG &amp; level-set formulation(?) up-to-second-order, Region covariance matrix others其它特征本质上也需要 local 或 region 的方式提取，只是原始信息并不是灰度或彩图。如 depth,probabilistic occupancy map, gait feature. Local features，比如颜色特征，在计算上比较高效，但是对遮挡，旋转比较敏感；Region features 里，HOG 对光照有一定的鲁棒性，但是对遮挡及形变效果较差；Region covariance matrix 更加鲁棒，但是需要更高的计算量；深度特征也比较有效，但是需要额外的获取深度信息的代价。 3.1.2.&ensp;Statistical Measuring 有了目标的特征表示方式之后，就可以评价两个观察的目标的相似性。特征表示的线索(cue)可分为： single cue因为只有一个线索，相似性(similarity)可以直接通过两个向量的距离转换得到。可以将距离指数化，高斯化。也可以将不相似度转为可能性，用协方差矩阵表示。 multiple cues多线索，即多种特征的融合，能极大提高鲁棒性，融合的策略有： Boosting, 选取一系列的特征，用 boost 算法选取表达能力最强的特征； Concatenation, 各个特征直接在空间维度上串起来，形成一个 cue 的表达方式； Summation, 加权融合各个特征，形成一个 cue 的表达方式； Product, 各个特征相乘的方式，比如目标 \(s_0\) 的某个潜在匹配 \(s_1\) 的颜色，形状特征为 \(color\), \(shape\) 的概率为 \(p(color|s_0)\), \(p(shape|s_0)\), 假设特征独立，那么， $$p(s_1|s_0)=p(color, shape|s_0)=p(color|s_0)\cdot p(shape|s_0)$$ Cascading, coarse-to-fine 的方式，逐步精细化搜索； 3.2.&ensp;Motion Model 运动模型对关联两个 tracklets 比较管用，而 online tracking 任务，对输出的时延要求较高，所以其中一个 tracklet 可以任务就是当前帧与上一帧形成的轨迹，所以这里很难去计算两个 tracklets 的相似度。能看到的一个应用点就是，通过 motion model 模型，预测下一时刻目标的位置，作为一个线索项目。以下讨论的各模型主要是为了度量 tracklets 的相似性，从而做 tracklets 的匹配。 3.2.1.&ensp;Linear Velocity Smoothness. N 帧 M 个目标轨迹: \(C_{dyn}=\sum_{t=1}^{N-2}\sum_{i=1}^{M}\parallel v_i^t-v_i^{t+1}\parallel^2\) Position Smoothness. \(G(p^{tail}+v^{tail}\Delta t-p^{head}, \sum_p)\cdot G(p^{head}-v^{head}\Delta t-p^{tail}, \sum_p)\) Acceleration Smoothness. 3.2.2.&ensp;Non-linear 运动模型假设是非线性的，相似度计算还是按照以上高斯形式。引为中提到，非线性运动模型并不作为目标的惩罚因子，因为目标并不需要满足该模型，但是只要有目标满足，就降低惩罚系数。 3.3.&ensp;Interaction Model3.3.1.&ensp;Social Force Models Individual Force fidelity, 目标不会改变它的目的地方向； constancy, 目标不会突然改变速度和方向； Group Force attraction, 目标间应该尽量靠近； repulsion, 目标间也得保留适当的距离； coherence, 同一个 group 里面的目标速度应该差不多； 3.3.2.&ensp;Crowd Motion Pattern Models 当一个 group 比较密集的时候，单个目标的运动模型不太显著了，这时候群体的运动模型更加有效，可以用一些方法来构建群体运动模型。 3.4.&ensp;Exclusion Model3.4.1.&ensp;Detection-level 同一帧两个检测量不能指向同一个目标。匹配 tracklets 时，可以将这一项作为惩罚项。不过目前的检测技术都做了 NMS，基本可以消除这种情况。 3.4.2.&ensp;Trajectory-level 两个轨迹不能非常靠近。对于 online tracking 来说，就是 tracking 结果的两个量不能挨在一起，如果挨在一起，就说明有问题，比如遮挡，或跟丢。 3.5.&ensp;Occlusion Handling Part-to-whole, 将目标分成栅格来处理； Hypothesize-and-test, Buffer-and-recover, 在遮挡产生前，记录一定量的观测，遮挡后恢复； Others 3.6.&ensp;Inference3.6.1.&ensp;Probabilistic Inference 概率法只需要用到当前时刻之前的信息，所以适合用于 online tracking 任务。首先，如果假设一阶马尔科夫，当前目标的状态之依赖于前一时刻目标的状态，即 dynamic model：$$P(S_t|S_{1:t-1})=P(S_t|S_{t-1})$$其次，观测是独立的，即当前目标的观测只由当前目标的状态决定，observation model：$$P(O_{1:t}|S_{1:t})=\prod_{i=1}^t P(O_t|S_t)$$dynamic model 对应的就是跟踪算法策略，observation model 是状态观测手段，包括检测方法。目标状态估计的迭代过程为： predict step根据 dynamic model，由目标的上一状态预测当前状态的后验概率分布； update step根据 observation model，更新当前目标状态的后验概率分布； 状态估计的过程伴随着噪音等因素的影响，常用的概率推断模型有： Kalman filter Extended Kalman filter Particle filter 3.6.2.&ensp;Deterministic Optimization 确定性优化法需要至少一个时间窗口的观测量，所以适合 offline tracking 任务。优化方法有： Bipartite graph matching Dynamic Programming Min-cost max-flow network flow Conditional random field MWIS(Maximum-weight independent set) 4.&ensp;评价方法 评价方法是非常重要的，一方面对算法系统进行调参优化，另一方面比较各个不同算法的优劣。评价方法 (evaluation) 包括评价指标 (metrics) 以及数据集 (datasets)，多类别的数据集主要有： MOT Challenge KITTI 评价指标可分为：A.&ensp;检测指标 \(\lozenge\) 准确性(Accuracy) Recall &amp; Precision False Alarme per Frame(FAF) rate, from paper False Positive Per Image(FPPI), from paper MODA(Multiple Object Detection Accuracy), 包含了 false positive &amp; miss dets. from paper \(\lozenge\) 精确性(Precision) MODP(Multiple Object Detection Precision), 衡量检测框与真值框的位置对齐程度；from paper B.&ensp;跟踪指标 \(\lozenge\) 准确性(Accuracy) ID switches(IDs), from paper MOTA(Multiple Object Tracking Accuracy), 包含了FP，FN，mismatch；from paper \(\lozenge\) 精确性(Precision) MOTP(Multiple Object Tracking Precision), from paper TDE(Tracking Distance Error), from paper OSPA(optimal subpattern assignment), from paper \(\lozenge\) 完整性(Completeness) MT, the numbers of Mostly Tracked, from paper PT, the numbers of Partly Tracked ML, the numbers of Mostly Lost FM, the numbers of Fragmentation \(\lozenge\) 鲁棒性(Robustness) RS(Recover from Short-term occlusion), from paper RL(Recover from Long-term occlusion) 评价指标汇总： 5.&ensp;总结5.1.&ensp;还存在的问题 MOT 算法模块较多，参数也较复杂，但是最依赖于检测模块的性能，所以算法间比较性能时，需要注意按模块进行变量控制。 5.2.&ensp;未来研究方向 MOT with video adaptation，检测模块式预先训练的，需要在线更新学习； MOT under multiple camera:\(\circ\) multiple views，不同视野相同场景信息的记录，\(\circ\) non-overlapping multi-camera，不同视野不同场景的 reidentification； Multiple 3D object tracking，能更准确预测位置，大小，更有效处理遮挡； MOT with scene understanding，拥挤场景，用场景理解来有效跟踪； MOT with deep learning MOT with other cv tasks，和其他任务融合，比如目标分割等；]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D Detection Paper List]]></title>
    <url>%2F3D-Detection-paper-list%2F</url>
    <content type="text"><![CDATA[这篇文章从输入数据类别上进行 3D Detection paper 的归类。 RGBRGB-D(双目，单目+点云)Lidar]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>3D Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study Topic List]]></title>
    <url>%2Fstudy-topic-list%2F</url>
    <content type="text"><![CDATA[本文罗列了相关领域知识的学习资料。 1.&ensp;Detection1.1.&ensp;2D Detection 入门 amusi Object Detection @handong Object Detection and Classification using R-CNNs Paper with Code 1.2.&ensp;3D Detection Paper with Code KITTI Leaderboard 2.&ensp;Tracking2.1.&ensp;Single Object Tracking Paper with Code 2.2.&ensp;Multi Object Tracking Paper with Code Paper List MOT Challenge 综述：Multiple Object Tracking: A Literature Review 综述：Online object tracking: A benchmark 综述：MOTChallenge 2015: Towards a benchmark for multi-target tracking 3.&ensp;Computational Photography 2017年秋季的计算摄影学课程15-463 4.&ensp;CNN ACC 5.&ensp;SLAM5.1.&ensp;理论知识 计算机视觉中的数学方法 Multiple View Geometry in Computer Vision Probabilistic Robotics(有中文版) State Estimation for Robotics(有中文版) 视觉SLAM十四讲 5.2.&ensp;综述 [Visual Odometry Part I: Fundamentals] [Visual Odometry Part II: Matching, Robustness, Optimization, Applications] Review of Visual Odometry: Types, Approaches, Challenges, and Applications Visual SLAM algorithms: a Survey from 2010 to 2016 Visual SLAM for Driverless Cars: a Brief Survey Visual Simultaneous Locations and Mapping: a Survey 5.3.&ensp;工具 ROS Opencv Camera Calibration Matlab Camera Calibration Toolbox ROS Wiki Camera Calibration 5.4.&ensp;算法 OpenSLAM 5.5.&ensp;其它资料 计算机视觉life Paper with Code]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
