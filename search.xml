<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3D Detection Paper List</title>
    <url>/3D-Detection-paper-list/</url>
    <content><![CDATA[<p>这篇文章从输入数据类别上进行 3D Detection paper 的归类。</p>
<h2 id="rgb">RGB</h2>
<h2 id="rgb-d双目单目点云">RGB-D(双目，单目+点云)</h2>
<h2 id="lidar">Lidar</h2>
]]></content>
      <categories>
        <category>Trash</category>
      </categories>
      <tags>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Epistemic Uncertainty for Active Learning</title>
    <url>/Epistemic-Uncertainty-for-Active-Learning/</url>
    <content><![CDATA[<p>　　<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中详细讨论了 Aleatoric Uncertainty 的建模以及应用。本文讨论 Epistemic Uncertainty 的建模，以及在 Active Learning 中的应用。Epistemic Uncertainty 描述了模型因为缺少训练数据而存在的不确定性，所以其可应用于 Active Learning。应用场景有：</p>
<ul>
<li><strong>减少训练时间</strong>：在大数据集下，训练时挑选当前模型认知困难的样本，减少训练数据从而减少训练时间；</li>
<li><strong>减少无效标注</strong>：只挑选当前模型认知困难的样本进行标注、迭代模型；</li>
</ul>
<p><img src="/Epistemic-Uncertainty-for-Active-Learning/active_learning.png" width="50%" height="50%" title="图 1. active learning 工作流"> 　　<a href="#1" id="1ref">[1]</a>中提到的一种 Active Learning 工作流如图 1. 所示，重要环节有 Estimating Uncertainty 以及 Querying Data。该工作流假设了<strong>一个完美的图像检测器(至少有个完美的召回率)</strong>，图像检测器提供目标 proposal，3D 检测对 proposal 作 uncertainty 估计，从而确定是否标注。 Estimating Uncertainty 指的是 Epistemic Uncertainty 的建模；Querying Data 则设计一种策略，其能通过估计的 Uncertainty 来选择模型认知困难的样本。<br>
　　由于 Epistemic Uncertainty 只能通过 Monte-Carlo 等方法近似得到，这些方法都是基于模型预测的目标进行 Uncertainty 估计的，所以对于漏检的目标，其 Uncertainty 是无法有效获取的。换句话说，本文讨论的 Epistemic Uncertainty 只能抓取预测的正样本(TP)置信度不高，以及误检(FP)的 Uncertainty 信息，无法获得TP置信度非常低的样本 Uncertainty，即完全没见过的目标。<strong>所以基于 Epistemic Uncertainty 的 Active Learning，理论上只能使正样本置信度提高，以及消除误检；对于漏检，需要加入一定的随机性，让模型先“见到”这种类型的目标。</strong></p>
<h2 id="estimating-epistemic-uncertainty">1. Estimating Epistemic Uncertainty</h2>
<p>　　针对一批训练数据集\(\{\mathbf{X,Y}\}\)，训练模型 \(\mathbf{y=f^W(x)}\)，在贝叶斯框架下，预测量的后验分布为<a href="#3" id="3ref"><sup>[3]</sup></a>： <span class="math display">\[p\left(\mathbf{y\vert x,X,Y}\right) = \int p\left(\mathbf{y\,|\,f^W(x)}\right) p\left(\mathbf{W\,|\,X,Y}\right)d\mathbf{W} \tag{1}\]</span> 其中 \(p(\mathbf{W\,|\,X,Y})\) 为模型参数的后验分布，描述了模型的不确定性，即 Epistemic Uncertainty；\(p\left(\mathbf{y\,|\,f^W(x)}\right)\) 为观测似然，描述了观测不确定性，即Aleatoric Uncertainty。接下来讨论如何计算 Epistemic Uncertainty。</p>
<h3 id="分类问题">1.1. 分类问题</h3>
<p><img src="/Epistemic-Uncertainty-for-Active-Learning/softmax.png" width="60%" height="60%" title="图 2. softmax for unseen data"> 　　如图 2. 所示<a href="#2" id="2ref"><sup>[2]</sup></a>，softmax 可能会对没见过的目标产生较高的概率输出(如误检)。所以不能直接使用分类的概率输出作为 Uncertainty 估计。</p>
<ul>
<li><strong>Monte-Carlo Dropout</strong><br>
<a href="#2" id="2ref">[2]</a>中提出了 Monte-Carlo 近似求解 Epistemic Uncertainty 的方法，其指出：在训练阶段，Dropout 等价于优化网络权重 \(W\) 的 Bernoulli 分布；在测试阶段，使用 Dropout 对样本进行多次测试，能得到模型权重的后验分布，即 Epistemic Uncertainty。由此得到： <span class="math display">\[p(\mathbf{y|x}) \approx \frac{1}{T}\sum^T_{t=1} p(\mathbf{y|x,W}_t) = \frac{1}{T}\sum^T_{t=1}softmax_{(\mathbf{W}_t)}(\mathbf{x}) \tag{2}\]</span> 其中 \(\mathbf{W}_t\) 为第 \(t\) 次 Inference 网络权重。</li>
<li><strong>Deep Ensembles</strong><br>
Deep Ensemble 则是一种非贝叶斯的方法，该方法用不同的初始化方法训练一系列网络 \(\{\mathbf{M} _ e\} _ {e=1}^E\)。那么： <span class="math display">\[p(\mathbf{y|x}) \approx \frac{1}{E}\sum^E_{e=1} p(\mathbf{y|x,M}_e) = \frac{1}{E}\sum^E_{e=1}softmax_{(\mathbf{M}_e)}(\mathbf{x}) \tag{3}\]</span></li>
</ul>
<p>　　有了预测的概率后，可用 Shannon Entropy 或者 Mutual Information 来计算目标的信息量，即 Uncertainty。</p>
<ul>
<li><strong>Shannon Entropy(SE)</strong><br>
SE 计算公式为: <span class="math display">\[\mathcal{H}[\mathbf{y|x}] = -\sum^C_{c=1}p(y=c|\mathbf{x})\,\mathrm{log}\,p(y=c|\mathbf{x}) \tag{4}\]</span></li>
<li><strong>Mutual Information(MI)</strong><br>
由于 Monte-Carlo 以及 Deep Ensembles 获取的是概率分布，以 Monte-Carlo 为例，由此可计算 MI： <span class="math display">\[\mathcal{I}[\mathbf{y;W}] = \mathcal{H}[\mathbf{y|x}] - \mathbb{E}\mathcal{H}[\mathbf{y|x,W}] \approx \mathcal{H}[\mathbf{y|x}] + \frac{1}{T}\sum_{t=1}^T\sum_{c=1}^Cp(y=c|\mathbf{x,W}_t)\,\mathrm{log}\,p(y=c|\mathbf{x,W}_t) \tag{5}\]</span></li>
</ul>
<p>　　SE 测量的是预测 Uncertainty，MI 测量的是模型对该数据的 Uncertainty。根据该 Uncertainty，即可挑选样本进行标注。Uncertainty 越高，代表该样本对模型的信息量更大，所以需要进一步标注来训练模型。</p>
<h3 id="回归问题">1.2. 回归问题</h3>
<p>　　Monte-Carlo 采样下，假设获得的回归量为 \(\{\mathbf{v}\}_{t=1}^T\)。那么其均值和方差为： <span class="math display">\[\left\{\begin{array}{l}
\mathcal{M}_{\mathbf{v}} \approx \frac{1}{T}\sum_{t=1}^T\mathbf{v}_t \\
\mathcal{C}_{\mathbf{v}} = \frac{1}{T}\sum_{t=1}^T\mathbf{v}_t\mathbf{v}_t^T-\mathcal{M}_{\mathbf{v}}\mathcal{M}_{\mathbf{v}}^T
\end{array}\tag{6}\right.\]</span> 由此得到回归量的 Uncertainty： <span class="math display">\[TV_{\mathbf{v}} = trace\left(\mathcal{C}_{\mathbf{v}} \right) \tag{7}\]</span> 该 Uncertainty 越大，说明该数据对模型的信息也越多，所以可进一步标注训练。</p>
<h2 id="metrics">2. Metrics</h2>
<p>TODO</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Feng, Di, et al. &quot;Deep active learning for efficient training of a lidar 3d object detector.&quot; arXiv preprint arXiv:1901.10609 (2019).<br>
<a id="2" href="#2ref">[2]</a> Gal, Yarin. Uncertainty in deep learning. Diss. PhD thesis, University of Cambridge, 2016.<br>
<a id="3" href="#1ref">[3]</a> Feng, Di, Lars Rosenbaum, and Klaus Dietmayer. &quot;Towards safe autonomous driving: Capture uncertainty in the deep neural network for lidar 3d vehicle detection.&quot; 2018 21st International Conference on Intelligent Transportation Systems (ITSC). IEEE, 2018.</p>
]]></content>
      <categories>
        <category>Uncertainty</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Uncertainty</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN</title>
    <url>/GAN/</url>
    <content><![CDATA[<p>　　Generative Adversarial Nets(GAN) 能将某个分布的数据映射到另一组数据形成的分布空间内。这在某些领域非常有用，如：图像去噪，图像去雨雾，图像去模糊，图像低光照增强等。<strong>自动驾驶中，图像去雨雾与低光照增强非常关键，GAN 能在没有模拟器的情况下，根据有限的数据，自动生成某一分布的数据，为后续感知做准备</strong>。目前还没看到针对点云的 GAN，未来 3D GAN 可能会有大进展。<br>
　　本文介绍几个 GAN 的基础性工作。</p>
<h2 id="gan-基础网络">1. GAN 基础网络</h2>
<h3 id="generative-adversarial-nets1">1.1. Generative Adversarial Nets<a href="#1" id="1ref"><sup>[1]</sup></a></h3>
<p>　　对抗网络由生成模型和判别模型构成。生成模型输入随机噪声，输出以假乱真的图像，判别模型则对图像作分类。其优化函数为： <span class="math display">\[ \min\limits _ G \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x))] + E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{1}\]</span> 该优化过程有两部分组成：</p>
<ol type="1">
<li><strong>优化判别模型</strong><br>
<span class="math display">\[ \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x))] + E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{2}\]</span> 其中第一项表示输入为真样本时，那么判别模型输出越大越好，即越接近 1；而对于已经生成的假样本 \(G(z)\)，判别模型输出越小越好，即接近 0。</li>
<li><strong>优化生成模型</strong><br>
<span class="math display">\[ \min\limits _ GV(D,G) =E _ {x\sim p _ z(z)}[log(1-D(G(z)))] \tag{3}\]</span> 优化生成模型时，希望生成的假样本接近真样本，所以生成的假样本经过判别模型后越大越好，即\(D(G(z))\)要接近 1。由此统一成上式。</li>
</ol>
<p>　　对抗网络的优化由这两步迭代组成。</p>
<h3 id="conditional-generative-adversarial-nets2">1.2. Conditional Generative Adversarial Nets<a href="#2" id="2ref"><sup>[2]</sup></a></h3>
<p>　　条件对抗网络中的生成模型输入不在是随机噪声，而是特定的数据分布，如真值标签。其优化函数为： <span class="math display">\[ \min\limits _ G \max\limits _ D V(D,G) = E _ {x\sim p _ {data}(x)}[log(D(x|y))] + E _ {x\sim p _ z(z)}[log(1-D(G(z|y)))] \tag{4}\]</span> 　　其优化过程与 GAN 类似。</p>
<h3 id="cycle-consistent-adversarial-nets3">1.3. Cycle-Consistent Adversarial Nets<a href="#3" id="3ref"><sup>[3]</sup></a></h3>
<p>　　Cycle GAN 使得高分辨率图像的 domain-transfer 成为可能。对于两个图像分布 \(X,Y\)，设计两个映射函数(生成模型): \(G:X\to Y\) 和 \(F:Y\to X\)；设计两个判别模型: \(D _ X\) 和 \(D _ Y\)，\(D _ X\) 用于判别 \(x\) 与 \(F(y)\), \(D _ Y\) 用于判别 \(y\) 与 \(G(x)\)。为了还原高分辨率图像，设计两部分 Loss：</p>
<ol type="1">
<li><strong>Adversarial Loss</strong><br>
就是传统的对抗网络 Loss: <span class="math display">\[\begin{align}
\mathcal{L} _ {GAN}&amp;=\mathcal{L} _ {GAN}(G, D _ Y,X,Y)+\mathcal{L} _ {GAN}(F, D _ X,Y,X)\\
&amp;= E _ {y\sim p _ {data}(y)}[log(D _ Y(y))] + E _ {x\sim p _ {data}(x)}[log(1-D _ Y(G(x)))]\\
&amp;+ E _ {x\sim p _ {data}(x)}[log(D _ X(x))] + E _ {y\sim p _ {data}(y)}[log(1-D _ X(F(Y)))]
\end{align} \tag{5}\]</span></li>
<li><strong>Cycle Consistency Loss</strong><br>
为了保证映射网络的映射准确性，考虑到 \(x\to G(x)\to F(G(x))\approx x \) 以及 \(y\to F(y)\to G(F(y))\approx y \)，设计 cycle loss： <span class="math display">\[\mathcal{L} _ {cyc}(G,F)= E _ {x\sim p _ {data}(x)}\Vert F(G(x))-x\Vert + E _ {y\sim p _ {data}(y)}\Vert G(F(y))-y\Vert \tag{6}\]</span></li>
</ol>
<p>总的 Loss 为： <span class="math display">\[\mathcal{L} _ (G,F,D _ X, D _ Y)=\mathcal{L} _ {GAN}(G, D _ Y,X,Y)+\mathcal{L} _ {GAN}(F, D _ X,Y,X)+\lambda \mathcal{L} _ {cyc}(G,F) \tag{7}\]</span></p>
<h2 id="其它资料">2. 其它资料</h2>
<p>　　上面介绍了三个 GAN 基本网络，尤其是 Cycle-GAN，是高分辨率图像无监督 domain-transfer 的基础，应用相当广泛。本文介绍相对较简单，<a href="#4" id="4ref">[4]</a> 详细介绍了 GAN 的来龙去脉。代码则可以参考 <a href="#5" id="5ref">[5]</a> ，收录的 GAN 网络非常详细。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Goodfellow, Ian, et al. &quot;Generative adversarial nets.&quot; Advances in neural information processing systems. 2014.<br>
<a id="2" href="#2ref">[2]</a> Mirza, Mehdi, and Simon Osindero. &quot;Conditional generative adversarial nets.&quot; arXiv preprint arXiv:1411.1784 (2014).<br>
<a id="3" href="#3ref">[3]</a> Zhu, Jun-Yan, et al. &quot;Unpaired image-to-image translation using cycle-consistent adversarial networks.&quot; Proceedings of the IEEE international conference on computer vision. 2017.<br>
<a id="4" href="#4ref">[4]</a> http://www.gwylab.com/note-gans.html<br>
<a id="5" href="#5ref">[5]</a> https://github.com/eriklindernoren/PyTorch-GAN</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Grid Mapping</title>
    <url>/Grid-Mapping/</url>
    <content><![CDATA[<p>　　占据栅格地图(Occupied Grid Map)是机器人领域一种地图表示方式。可以作为 SLAM 的一个模块，但是这里讨论：<strong>在本体位姿已知的情况下，如何构建 2D Grid Map</strong>。本文介绍两种方法，贝叶斯概率模型以及高斯过程。</p>
<h2 id="贝叶斯概率模型1">1. 贝叶斯概率模型<a href="#1" id="1ref"><sup>[1]</sup></a></h2>
<p>　　设机器人位姿序列为 \(x_{1:t}\)，观测序列为 \(z_{1:t}\)，那么 Grid Map 的构建就是求解地图的后验概率：\(p(m|x_{1:t},z_{1:t})\)，其中地图由栅格构成：\(m=\{m_1,m_2,...,m_n\}\)。<strong>假设每个栅格独立同分布</strong>，那么： <span class="math display">\[p(m|x_{1:t},z_{1:t})=p(m_1,m_2,...,m_n|x_{1:n},z_{1:t}) = \prod_{i=1}^n p(m_i|x_{1:t},z_{1:t}) \tag{1}\]</span> 　　每个栅格有三种状态：被占有，空，未被观测。设被占有的概率为 \(occ(m_i) = p(m_i|x_{1:t},z_{1:t})\)，那么空的概率为 \(free(m_i)=1-occ(m_i)\)，对于未被观测的区域认为 \(occ(m_i) = free(m_i) =0.5\)。下面通过贝叶斯法则及马尔科夫性推理后验概率计算过程： <span class="math display">\[\begin{align}
occ_t(m_i) &amp;= p(m_i|x_{1:t},z_{1:t}) \\
&amp;= \frac{p(z_t|m_i,x_{1:t},z_{1:t-1})\,p(m_i|x_{1:t},z_{1:t-1})}{p(z_t|x_{1:t},z_{1:t-1})} \\
&amp;= \frac{p(z_t|m_i,x_{t})\,p(m_i|x_{1:t-1},z_{1:t-1})}{p(z_t|x_{1:t},z_{1:t-1})} \\
&amp;= \frac{p(m_i|z_t,x_{t})\,p(z_t|x_t)\,p(m_i|x_{1:t-1},z_{1:t-1})}{p(m_i|x_t)\,p(z_t|x_{1:t},z_{1:t-1})} \\
&amp;= \frac{p(m_i|z_t,x_{t})\,p(z_t|x_t)\,occ_{t-1}(m_{i})}{p(m_i)\,p(z_t|x_{1:t},z_{1:t-1})} \tag{2}
\end{align}\]</span> 对应的栅格为空的概率为： <span class="math display">\[\begin{align}
free_t(\hat{m}_i) &amp;=\frac{p(\hat{m}_i|z_t,x_{t})\,p(z_t|x_t)\,free_{t-1}(\hat{m}_{i})}{p(\hat{m}_i)\,p(z_t|x_{1:t},z_{1:t-1})} \\
&amp;= \frac{(1-p(m_i|z_t,x_{t}))\,p(z_t|x_t)\,(1-occ_{t-1}(m_{i}))}{(1-p(m_i))\,p(z_t|x_{1:t},z_{1:t-1})} \tag{3}
\end{align}\]</span> 由(2),(3)可得： <span class="math display">\[\frac{occ_t(m_i)}{1-occ_t(m_i)} = \frac{1-p(m_i)}{p(m_i)}\cdot\frac{occ_{t-1}(m_i)}{1-occ_{t-1}(m_i)}\cdot\frac{p(m_i|z_t,x_t)}{1-p(m_i|z_t,x_t)}   \tag{4}\]</span> 将上式进行对数化： <span class="math display">\[lm_i^{t} = lm_i^{t-1} + \mathrm{log}\left(\frac{p(m_i|z_t,x_t)}{1-p(m_i|z_t,x_t)}\right) - \mathrm{log}\left(\frac{p(m_i)}{1-p(m_i)}\right) \tag{5}\]</span> 其中 \(p(m_i)\) 表示未观测下其被占有的概率，\(p(m_i|z_t,x_t)\) 表示当前观测下其被占有的概率。比如，考虑到激光点云的测量噪声，我们可以假设如果该栅格有点云，那么 \(p(m_i|z_t,x_t) = 0.9\)；对于激光点光路经过的栅格区域 \(p(m_i|z_t,x_t) = 0.02\)，即 \(p(\hat{m}_i|z_t,x_t) = 0.98\)。<br>
　　该模型下，每个栅格被占有的概率可以转换为前后相加测量量的过程，实际每个栅格被占有的概率为： <span class="math display">\[occ_t(m_i) = \frac{\mathrm{exp}(lm_i^t)}{1+\mathrm{exp}(lm_i^t)} \tag{6}\]</span></p>
<h2 id="高斯过程2">2. 高斯过程<a href="#2" id="2ref"><sup>[2]</sup></a></h2>
<p>　　以上概率模型有个缺陷，其假设栅格独立。实际上栅格并不是独立的，相邻的栅格有很强的相关性。高斯过程则可以处理时域及空域的概率估计与融合问题。<br>
　　高斯过程基本理论在 <a href="/Ground-Segmentation-with-Gaussian-Process/" title="Ground Segmentation with Gaussian Process">Ground Segmentation with Gaussian Process</a> 中已经有较详细阐述，这里作简要概述。假设有训练集 \(\{X_n,y_n\}_{n=1}^N\)，那么高斯过程下其符合分布： <span class="math display">\[y_n=f(X_n)+\epsilon, \epsilon\sim \mathcal{N}(0,\sigma^2) \tag{7}\]</span> 对于测试集，则有： <span class="math display">\[f(X^\ast) = \mathcal{N}(\mu,\sigma) \tag{8}\]</span> 高斯过程对测试集的预测结果为： <span class="math display">\[\begin{align}
\mu^\ast &amp;=K(X^\ast,X)(K(X,X)+\sigma_n^2I)^{-1}y\\
\sigma^\ast &amp;=K(X^\ast,X^\ast) - K(X^\ast,X)(K(X,X)+\sigma_n^2I)^{-1}K(X,X^\ast)
\end{align} \tag{9}\]</span> <img src="/Grid-Mapping/GPOM.png" width="60%" height="60%" title="图 1. GPOM"> 　　高斯过程占据栅格地图(Gaussian Process Occupancy Maps, GPOM)算法过程如图 1. 所示。\(\mathrm{p,r}\) 分别为机器人位姿以及观测量。基本思想就是根据当前时刻的观测数据，提取出正负样本训练集，然后构建高斯模型，对于未观测到的区域，用高斯模型进行预测；每个栅格的信息通过 BCM<a href="#3" id="3ref"><sup>[3]</sup></a> 进行时序的融合，最终采用 logistic 回归得到每个栅格被占据的概率(贝叶斯概率模型中，代替 BCM 及 logistic 的是 log 函数累加融合并求取概率，这里应该也可以用这种方式实现)。<br>
　　可见，高斯过程来求解占据栅格地图，<strong>能融合时序及空间信息</strong>，但是效率会比较低，不过除了高斯过程中的矩阵求逆操作，其它操作基本可以并行化处理。代码可参考<a href="#4" id="4ref">[4]</a>。</p>
<h2 id="reference">3. reference</h2>
<p><a id="1" href="#1ref">[1]</a> Thrun, Sebastian. &quot;Probabilistic robotics.&quot; Communications of the ACM 45.3 (2002): 52-57.<br>
<a id="2" href="#2ref">[2]</a> Yuan, Yijun, Haofei Kuang, and Sören Schwertfeger. &quot;Fast Gaussian Process Occupancy Maps.&quot; 2018 15th International Conference on Control, Automation, Robotics and Vision (ICARCV). IEEE, 2018.<br>
<a id="3" href="#3ref">[3]</a> Tresp, Volker. &quot;A Bayesian committee machine.&quot; Neural computation 12.11 (2000): 2719-2741.<br>
<a id="4" href="#4ref">[4]</a> https://github.com/STAR-Center/fastGPOM</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>SLAM</tag>
        <tag>Mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>Ground Segmentation with Gaussian Process</title>
    <url>/Ground-Segmentation-with-Gaussian-Process/</url>
    <content><![CDATA[<p>　　地面分割可作为自动驾驶系统的一个重要模块，本文介绍一种基于高斯过程的地面分割方法。</p>
<h2 id="算法概要">1. 算法概要</h2>
<p><img src="/Ground-Segmentation-with-Gaussian-Process/ground_seg.png" width="80%" height="80%" title="图 1. ground segmentation"> 　　为了加速，本方法<a href="#1" id="1ref"><sup>[1]</sup></a>将三维地面分割问题分解为多个一维高斯过程来求解，如图 1. 所示，其步骤为：</p>
<ol type="1">
<li><strong>Polar Grid Map</strong><br>
将点云用极坐标栅格地图表示，二维地面估计分解成射线方向的多个一维地面估计；</li>
<li><strong>Line Fitting</strong><br>
在每个一维方向，根据梯度大小，作可变数量的线段拟合；</li>
<li><strong>Seed Estimation</strong><br>
在半径 \(B\) 范围内，如果某个 Grid 绝对高度(Grid 高度定义为该 Grid 内所有点的最小高度，其绝对高度则是与本车传感器所在地面的比较)大于 \(T_s\)，那么就将其作为 Seed；</li>
<li><strong>Ground Model Estimation with Gaussian Process</strong><br>
采用高斯过程生成每个一维方向 Grid 的地面估计量，这里为了进一步加速，可以删除冗余的 Seed；根据地面估计模型，将满足模型的 Grid 加入 Seed，更新模型，迭代直至收敛，满足模型的 Seed 条件为： <span class="math display">\[\begin{align}
V[z]&amp;\leq  t_{model}\\
\frac{|z_*-\bar{z}|}{\sqrt{\sigma^2_n+V[z]}} &amp;\leq t_{data}
\end{align} \tag{0}\]</span></li>
<li><strong>Point-wise Segmentation</strong><br>
得到地面估计模型后，就得到了每个 Grid 是否为地面的标签量，对于属于地面标签量的 Grid 内的点，与 Grid 高度的相对高度小于 \(T_r\)，则认为该点属于地面。</li>
</ol>
<h2 id="高斯过程">2. 高斯过程</h2>
<p>　　步骤四中用高斯过程来估计地面模型，对于每个极射线方向的 Grids，假设有 \(n\) 个已经确定是地面的训练集：\(D=\{(r _ i,z _ i)\} _ {i=1}^n\)。根据高斯过程定义，这些样本的联合概率分布为： <span class="math display">\[p(Z|R)\sim N(f(R)+\mu,K) \tag{1}\]</span> 其中 \(R=[r_1,...,r_n]^T\) 为每个 Grid 的距离量，\(Z=[z_1,...,z_n]^T\) 为该 Grid 地面高度，\(f(\cdot)\)为高斯过程要回归的函数。\(\mu\) 设计为零，协方差矩阵 \(K\) 表示变量之间的关系，由协方差方程与噪音项构成： <span class="math display">\[K(r_i,r_j)=k(r_i,r_j)+\sigma^2_n\delta_{ij}\tag{2}\]</span> 其中当且仅当 \(i==j\) 时 \(\delta _ {ij} =1\)。<br>
　　一般的协方差方程是静态，同向的(stationary, isotropic): <span class="math display">\[k(r_i,r_j)=\sigma_f^2\mathrm{exp}\left(-\frac{(r_i-r_j)^2}{2l^2}\right) \tag{3}\]</span> 其中 \(\sigma_f^2\) 是信号协方差，\(l\) 是 length-scale。该方程假设了全空间内 length-scale 的一致性，然而实际上，<strong>越平坦的地面区域，我们需要越大的 length-scale，因为此时该区域对周围区域的概率输出能更大</strong>，所以可进一步设计协方差方程为: <span class="math display">\[k(r_i,r_j)=\sigma_f^2\left(l_i^2\right)^{\frac{1}{4}}\left(l_j^2\right)^{\frac{1}{4}}\left(\frac{l_i^2+l_j^2}{2}\right)^{-\frac{1}{2}}  \mathrm{exp}\left(-\frac{2(r_i-r_j)^2}{l_i^2+l_j^2}\right) \tag{4}\]</span> 其中 \(l_i\) 为位置 \(r_i\) 的 length-scale。\(l_i\) 由该位置距离最近的线段梯度决定(步骤二): <span class="math display">\[l_i=\left\{\begin{array}{l}
a\cdot \mathrm{log}\left(\frac{1}{|g(r_i)|}\right) \,\, if\, |g(r_i)|&gt;g_{def}\\
a\cdot \mathrm{log}\left(\frac{1}{|g_{def}|}\right) \,\, otherwise
\end{array}\tag{5}\right.\]</span> 　　高斯回归预测的过程为，对于测试集 \(T=(r_\ast,z_\ast)\)，其与训练集的联合概率分布为： <span class="math display">\[\begin{bmatrix}
Z\\
z_\ast\\
\end{bmatrix}\sim
N\left(0,
\begin{bmatrix}
K(R,R) &amp; K(R,r_\ast)\\
K(r_\ast,R) &amp; K(r_\ast,r_\ast)\\
\end{bmatrix}\right)
\tag{6}\]</span> 那么，高斯过程回归预测为： <span class="math display">\[\begin{align}
\bar{z}_\ast &amp;=K(r_\ast,R)K^{-1}Z\\
V[z_\ast] &amp;= K(r_\ast,r_\ast)-K(r_\ast,R)K^{-1}K(R,r_\ast)
\end{align} \tag{7}\]</span> 由此得到测试集的预测量，由式(0)可决定该测试量是否标记为地面，进一步迭代估计地面模型，直至收敛。<br>
　　需要注意的是，以上我们假设高斯过程的超参数 \(\theta=\{\sigma_f,a,\sigma_n\}\) 是已知的，实际应用中，可以将超参数设定为经验量，也可以基于训练集用 SGD 学习出一个最优量，这里不做展开。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Chen, Tongtong, et al. &quot;Gaussian-process-based real-time ground segmentation for autonomous land vehicles.&quot; Journal of Intelligent &amp; Robotic Systems 76.3-4 (2014): 563-582.</p>
]]></content>
      <categories>
        <category>Semantic Segmentation</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
        <tag>Segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>Heteroscedastic Aleatoric Uncertainty</title>
    <url>/Heteroscedastic-Aleatoric-Uncertainty/</url>
    <content><![CDATA[<p>　　<a href="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/" title="Multi-task Learning Using Uncertainty to Weigh Losses">Multi-task Learning Using Uncertainty to Weigh Losses</a> 已经详细描述了贝叶斯模型中几种可建模的不确定性(uncertainty)，并应用了<strong>任务依赖/同方差不确定性(Task-dependent or Homoscedastic Aleatoric Uncertainty)</strong>来自动学习多任务中的 Loss 权重。本文讨论同为偶然不确定性(Aleatoric Uncertainty)的<strong>数据依赖/异方差不确定性(Data-dependent or Heteroscedastic Aleatoric Uncertainty)</strong>。需要注意的是，偶然不确定性(Aleatoric Uncertainty)描述的是数据不能解释的信息，只能通过提高数据的精度来消除；而认知不确定性(Epistemic Uncertainty)描述的是模型因为缺少训练数据而存在的未知，可通过增加训练数据解决。<br>
　　为什么要建模 Heteroscedastic Aleatoric Uncertainty？Learning 算法一个比较致命的问题是，网络能输出预测量，但是网络不知道其预测的不确定性，如目标状态估计中，需要获得观测的协方差矩阵<strong>(检测作为观测模块，理论上需要出检测的 Uncertainty，包括 Aleatoric 与 Epistemic Uncertainty，但是 Epistemic Uncertainty 只能通过多次采样近似得到，不能实时应用，所以一般只考虑 Aleatoric Uncertainty 作为观测的不确定性)</strong>。尤其在自动驾驶领域，<strong>我们不仅关注模型知道什么，更要关注模型不知道什么</strong>。<br>
　　本文通过贝叶斯神经网络来建模 Aleatoric Uncertainty，并分析其应用效果。</p>
<h2 id="aleatoric-uncertainty-建模">1. Aleatoric Uncertainty 建模</h2>
<p>　　针对一批训练数据集\(\{\mathbf{X,Y}\}\)，训练模型 \(\mathbf{y=f^W(x)}\)，在贝叶斯框架下，预测量的后验分布为： <span class="math display">\[p\left(\mathbf{y\vert x,X,Y}\right) = \int p\left(\mathbf{y\,|\,f^W(x)}\right) p\left(\mathbf{W\,|\,X,Y}\right)d\mathbf{W} \tag{0}\]</span> 其中 \(p(\mathbf{W\,|\,X,Y})\) 为模型参数的后验分布，描述了模型的不确定性，即 Epistemic Uncertainty；\(p\left(\mathbf{y\,|\,f^W(x)}\right)\) 为观测似然，描述了观测不确定性，即Aleatoric Uncertainty。Epistemic Uncertainty 只能通过近似推断获得，本文不作讨论。<br>
　　<a href="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/" title="Multi-task Learning Using Uncertainty to Weigh Losses">Multi-task Learning Using Uncertainty to Weigh Losses</a> 已经详细推导了 Aleatoric Uncertainty 的建模过程，这里摘抄如下：</p>
<p><span class="math display">\[\mathcal{L}(\mathbf{W}, s_1, s_2) = \frac{1}{2}\mathrm{exp}(-s_1)\mathcal{L}_1(\mathbf{W}) + \mathrm{exp}(-s_2)\mathcal{L}_2(\mathbf{W}) + \mathrm{exp}(\frac{1}{2}s_1) + \mathrm{exp}(\frac{1}{2}s_2) \tag{1}\]</span> 其中 \(\mathcal{L}(\mathbf{W},s_1)\) 为回归项，\(\mathcal{L}(\mathbf{W},s_2)\) 为分类项。<br>
　　<a href="#1" id="1ref">[1]</a><a href="#2" id="2ref">[2]</a><a href="#3" id="3ref">[3]</a> 中建模的回归项 loss uncertainty 与式(1)有细微出入(可以认为是 Uncertainty 的正则项不同，但是效果类似)，其负log似然为： <span class="math display">\[-\mathrm{log}p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) \propto \frac{1}{2\sigma ^2} \Vert \mathbf{y-f^W(x)} \Vert ^2 + \frac{1}{2}\mathrm{log}\sigma^2 \tag{2}\]</span> 所以其回归项 loss 为： <span class="math display">\[\mathcal{L}(\mathbf{W}, s_1) = \frac{1}{2}\mathrm{exp}(-s_1)\mathcal{L}_1(\mathbf{W}) + \frac{1}{2}s_1 \tag{3}\]</span></p>
<h3 id="d-object-detection-by-regressing-corners2">1.1. 3D Object Detection by regressing corners<a href="#2" id="2ref"><sup>[2]</sup></a></h3>
<p>　　该方案是在俯视图下回归 3D 框的 8 个角点，总共 24 个参数。假设观测为多变量的高斯分布，即： <span class="math display">\[\left\{\begin{array}{l}
p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) = \mathcal{N}\left(\mathbf{f^W(x)}, \Sigma(\mathbf{x}) \right) \\
\Sigma(\mathbf{x}) = diag(\sigma _ {\mathbf{x}}^2)
\end{array}\tag{4}\right.\]</span> 其中 \(\mathbf{y}\) 是预测的目标框参数，\(\sigma _ {\mathbf{x}}^2\) 是 24 维的向量，表示了观测数据的噪声水平，由式(3)可知，噪声越大，其对 Loss 的作用越小。</p>
<p><img src="/Heteroscedastic-Aleatoric-Uncertainty/Aleatoric.png" width="60%" height="60%" title="图 1. Aleatoric Uncertainty 与 3D corner 关系"> 　　如图 1. 所示，同一目标，靠近本车的 corner 点，其 Aleatoric Uncertainty 越小；距离越远，目标被遮挡的越严重，其 Aleatoric Uncertainty 越高。</p>
<h3 id="d-object-detection-by-regressing-location-and-orientation-3">1.2. 3D Object Detection by regressing location and orientation <a href="#3" id="3ref"><sup>[3]</sup></a></h3>
<p><img src="/Heteroscedastic-Aleatoric-Uncertainty/regression_uncert.png" width="80%" height="80%" title="图 2. network arch"> 　　如图 2. 所示，网络结构比较简单，这里建模了三种 uncertainty: RPN bbox regression \(\sigma^2_{\mathbf{t_r}}\)；Head 中的 location \(\sigma^2_{\mathbf{t_v}}\)；Head 中的 orientation \(\sigma^2_{\mathbf{r_v}}\)。最终的 Loss 由三项式(3) 以及两项分类 loss 构成。<br>
<img src="/Heteroscedastic-Aleatoric-Uncertainty/Aleatoric_Uncert.png" width="80%" height="80%" title="图 3. Aleatoric Uncertainty 与目标状态关系"> 　　如图 3. 所示，TV(Total Variance) 与目标状态的关系。对于距离越远，遮挡越严重的目标，其 Aleatoric Uncertainty 会越高，因为其观测到的点云会比较少。</p>
<h3 id="semantic-segmentation-1">1.3. Semantic Segmentation <a href="#1" id="1ref"><sup>[1]</sup></a></h3>
<p><img src="/Heteroscedastic-Aleatoric-Uncertainty/Aleatoric_Epistemic.png" width="60%" height="60%" title="图 4. Aleatoric Uncertainty 在语义分割中的关系"> 　　如图 4. 所示，Aleatoric Uncertainty 在远处，边缘处较大；而 Epistemic Uncertainty 对没见过的数据/区域较大。</p>
<h2 id="aleatoric-uncertainty-预测">2. Aleatoric Uncertainty 预测</h2>
<p>　　<a href="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/" title="Multi-task Learning Using Uncertainty to Weigh Losses">Multi-task Learning Using Uncertainty to Weigh Losses</a> 中 Uncertainty 不需要作为预测输出，可将其设计为网络的 weights，且每个任务都设计为单变量高斯分布的形式。<a href="#2" id="2ref">[2]</a><a href="#3" id="3ref">[3]</a> 中则将 Uncertainty 设计为网络的输出，且是多变量高斯分布。更一般的，假设模型输出为混合高斯分布： <span class="math display">\[\left\{\begin{array}{l}
p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) = \sum_k \alpha_k \mathcal{N}\left(\mathbf{f^W(x)}_{(k)}, \Sigma(\mathbf{x})_{(k)} \right)\\
\sum_k \alpha_k = 1
\end{array}\tag{5}\right.\]</span> 　　对于 3D Detection 问题，网络输出的 3D 框参数为 \(\mathbf{y}=(x,y,z,l,h,w,\theta)\)，当输出满足 \(K\) 个混合高斯分布时，网络的输出量有：</p>
<ul>
<li>\(K\) 组目标框参数预测量 \(\{\mathbf{y}_k\}\)；</li>
<li>\(K\) 个对数方差 \(\{s_k\}\)；</li>
<li>\(K\) 个混合高斯模型权重参数 \(\{\alpha_k\}\)；</li>
</ul>
<p>　　训练时，找出与真值分布最近的一组预测量，混合高斯模型权重用 softmax 回归并用 cross-entropy loss，找到最相似的分布后，将该分布的方差用式(3)作用于回归的 Loss 项；测试时，找到混合高斯模型最大的权重项，对应的高斯分布，即作为最终的输出分布。这里只考虑了输出 3D 框的一个整体的方差，也可以输出定位方差+尺寸方差+角度方差，只要将该方差作用于对应的 Loss 项即可。当 \(K=1\) 时，就是多变量单高斯模型，一般也够用。</p>
<h2 id="metrics">3. Metrics</h2>
<p>TODO</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Kendall, Alex, and Yarin Gal. &quot;What uncertainties do we need in bayesian deep learning for computer vision?.&quot; Advances in neural information processing systems. 2017.<br>
<a id="2" href="#2ref">[2]</a> Feng, Di, Lars Rosenbaum, and Klaus Dietmayer. &quot;Towards safe autonomous driving: Capture uncertainty in the deep neural network for lidar 3d vehicle detection.&quot; 2018 21st International Conference on Intelligent Transportation Systems (ITSC). IEEE, 2018.<br>
<a id="3" href="#3ref">[3]</a> Feng, Di, et al. &quot;Leveraging heteroscedastic aleatoric uncertainties for robust real-time lidar 3d object detection.&quot; 2019 IEEE Intelligent Vehicles Symposium (IV). IEEE, 2019.</p>
]]></content>
      <categories>
        <category>Uncertainty</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Uncertainty</tag>
      </tags>
  </entry>
  <entry>
    <title>MOT 评价指标-&quot;Evaluating Multiple Object Tracking Performance, the CLEAR MOT Metrics&quot;</title>
    <url>/MOT-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-Evaluating-Multiple-Object-Tracking-Performance-the-CLEAR-MOT-Metrics/</url>
    <content><![CDATA[<p>　　这篇文章介绍了两个综合性指标 MOTA 以及 MOTP 的计算过程，这两个指标有优劣势，但是作为综合性指标至今在学术界仍广泛应用。本文主要介绍其设计思想及计算过程。<br>
　　一个理想的 MOT 算法，我们期望每一帧：</p>
<ul>
<li>准确检测目标的数量；</li>
<li>准确估计每个目标的状态，如位置，朝向，速度等；</li>
<li>准确估计每个目标的轨迹，即目标的 ID 不变性；</li>
</ul>
<p>这就要求评价准则：</p>
<ul>
<li>能评估目标定位的精度；</li>
<li>能反映目标轨迹的追踪能力，即同一个目标产生唯一的 ID；</li>
</ul>
<p>此外，为了提高评价准则的实用性：</p>
<ul>
<li>参数尽可能少，阈值可调；</li>
<li>易于理解，表现方式符合人们的直觉；</li>
<li>有较强的通用性，能评估各种跟踪算法；</li>
<li>指标个数少，但是能足够反映算法不同维度的性能；</li>
</ul>
<p>假设第 \(t\) 帧，有目标集 \(\{o_1,...,o_n\}\)，跟踪算法的输出(hypotheses)：\(\{h_1,...h_m\}\)。根据上述设计准则，设计评价计算过程：</p>
<ol type="1">
<li> 构建 \(h_j\) 与 \(o_i\) 的最优匹配；</li>
<li> 对于每个匹配对，计算位置估计误差；</li>
<li> 累加所有匹配对的误差，包括：
<ol type="a">
<li> 计算漏检数(FN)；</li>
<li> 计算误检数(FP)；</li>
<li> 计算 ID swith 次数，包括两个邻近目标的 ID 交换，以及遮挡后，同一目标的 ID 跳变；</li>
</ol></li>
</ol>
<p>由此可得到两大指标：</p>
<ul>
<li>tracking precision，目标位置的估计精度；</li>
<li>tracking accuracy，包括 misses(FN), FP, mismatches(IDs), failures to recover；</li>
</ul>
<p>下面分两块做细节分析，匹配构建 (Establishing Correspondences) 与评价指标 (Metrics)。</p>
<h2 id="匹配构建">1. 匹配构建</h2>
<p>　　算法估计与目标真值的匹配，大致还是基于匹配最近 object-hypothesis 的思想，没匹配上的估计就是 FP，没匹配上的真值就是 FN。但是这中间需要进一步考虑一些问题。</p>
<h3 id="有效匹配">1.1. 有效匹配</h3>
<p>　　如果算法估计 \(h_j\) 与目标 \(o_i\) 的最近距离 \(dist_{i,j}\) 超过了一定的阈值 \(T\)，那么这个匹配也是不合理的，因为这个距离误差加入到定位误差中是不合理的，所以只能说这个跟踪的结果不是这个目标。关于距离的度量：</p>
<ul>
<li>区域（框）跟踪器，距离可用两者的重叠区域来度量，\(T\) 可以设为 0；</li>
<li>点跟踪器，距离可用两者中心点的欧氏距离来度量，\(T\) 可以根据目标的尺寸来设定；</li>
</ul>
<h3 id="跟踪一致性">1.2. 跟踪一致性</h3>
<p>　　统计目标与算法输出的匹配跳变的次数，也就是目标 ID 的跳变数。文章还提到，当目标有两个有效地匹配时，选择之前的匹配，即使那个匹配的距离大于另一个匹配，这点当存在两个很近的目标时，可能会有问题，需要全局来看。</p>
<h3 id="匹配过程">1.3. 匹配过程</h3>
<ol type="1">
<li> 对 \(t\) 帧，考虑 \(M_{t-1}\) 中所有匹配是否还依然有效，包括目标真值及算法输出是否还存在，如果都存在，那么距离是否超出阈值 \(T\)；</li>
<li> 对于剩下的没找到匹配的真值目标，在唯一匹配以及阈值约束下，可采用匹配算法或者贪心算法来求解，使得距离误差的总和最小（文章的意思是排除了从上一帧继承的已有匹配，当目标密集时，这部分也应该加入进来优化）。统计当前帧目标真值匹配的跳变数 \(mme_t\)，作为 mismatch errors；</li>
<li> 经过之前两步后，找到了所有的匹配，统计匹配个数为 \(c_t\)，计算匹配上的目标真值与算法输出的定位误差 \(d_t^i\)；</li>
<li> 统计没有匹配上的算法输出 (hypotheses) 为 \(fp_t\)，没有匹配上的目标真值为 \(m_t\)，目标真值个数为 \(g_t\)；</li>
<li> 每一帧重复步骤１，第一帧没有 mismatch；</li>
</ol>
<h2 id="评价指标">2. 评价指标</h2>
<p>　　基于以上的匹配策略，得出两个合理的指标：</p>
<ul>
<li><strong>MOTP</strong>(multiple object tracking precision)，跟踪定位精度指标：<span class="math display">\[MOTP=\frac{\sum_{i,t}d_t^i}{\sum_tc_t}\]</span></li>
<li><strong>MOTA</strong>(multiple object tracking accuracy)，综合了漏检率，误检率，以及 ID 跳变率：<span class="math display">\[MOTA=1-\frac{\sum_t(m_t+fp_t+mme_t)}{\sum_tg_t}\]</span></li>
</ul>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>MOT Multimodal Fusion</title>
    <url>/MOT-Fusion/</url>
    <content><![CDATA[<p>　　同一传感器的目标状态估计在<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中已经有较详细的介绍。不同传感器在不同光照不同天气情况下，有不同的表现，比如相机在低光照下可靠性较差，而激光雷达能弥补这个缺陷。所以在目标状态估计中，多传感器融合非常重要，可以是<strong>数据前融合，特征级融合，目标状态后融合</strong>。本文关注目标状态后融合过程。</p>
<h2 id="问题描述">1. 问题描述</h2>
<p>　　考虑两个传感器 \(A,B\) (传感器可为相机，激光雷达，毫米波雷达等)检测输出的(也可以是经过滤波的)多目标分别为：\(A=\{A _ i\in\mathbb{R}^D|i=1,...,M\}\)，\(B=\{B _ i\in\mathbb{R}^D|i=1,...,N\}\)，其中 \(\mathbb{R}^D\) 表示目标状态的维数，如位置，速度，朝向，类别等。MOT 的多模态后融合问题即由此求解融合后结果 \(C=\{C _ i\in\mathbb{R}^D|i=1,...,L\}\)，该过程主要有三步：</p>
<ol type="1">
<li>目标匹配/数据关联：从 \(A,B\) 中找出同一目标的两个多模态观测量，设匹配数为 \(K\)；</li>
<li>目标状态的多模态融合：对匹配上的同一目标的两个多模态观测进行融合；</li>
<li>整合目标，经过滤波输出最终结果，目标数目为 \(L=M+N-K\)；</li>
</ol>
<h2 id="目标匹配">2. 目标匹配</h2>
<p>　　本质上与单传感器下目标状态估计中前后帧的数据关联问题一致，这里的关键步骤是：</p>
<ol type="1">
<li>提取每个目标的特征向量：可以是位置，速度，角度，CNN特征层等；</li>
<li>构建 cost function：对两个目标集合建立 Cost 矩阵；</li>
<li>匈牙利算法找出最优匹配；</li>
</ol>
<p>　　传统的 cost function 基本是向量的 Euclidean 距离或是 cosine 距离，<a href="#1" id="1ref">[1]</a> 提出了一种 Deep Affinity Network 来一次性解决两个目标集合的匹配问题。 <img src="/MOT-Fusion/affinity.png" width="70%" height="70%" title="图 1. Affinity Network"> 　　如图 1. 所示，两个目标集 \(A\in\mathbb{R}^{M\times D}\)，\(B\in\mathbb{R}^{N\times D}\)，扩展到维度 \(\mathbb{R}^{M\times N\times D}\)，相减后输入到网络中，预测出 affinity matrix，\(C\in\mathbb{R}^{M\times N}\)，其中 \(C _ {ij}=1\) 表示匹配上同一目标，否则认为是两个目标。这里关键是 Loss 的设计，最简单的 Loss 为： <span class="math display">\[L(A,B)=\frac{1}{MN}\sum _ {i=1} ^ {M}\sum _ {j=1}^N |C _ {ij}-G _ {ij}| \tag{1}\]</span> 其中 \(G\) 为亲和度矩阵的 groundtruth。实际对亲和度矩阵并没有 0-1 要求，最终是通过匈牙利算法找出匹配的，所以只要将同一目标的分数增大，不同目标的分数减小，最终即可选出匹配。由此设计 Loss： <span class="math display">\[L(A,B)=\sum _ {i,\,j;\,G _ {ij}=1} \left(\sum _ {k;\,G _ {ik}\neq 1}\mathrm{max}(0,C _ {ik}-C _ {ij}+m)+\sum _ {p;\,G _ {pj}\neq 1}\mathrm{max}(0,C _ {pj}-C _ {ij}+m)\right)\tag{2}\]</span> 其中 \(m\) 控制正负样本的相对大小。式(2)更容易使网络收敛。</p>
<h2 id="多模态融合">3. 多模态融合</h2>
<p>　　当多传感器检测的同一目标匹配上后，需要融合出一个最终的观测。可以采用卡尔曼滤波的方法，<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中的式(1)~(6)是时序下状态估计的迭代过程。对于多模态融合，虽然是同时获取的观测，但是融合过程类似，令测量矩阵 \(H _ k\) 为单位阵，所以可得卡尔曼增益： <span class="math display">\[K _ k=\frac{\bar{P} _ k}{\bar{P} _ k+R _ k} \tag{3}\]</span> 由此计算后验概率<a href="#2" id="2ref"><sup>[2]</sup></a>： <span class="math display">\[\begin{align}
\hat{x} _ k &amp;=\bar{x} _ k+K(z_k-\bar{x}) = \frac{\bar{P} _ kz _ k + \bar{x} _ kR _ k}{\bar{P} _ k+R _ k} \tag{4}\\
\hat{P} _ k &amp;=(I-KH _ k)\bar{P} _ k =\frac{\bar{P} _ kR _ k}{\bar{P} _ k+R _ k}\tag{5}
\end{align}\]</span> 对于多模态输入 \(A,B\)，令 \(A = \bar{x} _ k,\sigma _ A^2 = \bar{P} _ k\)，\(B=z _ k,\sigma _ B^2 =R _ k\)，可得多模态融合结果为： <span class="math display">\[\begin{align}
C &amp;= \frac{\sigma _ A^2B+\sigma _ B^2A}{\sigma _ A^2+\sigma _ B^2}\\
\sigma _ C^2 &amp;= \frac{\sigma _ A^2\sigma _ B^2}{\sigma _ A^2+\sigma _ B^2}\\
\tag{6}\end{align}\]</span> 式(6)等价于： <span class="math display">\[\begin{align}
\sigma _ C^2 &amp;= \frac{\sigma _ A^2\sigma _ B^2}{\sigma _ A^2+\sigma _ B^2}\\
C &amp;= \sigma _ C^2\left(\frac{A}{\sigma _ A^2}+\frac{B}{\sigma _ B^2}\right)\\
\tag{7}\end{align}\]</span> 这是 BCM<a href="#3" id="3ref"><sup>[3]</sup></a>！卡尔曼滤波器也是在贝叶斯概率模型下导出来的，可见两个高斯分布的同一状态的观测量，均可通过 BCM 进行融合。<br>
　　得到当前时刻多模态融合后的目标状态后，即可进一步作时序卡尔曼平滑获得最终估计的目标状态。<br>
　　另一种融合方法是在 JPDAF(Joint Probabilistic Data Association Filter)<a href="#4" id="4ref"><sup>[4]</sup></a>框架下作两次 PDA 融合<a href="#5" id="5ref"><sup>[5]</sup></a>，JPDAF 是另一种数据关联(目标匹配)的方法，这里不作展开。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Kuang, Hongwu, et al. &quot;Multi-Modality Cascaded Fusion Technology for Autonomous Driving.&quot; arXiv preprint arXiv:2002.03138 (2020).<br>
<a id="2" href="#2ref">[2]</a> Fankhauser, Péter, et al. &quot;Robot-centric elevation mapping with uncertainty estimates.&quot; Mobile Service Robotics. 2014. 433-440.<br>
<a id="3" href="#3ref">[3]</a> Tresp, Volker. &quot;A Bayesian committee machine.&quot; Neural computation 12.11 (2000): 2719-2741.<br>
<a id="4" href="#4ref">[4]</a> Arya Senna Abdul Rachman, Arya. &quot;3D-LIDAR Multi Object Tracking for Autonomous Driving: Multi-target Detection and Tracking under Urban Road Uncertainties.&quot; (2017).<br>
<a id="5" href="#5ref">[5]</a> JRMOT: A Real-Time 3D Multi-Object Tracker and a New Large-Scale Dataset</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Registration with Point Cloud</title>
    <url>/Object-Registration-with-Point-Cloud/</url>
    <content><![CDATA[<p>　　<a href="/ADH-Tracker/" title="ADH Tracker">ADH Tracker</a> 通过 ADH 方法有效得在两目标点云的 T 变换的解空间中搜索出高概率解集，并用简单的运动模型，在贝叶斯概率框架下进行目标状态(位置，速度)的估计。这其中关键的环节还是两目标点云之间变换关系 \((R,T)\) 的求解，即 Object Registration。<br>
　　求解两点云之间的位姿关系，传统的做法是 ICP。以 ICP 为代表的方法大多数都是迭代法，本文介绍两种 learning-based 点云注册方法。</p>
<h2 id="deep-closet-point1">1. Deep Closet Point<a href="#1" id="1ref"><sup>[1]</sup></a></h2>
<h3 id="icp-描述">1.1. ICP 描述</h3>
<p>　　假设两个点云集：\(\mathcal{X}=\{x _ 1,...,x _ i,...,x _ N\}\in\mathbb{R}^3\)，\(\mathcal{Y}=\{y _ 1,...,y _ j,...y _ M\}\in\mathbb{R}^3\)。两个点集之间的变换为 \(R,t\)，定义点集匹配的误差函数： <span class="math display">\[ E(R,t) = \frac{1}{N}\sum_i^N\Vert Rx_i+t-y _ {m(x_i)}\Vert \tag{1}\]</span> 其中 \(y_{m(x_i)}\) 为 \(x_i\) 经过变换后匹配上的最近点，即： <span class="math display">\[ m(x_i,\mathcal{Y}) = \mathop{\arg\min}_j\Vert Rx_i+t-y_j\Vert \tag{2}\]</span> 定义点云重心：\(\bar{x}=\frac{1}{N}\sum _ {i=1}^Nx _ i\)，\(\bar{y}=\frac{1}{M}\sum _ {j=1}^Ny _ j\)。计算 Cross-covariance 矩阵： <span class="math display">\[ H = \sum_{i=1}^N(x_i-\bar{x})(y_i-\bar{y}) \tag{3}\]</span> \(R,t\) 变换可通过 \(H=USV^T\) 最小化误差函数 \(E(R,t)\) 实现： <span class="math display">\[\left\{\begin{array}{l}
R= VU^T\\
t= -R\bar{x}+\bar{y}
\end{array}\tag{4}\right.\]</span> ICP 算法就是迭代得求解式(2)与式(1)的过程。</p>
<h3 id="网络结构">1.2. 网络结构</h3>
<p><img src="/Object-Registration-with-Point-Cloud/DCP.png" width="80%" height="80%" title="图 1. DCP"> 　　如图 1. 所示，DCP 网络结构由三部分组成：</p>
<ul>
<li><strong>Embedding Module</strong><br>
特征提取层，可以用 PointNet，也可以用 DGCNN 网络(<a href="/PointCloud-Feature-Extraction/" title="PointCloud Feature Extraction">PointCloud Feature Extraction</a>)，DGCNN 能更有效的提取局部特征。</li>
<li><strong>Transformer</strong><br>
该模块基于 Attention 机制，详情可参考<a href="#3" id="3ref">[3]</a><a href="#4" id="4ref">[4]</a>。</li>
<li><strong>Head</strong><br>
该模块用于预测 \((R,t)\)，可以简单的用 MLP 回归，也可以用 SVD 层来预测，因为 Transformer 会输出 \(x_i\) 在 \(\mathcal{Y}\) 中的匹配点。</li>
</ul>
<h3 id="loss">1.3. Loss</h3>
<p>　　Loss 比较简单，也是基于有监督的学习： <span class="math display">\[ Loss = \Vert R^TR_g-I\Vert ^2 + \Vert t-t_g\Vert ^2 + \lambda \Vert\theta\Vert ^2\]</span></p>
<h2 id="alignnet-3d2">2. AlignNet-3D<a href="#2" id="2ref"><sup>[2]</sup></a></h2>
<h3 id="网络结构-1">2.1. 网络结构</h3>
<p><img src="/Object-Registration-with-Point-Cloud/AlignNet.png" width="60%" height="60%" title="图 2. AlignNet"> 　　如图 2. 所示，AlignNet 由两个网络组成：</p>
<ul>
<li><strong>CanonicalNet</strong><br>
CanonicalNet 作用是预测点集目标3D框的中心点坐标系，从而将点集坐标转换到中心点坐标系。预测点集目标3D框的中心点坐标系通过 coarse-to-fine 方式实现，stage1(T-CoarseNet) 只粗略预测中心点的位置信息，stage2(T-FineNet) 预测中心点位置相对 Stage1 的残差，以及中心点坐标系的旋转量。参考以前的方法，旋转量通过角度区域分类＋残差实现。通过该网络，每个点集的坐标均在各自目标框中心点坐标系下，能直观的反应目标的形状。</li>
<li><strong>Head</strong><br>
Head(stage3) 则将两个点集特征聚合，预测各中心点坐标系下两个点集的相对位姿。<br>
设点集 \(s_1\) 经过 CanonicalNet 预测的变换为 \(T_1\)，\(s_2\) 对应的变换为 \(T_2\)，stage3 预测的两者的变换为 \(T_f\)，那么最终得到的两个点集的变换为 \(T_1T_fT_2^{-1}\)。</li>
</ul>
<h3 id="loss-1">2.2. Loss</h3>
<p>　　stage1 预测了 translation，stage2/stage3 预测了 translation 和 rotation，总的 Loss 为： <span class="math display">\[\begin{align}
L &amp;= L_{trans,overall}+\lambda_2\cdot L_{angle,overall}\\
  &amp;= \lambda_1(L_{trans,s1}+L_{trans,s2}) + L_{trans,s3} + \lambda_2(\lambda_1L_{angle,s2}+L_{angle,s3})
\end{align}\]</span> stage1/stage2 预测的目标框中心点坐标系(包括中心点坐标及目标框的朝向)真值由点云所构成的目标框提供。</p>
<h3 id="不足点">2.3. 不足点</h3>
<p>　　这种级联式的方法，思想是非常好的，将两个点集的相对位姿分解为两大部来求解，即先将点集转换到中心点坐标系，然后再求解点集剩下位姿残差，coarse-to-fine，能较好回归且收敛。<br>
　　但是存在一些问题。我们假设两个点集作为同一刚性目标，其3D框没有偏差(标注非常准)，那么 CanonicalNet 出来结果，已经可以作为相对位姿结果。但是标注肯定会有抖动(除非是生成的数据)，可以认为是高斯分布，以及获取点云的传感器的测量噪音，这样的话，看起来 stage3 就是只用来拟合这种均值为 0 的高斯分布了。<br>
　　所以本方法对生成的数据与真实的数据，存在一定的偏差，因为目标框真值的抖动分布不一致。这样的话在生成的数据上训练的网络，直接迁移到真实数据中，可能性能会下降比较明显，反之可能还好。</p>
<h2 id="参考文献">3. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Wang, Yue, and Justin M. Solomon. &quot;Deep Closest Point: Learning Representations for Point Cloud Registration.&quot; arXiv preprint arXiv:1905.03304 (2019).<br>
<a id="2" href="#2ref">[2]</a> Groß, Johannes, Aljoša Ošep, and Bastian Leibe. &quot;AlignNet-3D: Fast Point Cloud Registration of Partially Observed Objects.&quot; 2019 International Conference on 3D Vision (3DV). IEEE, 2019.<br>
<a id="3" href="#3ref">[3]</a> Vaswani, Ashish, et al. &quot;Attention is all you need.&quot; Advances in neural information processing systems. 2017.<br>
<a id="4" href="#4ref">[4]</a> https://zhuanlan.zhihu.com/p/48508221</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>ICP</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>PointFlowNet</title>
    <url>/PointFlowNet/</url>
    <content><![CDATA[<p>　　点云的 Scene Flow 与 Semantic 一样是一个较低层的信息，通过 Point-Wise Semantic 信息可以作物体级别的检测，这种方式有很高的召回率，且超参数较少。同样，通过 Point-Wise Scene Flow 作目标级别的运动估计(当然也可作物体点级别聚类检测的线索)，也会非常鲁棒。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 将点级别/Voxel 级别的 Scene Flow 与 3D 目标检测融合在一起，作物体级别的运动估计，工作系统性较强。</p>
<h2 id="问题描述">1. 问题描述</h2>
<p>　　设 \(t\) 时刻点云 \(\mathbf{P} _ t\in\mathbb{R}^{M\times 3}\)，那么需要求解的未知量有：</p>
<ul>
<li>每个点的 Scene Flow: \(\mathbf{v} _ i\in\mathbb{R} ^3\);</li>
<li>每个点集的 Rigid Motion: \(\mathbf{R} _ i\in\mathbb{R}^{3\times 3}\)，\(\mathbf{t} _ i\in\mathbb{R}^{3}\);</li>
<li>每个物体的 3D 属性：Location，Orientation，Size，Rigid Motion;</li>
</ul>
<h2 id="算法框架">2. 算法框架</h2>
<p><img src="/PointFlowNet/framework.png" width="90%" height="90%" title="图 1. PoingFlowNet Framework"> 　　如图 1. 所示，PointFlowNet 由四部分组成，分别为：Feature Encoder，Scene Flow/Ego-motion Estimation and 3D Object Detection，Rigid Motion Estimation，Object Motion Decoder。Feature Encoder 将前后帧点云栅格化后作特征提取，然后 Context Encoder 作进一步的特征融合去提取；输出的特征第一个分支作 Voxel 级别的 Scene Flow 预测，进一步作每个点的 Rigid Motion 预测(<strong>每个点属于对应物体的 Motion 在该 Voxel 坐标系下的表示</strong>)；第二个分支作 Ego-Motion 的预测；第三个分支作 3D 目标检测，进一步作目标的 Motion Decoder。</p>
<h3 id="feature-encoder">2.1. Feature Encoder</h3>
<p>　　不同的点云特征提取方式都可采用，本文采用传统的 Bird-View Voxel 表示方式，然后作 2D/3D 卷积。同时还需要将前后帧的点云作特征融合，这里也完全可以采用 <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 的特征提取形式。</p>
<h3 id="scene-flowrigid-motion-decoder">2.2. Scene Flow/Rigid Motion Decoder</h3>
<p>　　Scene Flow 是作 Bird-View 下 Voxel 级别的场景流预测，然后再预测 Rigid Motion。 <img src="/PointFlowNet/rigid-motion.png" width="80%" height="80%" title="图 2. Rigid MOtion Estimation"> 　　如图 2. 所示，世界坐标系 \(\mathbf{W}\) 下点 \(\mathbf{p}\) 的 scene flow 表示为 \(\mathbf{v}\)，刚体物体的局部坐标系从 \(\mathbf{A}\) 经过 \((\mathbf{R _ A, t _ A})\) 运动到 \(\mathbf{B}\) ，那么其 scene flow 可表示为： <span class="math display">\[\mathbf{v=[R _ A(p-o _ A)+t _ A]-(p-o _ A)} \tag{1}\]</span> 本文论证了两个定理：</p>
<ol type="1">
<li>scene flow 只能通过刚体局部坐标系的运动导出，不能直接通过世界坐标系下的刚体运动导出(除非运动无旋转量)。所以如图 1. 所示，通过 scene flow 预测出的 voxel motion 是局部坐标系下的，还需通过坐标变换到世界坐标系下。<strong>这里每个 Voxel 预测量的局部坐标系采用 Voxel 中心点</strong>。作目标运动估计时，&quot;世界坐标系&quot;其实可以定义为物体坐标系(Voxel 为局部坐标系)，最后再通过 Ego-motion 变换到世界坐标系。</li>
<li>不管是局部坐标系 \(\mathbf{A}\) 还是 \(\mathbf{B}\)，都能导出 scene flow。</li>
</ol>
<p>　　如图 2. 所示，实验也验证了 scene flow 不能直接学习到世界坐标系下的 translation 运动。</p>
<h3 id="ego-motion-regressor">2.3. Ego-motion Regressor</h3>
<p>　　根据前后帧的点云回归本车的运动(ego-motion)，ego-motion 建立局部坐标系与世界坐标系的联系。如果有更精准的外部模块估计的 ego-motion，则可以直接替换采用。</p>
<h3 id="d-object-detection-and-object-motion-decoder">2.4. 3D Object Detection and Object Motion Decoder</h3>
<p>　　Bird-view 下 Voxel 后的 3D 检测方法很多，可以是 Anchor-based，Anchor-free，Semantic Segmentation 等方法，其中如果采用 Semantic Segmentation + cluster 方法，那么 scene flow 的结果也可作为 cluster 的线索。<br>
　　有了 3D 目标以及目标内 Voxel 的 Rigid Motion 后，取平均或中值即可得到目标的 Motion。<br>
　　<strong>Voxel Rigid Motion 可以有两种回归方法：</strong></p>
<ol type="1">
<li>translation 真值为实际该 Voxel 的位移，rotation 为对应刚体的旋转量；</li>
<li>translation 与 rotation 均为对应刚体的位移与旋转量；</li>
</ol>
<p>我理解的本文是采用方法 1. 这种形式，这种形式的好处是回归的就是真实 Voxel 的位移，与输入的特征是 Voxel 级别对应的，但是简单的对目标内的 Voxel 取平均或中值只是目标位移的近似，实际目标的真实位移应该为旋转中心 Voxel 的位移。而方法 2. 是物体级别的回归量，均值即可反应物体的运动，只要构建物体级别的 Loss，用 Voxel 去学习物体级别的运动应该问题不大，所以可能方法 2. 更合理。</p>
<h2 id="loss-functions">3. Loss Functions</h2>
<p>　　采用 Voxel 级别的 Loss，总的 Loss 为： <span class="math display">\[\mathcal{L}=\alpha\mathcal{L} _ {flow}+\beta\mathcal{L} _ {rigmo} + \gamma\mathcal{L} _ {ego}+\mathcal{L} _ {det}\tag{2}\]</span> 这四部分具体的形式为：</p>
<ol type="1">
<li>Scene Flow Loss<br>
对于有效的 Voxel，作预测值与真值的 \(\mathcal{l} _ 1\) 误差： <span class="math display">\[\mathcal{L} _ {flow}=\frac{1}{K}\sum _ j\Vert \mathbf{v} _ j-\mathbf{v} _ j ^ * \Vert \tag{3}\]</span></li>
<li>Rigid Motion Loss<br>
对于有效的 Voxel，作预测值与真值(真值有两种形式，详见 2.4 讨论)的 \(\mathcal{l} _ 1\) 误差： <span class="math display">\[\mathcal{L} _ {rigmo} = \frac{1}{K}\sum _ j\Vert\mathbf{t} _ j-\mathbf{t} _ j^ * \Vert+\lambda\Vert\theta _ j-\theta _ j^ * \Vert\tag{4}\]</span></li>
<li>Ego-motion Loss<br>
同样的对预测值与真值作 \(\mathcal{l} _ 1\) Loss: <span class="math display">\[\mathcal{L} _ {ego}=\Vert\mathbf{t} _ {BG}-\mathbf{t} _ {BG}^ * \Vert+\lambda\Vert\theta _ {BG}-\theta _ {BG}^ * \Vert \tag{5}\]</span></li>
<li>Detection Loss<br>
不作赘述。</li>
</ol>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Behl, Aseem, et al. &quot;Pointflownet: Learning representations for rigid motion estimation from point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>
]]></content>
      <categories>
        <category>Scene Flow</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>Scene Flow</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>PointNet 系列论文详读</title>
    <url>/PointNet-%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%E8%AF%A6%E8%AF%BB/</url>
    <content><![CDATA[<p>　　写了半天，发现还是网上一篇文章整理的好，直接上传递门吧：<a href="https://zhuanlan.zhihu.com/p/44809266" target="_blank" rel="noopener">PointNet 系列论文解读</a></p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;SA-SSD: Structure Aware Single-stage 3D Object Detection from Point Cloud&quot;</title>
    <url>/SA-SSD/</url>
    <content><![CDATA[<p>　　Voxel-based 3D Detection 相比 <a href="/Point-based-3D-Det/" title="Point-based 3D Detection">Point-based 3D Detection</a> 的缺点是特征提取不仅在 Voxel 阶段损失了一定的点云信息，而且 Voxel 化后丢失了点云之间的拓扑关系。<a href="/Point-based-3D-Det/" title="Point-based 3D Detection">Point-based 3D Detection</a> 中详细描述了几种 Point-based 方法，这种方法目前比较棘手的地方是，即使作 Inference 时，也需要作 kd-tree 搜索与采样等运算量较大的操作。那么如何榨干 Voxel-based 的性能对工业界落地就显得比较重要了，本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种单阶段的 Voxel-based 3D 检测方法，并借助了 Point 级别特征提取的相关策略，使得检测性能有较大提升。</p>
<h2 id="framework">1. Framework</h2>
<p><img src="/SA-SSD/framework.png" width="100%" height="100%" title="图 1. Framework of SA-SSD"> 　　如图 1. 所示，SA-SSD 由三部分组成：Backbone，Detection Head，Auxiliary Network。<br>
　　Backbone 的输入是栅格化后的点云表示方式，文中栅格大小设定为 \(0.05m,0.05m,0.1m\)。Backbone 由一系列的 3D convolution 组成，因为需要保留空间三维位置信息，作 Voxel-to-Point 的映射。这里如果用 2D convolution 代替，那么 Auxiliary Network 估计也只能作 BridView 的分割了。<br>
　　Detection Head 主体就是传统 Anchor-Free 结构，一个分支用于预测每个特征层像素点的 Confidence，另一个分支用于预测基于每个特征层像素点的 BBox 属性，如，以该点为 &quot;Anchor&quot; 的四个顶点坐标。此外，为了消除 One-Stage 方法中目标框与置信度不对齐的问题，本文引入 Part-sensitive Warping 来实现与 PSRoiAlign 类似的作用，实现两者的对齐。<br>
　　Auxiliary Network 只在训练的阶段起作用，Inference 阶段不需要计算。该模块的作用是训练时通过 Voxel-to-Point 特征映射来反向传播监督 Backbone 中的 Voxel 特征学习 Point 级别的特征，包括点云的空间拓扑关系。<strong>当然 Inference 时也可以保留该分割模块，那么还可以增加点级别的特征反映射到 Voxel 的模块(Point-to-Voxel)，进一步作特征增强。</strong></p>
<h2 id="detachable-auxiliary-network">2. Detachable Auxiliary Network</h2>
<p><img src="/SA-SSD/sa.png" width="60%" height="60%" title="图 2. Structured Aware Feature Learning"> 　　如图 2. 所示，随着 Backbone 特征提取的感受野增大(特征分辨率下降)，背景点会接近目标的边缘，使得目标框大小不容易预测准确。本文提出的 Auxiliary Network，通过增加点级别分割及目标中心坐标预测任务，来监督 Backbone 特征层捕捉这种结构信息，从而达到更准确的目标检测的目的。<br>
　　Auxiliary Network 的输入来自 Backbone 各个分辨率的特征层。将特征层上不为零的特征点，通过 Voxel-to-Point 反栅格化映射到三维空间，设该特征点表示为 \(\{(f _ j,p _ j):j=1,...,M\}\)，其中 \(f\) 为特征向量，\(p\) 为坐标向量。有了栅格对应的伪三维坐标点下的特征表示后，即可插值出实际点云中每个点的特征向量。设点云中点的插值特征为：\(\{(\hat{f} _ i,p _ i):i=1,...,N\}\)，采用 Inverse Distance Weighted 方法进行插值： <span class="math display">\[ \hat{f} _ i = \frac{\sum _ {j=1}^Mw _ j(p _ i)f _ j}{\sum _ {j=1}^Mw _ j(p _ i)} \tag{1}\]</span> 其中： <span class="math display">\[w _ j(p _ i)=\left\{\begin{array}{l}
\frac{1}{\Vert p _ i-p _ j\Vert _ 2} &amp; \mathrm{if} p _ j\in\mathcal{N}(p _ i)\\
0 &amp; \mathrm{otherwise}
\end{array}\tag{2}\right.\]</span> \(\mathcal{N}(p _ i)\) 为球状区域，本文在四个分辨率下分别设定为：0.05m，0.1m，0.2m，0.4m。然后通过 cross-stage link 对各个分辨率下的点特征进行 concatenate 融合。最后通过感知机进行点云分割及目标中心点预测任务的构建。<br>
　　对于点级别前景分割的任务，经过 sigmoid 函数后，应用二分类的 Focal Loss： <span class="math display">\[ \mathcal{L} _ {seg} = \frac{1}{N _ {pos}}\sum _ i^N -\alpha(1-\hat{s} _ i)^{\gamma}\mathrm{log}(\hat{s} _ i) \tag{3}\]</span> 该分割任务使得目标检测的框更加准确，如图 2.c 所示。但是还得优化其尺度与形状。<br>
　　中心点的预测任务则能有效约束目标框的尺度与形状，具体的，预测的是每个属于目标的点云与中心点的相对位置(残差)。可用 Smooth-l1 来构建预测的中心点与实际中心点的 Loss。</p>
<h2 id="part-sensitive-warping">3. Part-sensitive Warping</h2>
<p><img src="/SA-SSD/psw.png" width="60%" height="60%" title="图 3. Part-sensitive Warping"> 　　One-Stage 方法都会有 Confidence 和 BBox 错位的现象，本文提出一种类似 PSROIAlign 但更有高效的 PSW 方法，具体步骤为：</p>
<ol type="1">
<li>对于分类分支，修改为 \(K\) 个 Part-sensitive 的 cls maps，每个 map 包含目标的部分信息，比如当 \(K=4\) 时，可以理解为将目标切分为 \(2\times 2\) 部分；</li>
<li>对于回归分支，将每个目标框的 Feature map 划分为 \(K\) 个子区域，每个区域的中心点作为采样点；</li>
<li>如图 3. 所示，通过采样得到最终 cls map 的平均值。</li>
</ol>
<h2 id="experiment">4. Experiment</h2>
<p><img src="/SA-SSD/ablation.png" width="60%" height="60%" title="图 4. Ablation Study"> 　　如图 4. 所示，Auxiliary Network 能有效提升网络的定位精度，PSWarp 也能有效消除 Confidence 与 BBox 的错位影响。</p>
<h2 id="reference">5. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> henhang, et al. &quot;Structure Aware Single-stage 3D Object Detection from Point Cloud.&quot;</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
        <tag>Autonomous Driving</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsupervised Low-Light Image Enhancement</title>
    <url>/Unsupervised-Low-Light-Image-Enhancement/</url>
    <content><![CDATA[<p>　　在自动驾驶中，相机能捕捉丰富的纹理信息，是不可或缺的传感器。但是受限于相机 Sensor 及 ISP 性能，其动态范围有限，往往会出现过曝或欠曝的情况。过曝的情况还能通过 3A(AE, AF, AW) 中的 AE 调节，而欠曝的情况，AE 中要么提高增益或 ISO 但是会增加噪声，要么增加曝光时间但是撑死 50ms(按照 20Hz)，光圈则一般是固定的，不会调节。所以在低光照自动驾驶场景下，对欠曝的图像进行亮度增强则显得尤其重要（当然也可用夜视相机如红外相机等辅助)。<br>
　　基于学习的图像增强方法，由于很难获得大量的欠爆图像与对应的增强图像。所以无监督的图像增强方法就更有应用价值，本文介绍几种无监督图像增强方法。</p>
<h2 id="zero-dce1">1. Zero-DCE<a href="#1" id="1ref"><sup>[1]</sup></a></h2>
<p>　　无监督图像增强方法主要是指基于 GAN 的方法，基于 GAN 的方法还是需要选择欠爆图像及正常图像两个分布的数据集，选择不当也会导致性能下降。而 Zero-DCE 则无需选择正常图像数据集，消除了数据分布下过拟合或欠拟合的风险。<br>
　　Zero-DCE 基本思想是对每个像素作亮度变换，每个像素的变换方程为： <span class="math display">\[LE(I(\mathrm{x});\alpha) = I(\mathrm{x}) + \alpha I(\mathrm{x})(1-I(\mathrm{x})) \tag{1}\]</span> 其中 \(\alpha\in[-1,1]\) 是变换系数。对图像的每个通道每个像素分别作不同系数的迭代变换，可得： <span class="math display">\[LE _ n(\mathrm{x}) = LE _ {n-1}(\mathrm{x}) + \mathcal{A} _ n LE _ {n-1}(\mathrm{x})(1-LE _ {n-1}(\mathrm{x})) \tag{2}\]</span> 其中 \(\mathcal{A} _ n\) 是变换系数集，与图像大小一致。 <img src="/Unsupervised-Low-Light-Image-Enhancement/Zero-DCE.png" width="90%" height="90%" title="图 1. Zero-DCE Framework"> 　　如图 1. 所示，Zero-DCE 框架中，一个基本网络预测几组 \(\mathcal{A} _ n\) 集合，然后对原图每个通道进行迭代的亮度变换。LE-curves 不仅能增强暗处的曝光量，还能减弱过曝处的亮度值。<br>
　　该方法最重要的是 Loss 函数的设计，一共有以下 Loss 组成：</p>
<ol type="1">
<li><strong>Spatial Consisiency Loss</strong><br>
增强后的图像要求其与原图具有空间一致性： <span class="math display">\[ L _ {spa} = \frac{1}{K}\sum _ {i=1}^K\sum _ {j\in\Omega (i)}\left(\Vert Y _ i-Y _ j\Vert-\Vert I _ i-I _ j\Vert\right)^2 \tag{3}\]</span> 其中 \(\Omega\) 为某像素的领域集，可为四领域；\(K\) 为局部区域数量，可设定为 \(4\times 4\) 大小；\(Y,I\) 分别为增强后与原始的像素亮度值。</li>
<li><strong>Exposure Control Loss</strong><br>
曝光控制 Loss 相当于设定曝光量去监督训练每个像素亮度，实现“无监督”的效果： <span class="math display">\[ L _ {exp} = \frac{1}{M}\sum _ {k=1}^M\Vert Y _ k-E\Vert \tag{4}\]</span> 其中 \(M\) 为无重合的局部区域数量，可设定为 \(16\times 16\) 大小；\(Y _ k\) 为局部区域的平均亮度值。作者实验中，设定 \(E\in[0.4,0.7]\) 均能获得相似的较好的结果。</li>
<li><strong>Color Constancy Loss</strong><br>
根据 Gray-World color constancy 假设：rgb 每个通道的平均亮度值与 gray 灰度值一致。所以为了保证颜色不失真，构造： <span class="math display">\[ L _ {col}=\sum _ {\forall (p,q)\in \epsilon}(J^p-J^q), \epsilon=\{R,G,B\} \tag{5}\]</span> 其中 \(p,q\) 表示一对不同的颜色通道，\(J\) 表示该通道的平均亮度值。</li>
<li><strong>Illumination Smoothness Loss</strong><br>
增强的过程要求相邻亮度值是平滑的，对增强变换系数作约束： <span class="math display">\[ L _ {tv _ {\mathcal{A}}} = \frac{1}{N}\sum _ {n=1}^N\sum _ {c\in\epsilon}(\nabla _ x\mathcal{A} _ n^c+\nabla _ y\mathcal{A} _ n^c)^2, \epsilon = \{R,G,B\}\tag{6}\]</span> 其中 \(N\) 为增强迭代数；\(\nabla _ x,\nabla _ y\) 分别表示水平与垂直方向的求导操作。</li>
</ol>
<p>最终 Loss 构成为： <span class="math display">\[ L _ {total} = L _ {spa} + L _ {exp} + W _ {col}L _ {col} + W _ {tv _ {\mathcal{A}}}L _ {tv _ {\mathcal{A}}} \tag{7}\]</span></p>
<h2 id="enlightengan2">2. EnlightenGAN<a href="#2" id="2ref"><sup>[2]</sup></a></h2>
<p>　　图像增强本质上是作 domain transfer，所以能用 GAN 处理，实现无监督训练。 <img src="/Unsupervised-Low-Light-Image-Enhancement/EnlightenGAN.png" width="90%" height="90%" title="图 2. EnlightenGAN Framework"> 　　如图 2. 所示，EnlightenGAN 由 Generator 和 Discriminator 构成。Generator 是一个 attention-guided U-Net，因为我们期望欠曝的区域能增强，所以将亮度值归一化后，用 1 减去亮度值作为注意力图，与原图一起输入网络。Discriminator 由 Global Discriminator 与 Local Discriminator 组成，因为经常只需要局部区域的亮度，所以设计 Local Discriminator 就很有必要。<br>
　　Loss 的设计非常关键，EnlightenGAN 一共有以下 Loss 组成：</p>
<ol type="1">
<li><strong>Adversarial Loss</strong><br>
用于直接训练 Generator 以及 Discriminator 的 Loss，与传统的 GAN Loss 类似；</li>
<li><strong>Self Feature Preserving Loss</strong><br>
注意到，调整输入图像值的范围，对最终的高层任务影响不是很大，所以引入网络特征 Loss 来保证增强后图像的准确性。对原始图像与生成的图像，分别输入到在 ImageNet 上预训练的 VGG-16 模型，提取特征集合，将对应的特征对作 L1 Loss。</li>
</ol>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Guo, Chunle, et al. &quot;Zero-Reference Deep Curve Estimation for Low-Light Image Enhancement.&quot; arXiv preprint arXiv:2001.06826 (2020).<br>
<a id="2" href="#2ref">[2]</a> Jiang, Yifan, et al. &quot;Enlightengan: Deep light enhancement without paired supervision.&quot; arXiv preprint arXiv:1906.06972 (2019).</p>
]]></content>
      <categories>
        <category>Low-Light Image Enhancement</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Low-Light Image Enhancement</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;3D-LaneNet End-to-End 3D Multiple Lane Detection&quot;</title>
    <url>/paper-reading-3D-LaneNet-End-to-End-3D-Multiple-Lane-Detection/</url>
    <content><![CDATA[<p>　　在上一篇 paper reading <a href="/paper-reading-Deep-Multi-Sensor-Lane-Detection/" title="Deep Multi-Sensor Lane Detection">Deep Multi-Sensor Lane Detection</a> 中，最后我提到一个思考点：借鉴 STN 的思路，用前视图直接去回归 IPM 变换需要的矩阵参数。本文<a href="#1" id="1ref"><sup>[1]</sup></a>就是采用了这种思路！ <img src="/paper-reading-3D-LaneNet-End-to-End-3D-Multiple-Lane-Detection/res.png" width="60%" height="60%" title="图 1. 方法概图"> 如图 1. 所示，车道线检测还是在俯视图下来做的，车道线输出是三维曲线，一定程度上估计出了地面高度。</p>
<h2 id="网络结构">1. 网络结构</h2>
<p><img src="/paper-reading-3D-LaneNet-End-to-End-3D-Multiple-Lane-Detection/arch.png" width="90%" height="90%" title="图 2. 网络结构"> 　　如图 2. 所示，网络有两部分组成：</p>
<ul>
<li>Image-view 通路<br>
输入为前视图图像，输出相机 pitch 角度 \(\theta\) 以及相机高度 \(H\)，这里假设相机坐标系相对地面坐标系没有 roll，yaw 偏转，由此可得到相机外参矩阵，用于 IPM 变换；</li>
<li>Top-view 通路<br>
输入为前视图某个特征层经过 Projective Transformation Layer 变换后的特征，之后的特征层叠加来自经过变换的前视图特征层，最后输出车道线检测；</li>
</ul>
<h3 id="projective-transformation-layer">1.1. Projective Transformation Layer</h3>
<p>　　<a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a> 中较详细得阐述了 IPM 原理，<a href="/paper-reading-Deep-Multi-Sensor-Lane-Detection/" title="Deep Multi-Sensor Lane Detection">Deep Multi-Sensor Lane Detection</a> 则阐述了 STN 的原理。Projective Transformation Layer 类似 STN 的结构，输入相机内外参后，沿用 STN 中的 Grid Generator 以及 Sampler 模块，Grid Generator 就是 IPM 的过程。此外，Projective Transformation Layer 还增加一个卷积层，将前视图的 C 维特征卷积为 C/2 维特征与俯视图的特征层进行叠加。<br>
　　该层不仅从前视图特征层上产生了俯视图特征，还融合了前视图与俯视图特征层，融合前视图特征有两大好处：</p>
<ul>
<li>瘦高型物体，如栅栏，行人，在俯视图下信息量很小，而前视图能有效提取丰富特征；</li>
<li>远距离时，俯视图下的信息会比较稀疏(类似点云)，而前视图信息会比较密集，能有效提取远距离下的信息特征；</li>
</ul>
<h3 id="anchor-based-lane-prediction">1.2. Anchor-Based Lane Prediction</h3>
<p><img src="/paper-reading-3D-LaneNet-End-to-End-3D-Multiple-Lane-Detection/anchor.png" width="60%" height="60%" title="图 3. Anchor-Based Lane Prediction"> 　　如图 3. 所示，作者提出了一种 Anchor-Based 车道线检测方法，其实这和目标检测中的 Anchor-Based 还是不太一样，这里的 Anchor 指的是几条线。设定 \(y\) 方向的 anchor 线段：\(\{X_A^i\} _ {i=1}^N\)，\(y\) 坐标上的预定义位置：\(\{y_j\} _ {j=1}^K\)。对于每个 anchor 线段，分类上以 \(Y_{ref}\) 为基准，输出三种类别(距离 \(Y_{ref}\) 最近的线的类型)，两种车道中心线，一种车道线，即 \(\{c_1,c_2,d\}\)；回归上每种类别都输出 2K 个 Offsets：\(\{(x_j ^ i,z_j ^ i)\} _ {j=1}^K\)，对应的第 \(i\) 个 anchor，在第 \(j\) 位置上的 3D 点表示为 \((x_j ^ i+X_A ^ i,y_j,z_j ^ i)\in\mathbb{R}^3\)。综上网络输出 \(N\times(3(2K+1))\) 维的向量，最后经过 1D NMS 处理后，每个 anchor 上的 3D 点通过样条插值出 3D 线条。</p>
<h2 id="loss">2. Loss</h2>
<p>　　训练阶段，真值如何匹配 anchor 很重要，过程如下：</p>
<ol type="1">
<li>将所有车道线以及车道中心线通过 IPM 投影到俯视图下；</li>
<li>在 \(Y_{ref}\) 位置上将每条线匹配给 \(x\) 方向距离最近的 anchor 线段；</li>
<li>对于每个 anchor 上匹配到的线，将最左边的车道线与中心线赋为 \(d,c_1\)，如果还有其它中心线，则赋为 \(c_2\)；</li>
</ol>
<p>对于没有穿过 \(Y_{ref}\) 的车道线，则予以忽略，中心线理论上都会穿过 \(Y_{ref}\)。所以理论上，本文预测的中心线是全的，而车道线会不全，前方的岔路口，一部分车道线不会被预测出来。<br>
　　Loss 项有四部分组成，分别为车道线分类，车道线锚点 Offsets 回归，相机外参 pitch 角 \(\theta\) 以及高度 \(h_{cam}\) 的回归，如下： <span class="math display">\[\begin{align}
\mathcal{L} =&amp; - \sum_{t\in\{c_1,c_2,d\}} \sum_{i=1}^N\left(\hat{p}_t^i\mathrm{log}p_t^i + \left(1-\hat{p}_t^i\right)\mathrm{log}\left(1-p_t^i\right)\right) \\
&amp;+ \sum _ {t\in\{c_1,c_2,d\}}\sum_{i=1}^N \hat{p}_t^i\left(\left\Vert x_t^i-\hat{x}_t^i\right\Vert+\left\Vert z_t^i-\hat{z}_t^i\right\Vert\right) \\
&amp;+ \left|\theta-\hat{\theta}\right| + \left|h_{cam}-\hat{h}_{cam}\right| \tag{1}
\end{align}\]</span></p>
<h2 id="参考文献">3. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Garnett, Noa, et al. &quot;3D-LaneNet: end-to-end 3D multiple lane detection.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2019.<br>
<a id="2" href="#2ref">[2]</a> <a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a><br>
<a id="3" href="#3ref">[3]</a> <a href="/paper-reading-Deep-Multi-Sensor-Lane-Detection/" title="Deep Multi-Sensor Lane Detection">Deep Multi-Sensor Lane Detection</a></p>
]]></content>
      <categories>
        <category>Lane Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Lane Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>Apply IPM in Lane Detection from BEV</title>
    <url>/lane-det-from-BEV/</url>
    <content><![CDATA[<p>　　车道线检测(Lane Detection)是 ADAS 系统中重要的功能模块，而对于 L4 自动驾驶系统来说，在不完全依赖高精度地图的情况下，车道线检测结果也是车辆运动规划的重要输入信息。由于俯视图(BEV, Bird's Eye View)下做车道线检测相比于前视图，有天然的优势，所以本文根据几篇论文(就看了两三篇)及项目经验，探讨总结俯视图下做车道线检测的流程方案，并主要介绍 IPM 逆透视变换原理，<a href="#0" id="0ref">[0]</a>为车道线检测资源集。</p>
<h2 id="流程框架">1. 流程框架</h2>
<p>　　由于激光点云的稀疏性，目前车道线检测主要还是依靠图像，激光点云数据当然可作为辅助输入。由此归纳一种可能的粒度较粗的俯视图下车道线检测的流程：</p>
<ol type="1">
<li>IPM 逆透视变换，将图像前视图变换为俯视图；</li>
<li>网络，提取特征，进行像素级别的分类或回归；</li>
<li>后处理，根据网络输出作相应后处理，网络输出可能是像素级别预测；</li>
</ol>
<p>网络相对比较成熟，后处理则在不同网络方法下复杂度差异很大，这里不做讨论。接下来主要讨论如何进行逆透视变换。</p>
<h2 id="ipm-逆透视变换">2. IPM 逆透视变换</h2>
<p>　　设变换前后图像坐标为 \((u,v)\), \((u',v')\), 对于仿射变换(Affine transformation)，变换前后保持了线的平行性，其变换矩阵 A： <span class="math display">\[\begin{bmatrix}
u&#39; \\
v&#39; \\
\end{bmatrix} = A
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} =
\begin{bmatrix}
a_{11} &amp;a_{12} &amp;a_{13} \\
a_{21} &amp;a_{22} &amp;a_{23}
\end{bmatrix}
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} \tag{1}\]</span> 对透视变换，可表示为： <span class="math display">\[\begin{bmatrix}
u&#39; \\
v&#39; \\
1 \\
\end{bmatrix} = s\cdot P
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} = \frac{1}{p_{31}u+p_{32}v+p_{33}}
\begin{bmatrix}
p_{11} &amp;p_{12} &amp;p_{13} \\
p_{21} &amp;p_{22} &amp;p_{23} \\
p_{31} &amp;p_{32} &amp;p_{33} \\
\end{bmatrix}
\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} \tag{2}\]</span></p>
<p>用于前视图到俯视图的 IPM 逆透视变换本质上还是透视变换，变换矩阵 \(P\in \mathbb{R}^{3\times3}\) 有 8 个自由度。</p>
<h3 id="ipminverse-perspective-mapping">2.1. IPM(Inverse Perspective Mapping)</h3>
<p><img src="/lane-det-from-BEV/coords.png" width="60%" height="60%" title="图 1. 坐标关系"> 　　世界(road)坐标系与相机坐标系如图 1. 所示，设 \((u',v')\) 表示图像像素坐标系下的点，\((X_w,Y_w,0)\) 表示世界坐标系下地面上的点坐标，\((u,v)\)表示俯视图像素坐标点，<strong>IPM 假设地面是平坦的</strong>。那么根据相机透视变换原理，可得： <span class="math display">\[\begin{align}
\begin{bmatrix}
u&#39; \\
v&#39; \\
1
\end{bmatrix} &amp;= K_{cam}\frac{1}{Z_{cam}}T_{world}^{cam}
\begin{bmatrix}
X \\
Y \\
Z \\
1
\end{bmatrix}_{world}\\ &amp;=
\begin{bmatrix}
f_x &amp;0 &amp;u_0 \\
0 &amp;f_y &amp;v_0\\
0 &amp;0 &amp;1
\end{bmatrix}
\frac{1}{r_{31}X+r_{32}Y+t_z}
\begin{bmatrix}
R &amp;t\\
0 &amp;1
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\
0 \\
1
\end{bmatrix}_{world}\\
&amp;= \frac{1}{r_{31}X+r_{32}Y+t_z}
\begin{bmatrix}
m_{11} &amp;m_{12} &amp;m_{13}\\
m_{21} &amp;m_{22} &amp;m_{23}\\
r_{31} &amp;r_{32} &amp;t_{z}\\
\end{bmatrix}
\begin{bmatrix}
X \\
Y \\
1 
\end{bmatrix}_{world} = \frac{Res}{Z_{cam}} P 
\begin{bmatrix}
u \\
v \\
1 
\end{bmatrix} \tag{3}
\end{align}\]</span></p>
<p>式 (3) 与式 (2) 形式一致，其中 \(P\) 为相机内参及外参，\(Res\) 为俯视图像素对物理空间尺寸的分辨率，单位为\((meter/pixel)\)。<strong>IPM 需要预先标定相机的内外参</strong>，尤其是外参 \(R\)，表示与地面平行的世界坐标系与相机成像平面的相机坐标系之间的旋转关系，一般情况下不考虑相机的横滚角以及偏航角，只考虑俯仰角。</p>
<h3 id="俯视图求解过程">2.2. 俯视图求解过程</h3>
<p>　　已知前视图，相机内外参，求解俯视图有两种思路。一种是在世界坐标系下划定感兴趣区域，另一种是在前视图图像上划定感兴趣区域。</p>
<h4 id="世界坐标系下划定感兴趣区域">2.2.1 世界坐标系下划定感兴趣区域</h4>
<p>　　这种方式很直接，假设世界坐标系下感兴趣区域是 \(x\in [X_{min},X_{max}],y\in [Y_{min},Y_{max}], z\in [Z_{min},Z_{max}]\)，设定 \(Res\)，即可生成俯视图要生成的像素图，然后通过公式 (2) 投影到前视图的亚像素上，用双线性插值获得采样值填入俯视图中即可。</p>
<h4 id="前视图图像上划定感兴趣区域">2.2.2 前视图图像上划定感兴趣区域</h4>
<p>　　基于(3)，可以求出世界坐标系下两条平行 \(z\) 轴的平行直线在图像坐标系下的交点，即<strong>消失点(Vanishing Point)</strong>。假设世界坐标系下平行 \(z\) 轴的直线表示为，点 \((x_a,x_b,x_c)\) 及方向向量 \(k(0,0,1)\)，那么可得该直线上任意一点投影到图像坐标系下表示，当 \(k\) 趋向于无穷大时，即可得到消失点坐标： <span class="math display">\[\begin{bmatrix}
u \\
v \\
1
\end{bmatrix} = \frac{1}{Z_{cam}} M 
\begin{bmatrix}
x_a \\
x_b \\
x_c + k
\end{bmatrix}_{world} = 
\begin{bmatrix}
\frac{m_{11}x_a+m_{12}x_b+m_{13}(x_c+k)}{m_{31}x_a+m_{32}x_b+m_{33}(x_c+k)} \\
\frac{m_{21}x_a+m_{22}x_b+m_{23}(x_c+k)}{m_{31}x_a+m_{32}x_b+m_{33}(x_c+k)} \\
1
\end{bmatrix} \overset{k\to\infty}{\simeq}
\begin{bmatrix}
\frac{m_{13}}{m_{33}} \\
\frac{m_{23}}{m_{33}} \\
1
\end{bmatrix}
\tag{3}
\]</span> 有了图像坐标系下的消失点坐标以后，我们就可以选定需要作透视变换的 ROI 梯形区域(逆透视变换到俯视图后，梯形变矩形)。选定梯形四个角点后，根据像素距离关系，定义俯视图下其对应的矩形框四个像素坐标点，这样能得到四组(2)方程组，足可求解自由度 8 的透视矩阵 \(P\)。OpenCV 有较成熟的函数，更详细的代码原理可见<a href="#1" id="1ref">[1]</a>。</p>
<h2 id="其它思考">3. 其它思考</h2>
<p>　　如果在俯视图下作车道线检测，IPM 是必不可少的。以上 IPM 的缺陷是有一个较强的假设：路面是平坦的。并且时间一长标定参数，尤其是外参会失效，而且距离越远，路面的不平坦导致的逆透视变换误差也会增大。但对于 ADAS 系统来说，车道偏离预警(LDW，Lane Departure Warnings) 中车道线的检测距离在 50m 已经能满足要求。如果要消除更远距离下路面不平坦所带来的影响，也是有方法可以消除的，留到日后再讨论。<br>
　　按照之前的项目经验，LDW 系统完成度可以很高，基本思路就是 IPM，parsing(segmentation)，clustering，hough，optimization 等几个步骤(这里就不能说得太细了)，更多的精力可能在指标设计及 cornercase 优化上。唯一对用户不太友好的地方就是安装时要进行相机外参(尤其是 pitch 角)的标定，当然标定方法比较简单，我们假设相机坐标系与路面平行，所以透视变换矩阵是固定的，用户只要看路面经过逆透射后，两条 \(z\) 方向的直线是否平行即可。相对于 Mobileye 这种标定巨麻烦的产品，这种标定方式算是非常友好了。此外还可以用自动外参标定方法，脑洞也可以开出很多，效果嘛看具体环境了，需要作谨慎的收敛判断。</p>
<h2 id="参考文献">4. 参考文献</h2>
<p><a id="0" href="#0ref">[0]</a> <a href="https://github.com/amusi/awesome-lane-detection" target="_blank" rel="noopener">awesome-lane-detection</a><br>
<a id="1" href="#1ref">[1]</a> <a href="https://blog.csdn.net/qq_32864683/article/details/85471800" target="_blank" rel="noopener">LDW 原理及代码</a></p>
]]></content>
      <categories>
        <category>Lane Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Lane Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Deep Multi-Sensor Lane Detection&quot;</title>
    <url>/paper-reading-Deep-Multi-Sensor-Lane-Detection/</url>
    <content><![CDATA[<p>　　前文 <a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a> 已经较详细得阐述了俯视图下作车道线检测的逆透视原理，提到传统 IPM 有个较强的假设：地面是平坦的。对于 L4 自动驾驶，在这个假设下车道线检测不管是精度还是可靠性，都远远不够。如果有高精度地图，那么这些问题都有方法来消除。当然，如果有高精度地图，且自定位准确，也就不需要车道线检测了，所以这里讨论，在无高精度地图下，本文<a href="#1" id="1ref"><sup>[1]</sup></a>如何通过激光点云数据学习的方法解决上述问题。</p>
<h2 id="网络结构">1. 网络结构</h2>
<p><img src="/paper-reading-Deep-Multi-Sensor-Lane-Detection/lane_det.png" width="90%" height="90%" title="图 1. Multi-Sensor Lane Detection"> 　　如图 1. 所示，整个算法有两个网络组成：</p>
<ul>
<li><strong>地面估计(Ground Height Estimation)网络</strong><br>
输入是俯视图下历史 N 帧的栅格点云，输出的是俯视图下地面高度；</li>
<li><strong>车道线检测(Lane Prediction)网络</strong><br>
输入是俯视图下历史 N 帧的栅格点云，并且叠加前视图图像逆透视变换到俯视图后的图像，输出为像素级别的车道线检测结果；</li>
</ul>
<p>历史 N 帧点云需要经过 ego-motion 补偿到当前本车位置，补偿后的点云只对运动物体会存在变形，而网络正好需要忽视运动物体。通过地面估计得到了俯视图下稠密的地面估计后，就可以将前视图的图像投影到俯视图下了。具体的过程为：取地面估计的三维点(高度+像素坐标经过分辨率变换后的物理坐标)，投影到图像上，然后双线性插值取得图像像素值，填充至俯视图上。这种透视变换是借助 3D 点信息完成的，原理可详见 <a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a>。</p>
<h2 id="differentiable-warping-function">2. Differentiable Warping Function</h2>
<p>　　其实这里估计出来的地面高度就是个简陋的高精度地图，所以这种方案理论上就能消除上述问题。并且，投影的过程采用了可求导的映射方程(differentiable warping function)，所以整个算法可以端到端的训练。 <img src="/paper-reading-Deep-Multi-Sensor-Lane-Detection/STN.png" width="90%" height="90%" title="图 2. Spatial Transformer Networks"> 　　关于可求导的映射方程，这里借鉴了 DeepMind 的 Spatial Transformer Networks<a href="#2" id="2ref"><sup>[2]</sup></a> 的思想。传统卷积网络只对较小的位移有位移不变性，而 STN 引入 2D/3D 仿射/透视变换，显示得将特征层变换到有利于分类的形态，这样整个网络就具有了仿射甚至透视(位移，旋转，裁剪，尺度，歪斜)不变性。如图 2. 所示，STN 有三部分构成：</p>
<ol type="1">
<li><strong>Localisation Net</strong>，对于 2D 仿射，回归预测出仿射变换矩阵 \(\theta \in \mathbb{R}_{2\times 3}\);</li>
<li><strong>Grid Generator</strong>，根据仿射变换矩阵及仿射变换前后特征图的大小，建立仿射前后坐标映射关系；</li>
<li><strong>Sampler</strong>，根据坐标映射关系设计可求导的插值采样方法(如双线性)，从输入特征中采样出特征值填入仿射后的特征图中；</li>
</ol>
<p>　　本文则是一个透视变换矩阵 \(P\)，但是 \(P\) 不需要网络预测，其完全由激光雷达与相机的内外参决定，这个需要提前标定好。预测的地面高度通过 <a href="/lane-det-from-BEV/" title="Apply IPM in Lane Detection from BEV">Apply IPM in Lane Detection from BEV</a> 中的式 (3) 即可与图像坐标系建立联系，作为 Grid Generator。最后采用可求导的 Sampler，这个模块就可以嵌入到网络中，进行端到端的训练。</p>
<h2 id="loss">3. Loss</h2>
<p>　　Loss 采用 SmoothL1 Loss，其有两种构成：</p>
<ul>
<li>地面估计项<br>
<span class="math display">\[ L_{gnd} = \sum_{p\in Output Image} \Vert z_{p,gt}-z_{p,pred}\Vert \tag{1}\]</span></li>
<li>车道线检测项<br>
<span class="math display">\[ L_{lane} = \sum_{p\in Output Image} \left\Vert \left(\tau-\mathrm{min}\{d_{p,gt}, \tau\}\right)-d_{p,pred}\right\Vert \tag{2}\]</span> 其中 \(\tau\) 是车道线真值标签的衰减像素区域，高速场景设为 30，城市道路设为 20。</li>
</ul>
<h2 id="其它思考">4. 其它思考</h2>
<p>　　既然 STN 专门是用来作仿射/透视变换的，那么是否可以在不借助激光点云的情况下，用前视图图像直接回归出透视变换到俯视图的透视矩阵 \(P\) ？理论上是可行的，但是训练过程不一定能收敛，需要精心设计训练过程，以及针对斜坡还会有一定的距离误差。</p>
<h2 id="参考文献">5. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Bai, Min, et al. &quot;Deep Multi-Sensor Lane Detection.&quot; 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2018.<br>
<a id="2" href="#2ref">[2]</a> Jaderberg, Max, Karen Simonyan, and Andrew Zisserman. &quot;Spatial transformer networks.&quot; Advances in neural information processing systems. 2015.</p>
]]></content>
      <categories>
        <category>Lane Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Lane Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Grid-GCN for Fast and Scalable Point Cloud Learning&quot;</title>
    <url>/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/</url>
    <content><![CDATA[<p>　　目前点云特征学习在学术界还处于各种探索阶段，<a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 中将点云特征提取分为三维物理空间操作以及映射空间操作两大类，其中对直接在三维空间中提取特征的操作进行了较详细的分析。由于变换到映射空间的操作会相对比较复杂，目前为了实时应用，本人还是比较倾向于直接在三维空间进行操作。<br>
　　类比图像特征提取，直接在三维空间进行点云特征提取的基本操作有：</p>
<ul>
<li><strong>局部点云特征提取</strong>：对目标点的周围点特征进行融合，从而得到该目标点特征；</li>
<li><strong>上采样/下采样</strong>：采样以扩大感受野，进一步提取局部/全局信息；</li>
</ul>
<p>　　<a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 主要描述了已知周围点位置后，局部点云特征的提取方式，考虑的是特征提取的有效性，重写该问题为：针对待提取特征的坐标点 \(\mathcal{x} _ c\)，融合其周围 \(K\) 个点的操作： <span class="math display">\[ \tilde{f_c} = \mathcal{A}\left(\{e(\mathcal{x_i,x_c},f_c, f_i)\ast \mathcal{M}(f_i)\}, i\in1,...,K \right) \tag{1}\]</span> 其中 \(f_i\) 为点 \(\mathcal{x_i}\) 的特征，\(\mathcal{M}\) 为多层感知机；\(e,\mathcal{A}\) 分别为周围点特征权重函数以及特征聚合函数，大致对应 <a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 中的 \(h_\theta\) 以及 \(\Box\)。本文则思考这两个基本操作如何计算加速以能实时应用。具体来看，耗时操作主要是：</p>
<ul>
<li>Sampling</li>
<li>Points Querying</li>
</ul>
<p>　　<a href="#1" id="1ref">[1]</a> 提出了一种基于 Voxel 的快速采样方法，并依赖 Voxel 做近似而快速的 Points Querying，以下作详细分析。</p>
<h2 id="overview">1. Overview</h2>
<p><img src="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/grid-gcn.png" width="50%" height="50%" title="图 1. Grid-GCN Model"> 　　如图 1. 所示，Grid-GCN 模型目标是提取点级别的特征，从而可以作 semantic segmentation 等任务。基本模块为 GridConv，该模块又包括数据的构建-Coverage-aware Grid Query(CAGQ)，以及图卷积-Grid Context Aggregation(GCA)。 <img src="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/feature.png" width="80%" height="80%" title="图 2. Grid Context Aggregation"> 　　GCA 操作如图 2. 所示，与 <a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 中介绍的方法都大同小异，当信息量累加到一定程度后，基本只有一两个点的 mAP 差异，这里不作展开。<br>
　　CAGQ 则包含 sampling 与 points querying 两个核心且又最耗时的操作，CAGQ 能极大提升这两个操作的速度。首先定义三维 voxel 大小 \((v_x,v_y,v_z)\)，那么对于点 \(x,y,z\)，其 voxel 索引为 \(Vid(u,v,w)=floor\left(\frac{x}{v_x},\frac{y}{v_y},\frac{z}{v_z}\right)\)，每个 voxel 限制点数量为 \(n_v\)。假设 \(O_v\) 为非空的 voxel 集合，采样 \(M\) 个 voxel \(O_c\subseteq O_v\)。对于每个 voxel \(v_i\)，定义其周围的 voxel 集合为 \(\pi(v_i)\)，该集合中的点则构成 context points。由此可知要解决的问题：</p>
<ul>
<li><strong>Sampling</strong>：采样 voxel 集合 \(O_c\subseteq O_v\)；</li>
<li><strong>Points Querying</strong>：从 Context Points 中选取 K 个点；</li>
</ul>
<h2 id="sampling">2. Sampling</h2>
<p>　　<a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 中大致阐述过几种采样方法，信息保留度较高的方法是 FPS，但是速度较慢。 <img src="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/sample2query.png" width="80%" height="80%" title="图 3. Sampling and Points Querying"> 　　如图 3. 所示，本文提出了两种基于 voxel 的采样方法:</p>
<ul>
<li><strong>Random Voxel Sampling(RVS)</strong><br>
对每个 voxel 进行随机采样，相比对每个点进行随机采样(Random Point Sampling)，RVS 有更少的信息损失，更广的空间信息覆盖率。</li>
<li><strong>Coverage-Aware Sampling(CAS)</strong><br>
在 RVS 基础上，CAS 有更广的信息覆盖率，其步骤为：
<ol type="1">
<li>随机采样 \(M\) 个 voxel，即执行 RVS；</li>
<li>对未被采样到的 voxel \(v_c\)，计算如果加入这个 voxel，空间覆盖率增益： <span class="math display">\[ H_{add} = \sum_{v\in \pi(v_c)}\delta(C_v) - \beta\frac{C_v}{\lambda} \tag{2}\]</span> 对采样集里面的 voxel \(v_i\)，计算如果去掉这个 voxel，空间覆盖率减少量： <span class="math display">\[ H_{rmv} = \sum_{v\in \pi(v_i)}\delta(C_v-1) \tag{3}\]</span></li>
<li>如果 \(H_{add} &gt; H_{rmv}\)，则进行替换；</li>
<li>迭代 2,3 步骤；</li>
</ol></li>
</ul>
<p>其中 \(\delta(x)=1,if x=0,else\,0\)。\(\lambda\) 为周围 voxel 个数，\(C_v\) 是采样集覆盖该 voxel 的个数。</p>
<h2 id="points-querying">3. Points Querying</h2>
<p>　　传统的 Points Querying 一般是在所有点中建立 KD-Tree 或 Ball Query 形式来找某点的邻近点。本文在 voxel 基础上来快速寻找邻近点，提供了两种方法：</p>
<ul>
<li><strong>Cube Query</strong><br>
这是一种近似法，直接在 Context Points 中随机采样 \(K\) 个点作为最近邻点。从物理意义上将，最近邻的区域的点特征应该都是相似的，所以这种近似法应该会很有效。</li>
<li><strong>K-Nearest Neighbors</strong><br>
在 Context Points 中寻找 K-NN，相比在全点云中找 K-NN，这种方法搜索速度会非常快。</li>
</ul>
<h2 id="experiments">4. Experiments</h2>
<p><img src="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/complexity.png" width="60%" height="60%" title="图 4. 时间复杂度"> <img src="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/time-eval.png" width="70%" height="70%" title="图 5. 空间覆盖率与耗时"> 　　如图 4. 与图 5. 所示，比较了 RPS，FPS，RVS，CAS 等采样算法的时间复杂度与空间覆盖率，以及 Ball Query，Cube Query，K-NN 等 Points Query 算法的时间复杂度。由此可见，本文提出的 Sample 及 Points Query 算法非常高效。</p>
<h2 id="reference">5. reference</h2>
<p><a id="1" href="#1ref">[1]</a> Xu, Qiangeng. &quot;Grid-GCN for Fast and Scalable Point Cloud Learning.&quot; arXiv preprint arXiv:1912.02984 (2019).</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;LaserNet&quot;</title>
    <url>/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/</url>
    <content><![CDATA[<p>　　3D 目标检测中，目标定位的不确定性也很关键，<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中已经较为详细的描述了在 Bayesian Deep Networks 中如何建模异方差偶然不确定性(Aleatoric Uncertainty)。在贝叶斯深度神经网络框架下，网络不仅预测目标的位置(Mean)，还预测出该预测位置的方差(Variance)。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 延续了 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中预测 Corner 点位置方差的思路，提出了一种预测目标位置方差的方法。</p>
<h2 id="算法框架">1. 算法框架</h2>
<p><img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/framework.png" width="90%" height="90%" title="图 1. LaserNet Framework"> 　　如图 1. 所示，输入为激光点云的 Sensor Range View 表示方式，输出为点级别的目标框3D属性，框顶点位置方差，以及类别概率。最后在 Bird View 下作目标框的聚类与 NMS 等后处理。</p>
<h3 id="点云输入方式">1.1. 点云输入方式</h3>
<p>　　不同于目前主流的 Bird View 点云栅格化方式，本文将点云直接根据线束在 Sensor Range View 下进行表示，高为激光线数量，宽为 HFOV 除以角度分辨率。设计 5 个 channel：距离，高度，角度，反射值，以及是否有点的标志位。<br>
　　本文认为这种点云表示方式的优点被忽视了，该视角下，点云的表达是紧促的，而且能高效得取得局部区域点，此外，能保留点云获取方式的信息。另一方面，该表达方式的缺点有，访问局部区域时，并不是空间一致的；以及需要处理物体的不同形状和遮挡问题。本文实验结果是，在 Kitti 上效果不如 Bird View 方法，但是在一个较大数据集上，能克服这些缺点。</p>
<h3 id="网络输出">1.2. 网络输出</h3>
<p>　　网络输出为点级别的预测，由三部分组成：</p>
<ol type="1">
<li><strong>类别概率</strong><br>
每个类别的概率；</li>
<li><strong>3D 框属性</strong><br>
包括相对中心距离 \((d _ x, d _ y)\)；相对朝向 \((\omega _ x, \omega _ y)=(\mathrm{cos}\omega, \mathrm{sin}\omega)\)；以及尺寸 \((l,w)\)。最终目标框中心点位置及朝向表示为： <span class="math display">\[\left\{\begin{array}{l}
\mathbf{b} _ c = [x,y]^T+\mathbf{R} _ \theta [d _ x,d _ y]^T \\
\varphi = \theta + \mathrm{atan2}(\omega _ y,\omega _ x)
\end{array}\tag{1}\right.\]</span> 其中 \(\theta\) 为该点的雷达扫描角度。由此可得到四个目标框角点坐标： <span class="math display">\[\left\{\begin{array}{l}
\mathbf{b} _ 1 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [l,w]^T\\
\mathbf{b} _ 2 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [l,-w]^T\\
\mathbf{b} _ 3 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [-l,-w]^T\\
\mathbf{b} _ 4 = \mathbf{b} _ c + \frac{1}{2}\mathbf{R} _ \varphi [-l,w]^T
\end{array}\tag{2}\right.\]</span></li>
<li><strong>顶点位置方差</strong><br>
当观测不完全时(遮挡，远处)，目标框的概率分布是多模态的，所以如 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 中所述，输出为混合高斯模型。对于每个点的每个类别，输出 \(K\) 个目标框属性：\(\{d _ {x,k}, d _ {y,k}, \omega _ {x,k}, \omega _ {y,k}, l _ k, w _ k\} _ {k=1}^K\)；对应的方差 \(\{s _ k\} _ {k=1}^K\)；以及模型权重 \(\{\alpha _ k\} _ {k=1}^K\)。</li>
</ol>
<h3 id="bird-view-后处理">1.3. Bird View 后处理</h3>
<p>　　网络其实就做了一个点级别的分割，接下来需要作聚类以得到目标框。本文采用 Mean-Shift 方法作聚类。由于是点级别的概率分布，得到目标点集后，需要用 BCN(详见 <a href="/MOT-Fusion/" title="MOT-Fusion">MOT-Fusion</a>) 转换为目标级别的概率分布： <span class="math display">\[\left\{\begin{array}{l}
\hat{\mathbf{b}} _ i = \frac{\sum _ {j\in S _ i} w _ j\mathbf{b} _ j}{\sum _ {j\in S _ i}w _ j}\\
\hat{\sigma} _ i^2 = \left(\sum _ {j\in S _ i}\frac{1}{\sigma ^2 _ j}\right)^{-1}
\end{array}\tag{3}\right.\]</span> 其中 \(w=\frac{1}{\sigma ^ 2}\)。</p>
<h2 id="loss-形式">2. Loss 形式</h2>
<p>　　分类采用 Focal Loss。对于每个点 3D 属性的回归，首先找到最靠近真值的预测模型： <span class="math display">\[k ^ * = \mathrm{arg}\min \limits _ k\Vert\hat{\mathbf{b}} _ k-\mathbf{b} ^{gt}\Vert\tag{4}\]</span> 对该预测模型作 Loss： <span class="math display">\[\mathcal{L} _ {box}=\sum _ n\frac{1}{\hat{\sigma} _ {k ^ * }} \left\vert\hat{\mathbf{b}} _ {n,k^ * }-\mathbf{b} _ n^{gt}\right\vert + \mathrm{log}\hat{\sigma} _ {k ^ * }\tag{5}\]</span> 实际回归的是 \(s:=\mathrm{log} \sigma\)。然后对混合模型的权重 \(\{\alpha _ k\} _ {k=1}^K\) 作 cross entry loss \(\mathcal{L} _ {mix}\)。最终的回归 Loss 为： <span class="math display">\[\mathcal{L} _ {reg} = \frac{1}{N}\sum _ i \frac{\mathcal{L} _ {box, i} + \lambda \mathcal{L} _ {mix,i}}{n _ i} \tag{6}\]</span></p>
<h2 id="adaptive-nms">3. Adaptive NMS</h2>
<p>　　类别概率不能反应目标框的质量，所以本文采用预测的目标框方差作为 NMS 的参考量。将目标框方差转换为目标框的质量分数：\(\alpha _ k/2\hat{\sigma} _ k\)。<br>
<img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/nms.png" width="50%" height="50%" title="图 2. Adaptive NMS"> 　　此外不同目标在 Bird-View 下 IoU 最大值有一定的限制，如图 2. 所示，最坏的情况，Bird-View 下两个框的 IoU 最大限制为设计为： <span class="math display">\[t=\left\{\begin{array}{l}
\frac{\sigma _ 1+\sigma _ 2}{2w-\sigma _ 1 - \sigma _ 2} &amp; \sigma _ 1+\sigma _ 2 &lt; w\\
1 &amp; otherwise
\end{array}\tag{7}\right.\]</span> 当两个目标框的 IoU 大于阈值时，可能的情况是：1. 目标框错误，则删除低分数的目标框；2. 方差估计错误，那么增大方差使最大阈值满足 IoU 条件。</p>
<h2 id="预测分布的分析">4. 预测分布的分析</h2>
<p><img src="/paper-reading-LaserNet-An-Efficient-Probabilistic-3D-Object-Detector-for-Autonomous-Driving/calibration.png" width="80%" height="80%" title="图 3. Uncertainty(Variance) Calibration"> 　　评价 Variance(Uncertainty) 预测的好坏，可以画 Calibration 图。如图 3. 所示，横坐标为预测的 Mean 与真值形成的高斯概率分布下的 CDF，而纵坐标为预测的 Variance 统计出的高斯分布下的 CDF。理想情况下，两者是 \(y=x\) 的关系，如图所示，在 ATG4D 大数据集上，预测的 Variance 效果更好。</p>
<h2 id="一些思考">5. 一些思考</h2>
<p>　　不管是 2D 检测还是 3D 检测，这种先(语义)分割后聚类出目标的思想，有很强的优势：召回率高，超参数少，自带分割信息等。本文又应用 Aleatoric Uncertainty 来建模检测的不确定性--位置方差(不确定性干嘛用，怎么用，不多说了)，有很好的借鉴意义。</p>
<h2 id="reference">6. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Meyer, Gregory P., et al. &quot;Lasernet: An efficient probabilistic 3d object detector for autonomous driving.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
        <tag>Uncertainty</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Learning to See in the Dark&quot;</title>
    <url>/paper-reading-Learning-to-See-in-the-Dark/</url>
    <content><![CDATA[<p>　　无监督低光照图像增强更有应用价值，<a href="/Unsupervised-Low-Light-Image-Enhancement/" title="Unsupervised Low Light Image Enhancement">Unsupervised Low Light Image Enhancement</a> 中介绍了几种无监督方法。本文则是有监督方法，但是值得一读。在 Sensor，曝光时间，光圈，ISO 等(在线调节通过 AE 完成)确定后，图像低光照下曝光不足主要是因为 ISP 过程对图像的亮度矫正不理想。本文直接重构 ISP 过程，对 Raw 图像进行一系列操作，以增强亮度。</p>
<h2 id="算法过程">1. 算法过程</h2>
<p><img src="/paper-reading-Learning-to-See-in-the-Dark/ISP.png" width="90%" height="90%" title="图 1. Raw Image Processing Pipeline 对比"> 　　如图 1. 所示，传统 ISP 过程包括：White Balance, Demosaic, Denoise/Sharpen, Color Space Conversion, Gamma Correction(与亮度变化相关)等。L3 与 Burst 是其它 ISP pipeline 学习的方法，本文网络算法过程如图 1.b 所示，首先提取 RGB sensor 值并放大一定比例(该放大系数用来控制最终增强的曝光级别)，然后经过网络层，最终输出全尺寸的 RGB 图像。<br>
　　训练数据采集自室内静态场景，每对数据由短曝光的低光照图像与长曝光的标签图像构成，由此可进行有监督训练。</p>
<h2 id="reference">2. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Chen, Chen, et al. &quot;Learning to see in the dark.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.</p>
]]></content>
      <categories>
        <category>Low-Light Image Enhancement</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Low-Light Image Enhancement</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;PolarNet&quot;</title>
    <url>/paper-reading-PolarNet/</url>
    <content><![CDATA[<p>　　Point-wise 特征提取在 <a href="/PointCloud-Feature-Extraction/" title="PointCloud-Feature-Extraction">PointCloud-Feature-Extraction</a> 中已经有较为详细的描述，虽然 Point-wise 提取的特征更加精细，但是一般都有 KNN 构建及索引操作，计算量较大，而且实践中发现学习收敛较慢。Voxel-based 虽然理论上损失了一定的信息，但是能直接应用 2D 卷积网络，网络学习效率很高。本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种在极坐标下栅格化后进行点云 Semantic Segmentation 的方法，相比传统的笛卡尔坐标系下栅格化有一定的优势。</p>
<h2 id="voxelization">1. Voxelization</h2>
<p><img src="/paper-reading-PolarNet/pts.png" width="98%" height="98%" title="图 1. Cartesian VS. Polar"> 　　如图 1. 所示，传统的笛卡尔坐标系下栅格化的栅格是矩形，而极坐标系下栅格是饼状的。激光雷达是在极坐标方式下获取点云的，所以由图可知，<strong>极坐标栅格化下，每个栅格拥有的点数更加均匀</strong>，有利于网络学习并减少计算量。此外，本文统计后显示，相比笛卡尔坐标栅格，极坐标的栅格内点属于同一目标的概率更大。</p>
<h2 id="polarnet-framework">2. PolarNet Framework</h2>
<p><img src="/paper-reading-PolarNet/framework.png" width="98%" height="98%" title="图 2. PolarNet"> 　　如图 2. 所示，点云经过 Polar 栅格化后，对每个栅格首先进行 PointNet 特征提取，然后对所有栅格作 ring-convolution 操作。<br>
　　ring-convolution 是指卷积在环形方向进行，没有边缘截断效应。实现上，将栅格从某处展开，然后边缘处用另一边对应的栅格进行 padding，即可用普通的卷积进行运算。<br>
　　网络是作 Voxel-wise 的分割，然后直接将预测的类别应用到栅格内的点云中。统计上，同一栅格内的点云属于不同类别的概率很低，所以本文并没进一步作 Point-wise 的分割。</p>
<h2 id="rethinking">3. Rethinking</h2>
<p>　　PolarNet 作 Semantic Segmentation 比其它方法提升很多。但是实际应用时，PolarNet 不能指定各个方向的范围，所以计算效率较低。比如，自动驾驶中，我们可以设定前 100m，后 60m，左右各 30m 的检测范围，笛卡尔坐标系下很容易进行栅格化，而极坐标下则没法搞。所以为了解决点云的分布不均匀问题，另一种思路是在笛卡尔坐标系下，近处打高分辨率的栅格，远处打低分辨率的栅格。具体实现，可以先用低分辨率过一遍网络，然后再对感兴趣的特定区域作高分辨率检测。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Zhang, Yang, et al. &quot;PolarNet: An Improved Grid Representation for Online LiDAR Point Clouds Semantic Segmentation.&quot; arXiv preprint arXiv:2003.14032 (2020).</p>
]]></content>
      <categories>
        <category>Semantic Segmentation</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
        <tag>Segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Probabilistic 3D Multi-Object Tracking for Autonomous Driving&quot;</title>
    <url>/paper-reading-Probabilistic-3D-Multi-Object-Tracking-for-Autonomous-Driving/</url>
    <content><![CDATA[<p>　　<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中已经较详细得阐述了 3D MOT 状态估计过程，文章末提到观测过程的协方差矩阵初始化问题可以用观测的不确定性解决，<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 就是通过贝叶斯深度神经网络来建模该不确定性。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提供了另一种简化的观测不确定性计算方法，同时估计运动模型与观测模型的不确定性，即过程噪声与测量噪声。</p>
<h2 id="kalman-filter">1. Kalman Filter</h2>
<p><img src="/paper-reading-Probabilistic-3D-Multi-Object-Tracking-for-Autonomous-Driving/framework.png" width="80%" height="80%" title="图 1. MOT Framework"> 　　如图 1. 所示，本文采用的卡尔曼滤波框架与传统的一样，分为预测与更新。预测阶段，根据上一时刻结果通过 Motion Model(Process Model) 预测当前时刻的状态(先验)；数据关联阶段，将预测的状态与观测的状态作目标数据关联，出 ID；更新阶段，融合预测与观测的状态，得到状态的后验估计。</p>
<h3 id="predict-step">1.1. Predict Step</h3>
<p>　　本文采用 CTRV(Constant Turn Rate and Velocity) 运动模型。不同与<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>中描述的 CTRV，本文作了<strong>线性简化</strong>，其运动方程为： <span class="math display">\[\begin{align}
&amp;\begin{bmatrix}
\hat{x}\\
\hat{y}\\
\hat{z}\\
\hat{a}\\
\hat{l}\\
\hat{w}\\
\hat{h}\\
\hat{d} _ x\\
\hat{d} _ y\\
\hat{d} _ z\\
\hat{d} _ a\\
\end{bmatrix} _ {t+1}=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0\\
0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\
0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
z\\
a\\
l\\
w\\
h\\
d _ x\\
d _ y\\
d _ z\\
d _ a\\
\end{bmatrix} _ {t}  +
\begin{bmatrix}
q _ x\\
q _ y\\
q _ z\\
q _ a\\
0\\
0\\
0\\
q _ {d _ x}\\
q _ {d _ y}\\
q _ {d _ z}\\
q _ {d _ a}\\
\end{bmatrix} _ {t}\\
\Longleftrightarrow &amp; \\
&amp;\hat{\mu} _ {t+1} = \mathbf{A}\mu _ t \\
\end{align}\tag{1}
\]</span> 其中未知的线加速度与角加速度 \((q _ x, q _ y, q _ z, q _ a)\)，\((q _ {d _ x},q _ {d _ y},q _ {d _ z},q _ {d _ a})\) 符合\((0,\mathbf{Q})\)高斯分布。<br>
　　根据 Motion Model，卡尔曼的预测过程计算状态量的先验： <span class="math display">\[\begin{align}
\hat{\mu} _ {t+1} &amp;= \mathbf{A}\mu _ t \\
\hat{\Sigma} _ {t+1} &amp;= \mathbf{A}\Sigma _ t\mathbf{A}^T + \mathbf{Q}\\
\end{align}\tag{2}\]</span> 　　观测模型为每一时刻检测的结果，包括位置，朝向，目标框尺寸，即观测矩阵 \(\mathbf{H} _ {7\times 11} = [\mathbf{I}, \mathbf{0}]\)。观测噪声也符合高斯分布，由此得到预测的观测量： <span class="math display">\[\begin{align}
\hat{o} _ {t+1} &amp;= \mathbf{H}\hat{\mu} _ {t+1} \\
\mathbf{S} _ {t+1} &amp;= \mathbf{H}\hat{\Sigma} _ {t+1}\mathbf{H}^T + \mathbf{R}\\
\end{align}\tag{3}\]</span></p>
<h3 id="update-step">1.2. Update Step</h3>
<p>　　首先将预测的观测量与实际的观测量作数据关联。基本思想是将预测目标与观测目标作 Cost Matrix，然后用匈牙利/贪心算法求解最优匹配对。本文采用 Mahalanobis distance： <span class="math display">\[ m = \sqrt{(o _ {t+1}- \mathbf{H}\hat{\mu} _ {t+1})^T\mathbf{S} _ {t+1} ^{-1}(o _ {t+1}-\mathbf{H}\hat{\mu} _ {t+1})} \tag{4}\]</span> 需要注意的是，计算距离前先做角度矫正，如果两个目标框角度相差大于 90 度，那么作 180 度旋转。<br>
　　得到预测与观测的匹配对后，计算后验概率更新该目标的状态： <span class="math display">\[\begin{align}
\mathbf{K} _ {t+1} &amp;= \hat{\Sigma} _ {t+1}\mathbf{H} ^T\mathbf{S} _ {t+1}^{-1}\\
\mu _ {t+1} &amp;= \hat{\mu} _ {t+1} + \mathbf{K} _ {t+1}(o _ {t+1}-\mathbf{H}\hat{\mu} _ {t+1})\\
\Sigma _ {t+1} &amp;=(\mathbf{I}-\mathbf{K} _ {t+1}\mathbf{H})\hat{\Sigma} _ {t+1}\\
\end{align}\tag{5}\]</span> 　　以上卡尔曼过程与<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>，以及<a href="/卡尔曼滤波详解/" title="卡尔曼滤波详解">卡尔曼滤波详解</a>完全一致。</p>
<h2 id="covariance-matrices-estimation">2. Covariance Matrices Estimation</h2>
<p>　　如何确定卡尔曼滤波过程中的 \(\Sigma _ 0, \mathbf{Q, R}\)？传统方法是直接用一个确定的经验矩阵赋值；理想的是用<a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 建模处理，但是会相对较复杂；本文用更简单的基于统计方法来确定协方差矩阵。<br>
　　<strong>观测量的方差(不确定性)与目标的属性有关</strong>，如距离，遮挡，类别等。本文没有区分这些属性，只统计了一种观测量的方差，<strong>更好的处理方式是按照不同属性，统计不同的方差</strong>。而 <a href="/Heteroscedastic-Aleatoric-Uncertainty/" title="Heteroscedastic Aleatoric Uncertainty">Heteroscedastic Aleatoric Uncertainty</a> 是 Instance 级别的方差预测。<strong>这种统计出来的方差虽然细粒度差一点，但是非常合理，因为只要模型训练好后，模型预测的分布是与训练集分布相似的(理想情况)</strong>，所以用训练集的方差来直接代替模型预测的方差也较为合理。<br>
　　<span style="color:red"><strong>更准确的来说，不确定性与物体的属性以及标注误差有关，这里只统计了标注误差(标注误差在大多数情况下都是同分布的)，而实际上遮挡大的目标，是更难学习的(目标学习有难易之分，即预测分布与训练集分布会有偏差)，即预测结果会有额外量的不确定性，所以这种离线统计方法也有很大的局限性</strong>。</span><br>
　　设训练集的真值标签：\(\left\{\left\{x _ t^m, y _ t^m, z _ t^m, a _ t^m\right\} _ {m=1}^M\right\} _ {t = 1}^T\)。</p>
<h2 id="motionprocess-noise-model">2.1. Motion/Process Noise Model</h2>
<p>　　假设各状态量的噪声独立同分布，那么对于位置与朝向噪声，有： <span class="math display">\[\begin{align}
Q _ {xx} &amp;= \mathbf{Var}\left(\left(x _ {t+1}^m-x _ t^m\right)-\left(x _ t^m-x _ {t-1}^m\right)\right)\\
Q _ {yy} &amp;= \mathbf{Var}\left(\left(y _ {t+1}^m-y _ t^m\right)-\left(y _ t^m-y _ {t-1}^m\right)\right)\\
Q _ {zz} &amp;= \mathbf{Var}\left(\left(z _ {t+1}^m-z _ t^m\right)-\left(z _ t^m-z _ {t-1}^m\right)\right)\\
Q _ {aa} &amp;= \mathbf{Var}\left(\left(a _ {t+1}^m-a _ t^m\right)-\left(a _ t^m-a _ {t-1}^m\right)\right)\\
\end{align}\tag{6}\]</span> 　　对于线速度与角速度，因为： <span class="math display">\[\begin{align}
q _ {x _ t} &amp;\approx x _ {x+1} - x _ t - d _ {x _ t}\\
&amp; \approx (x _ {t+1}-x _ t) - (x _ t-x _ {t-1})\\
q _ {d _ {x _ t}} &amp;\approx d _ {x _ {t+1}} - d _ {x _ t}\\
&amp; \approx (x _ {t+1}-x _ t) - (x _ t-x _ {t-1})\\
\end{align}\tag{7}\]</span> 所以： <span class="math display">\[ (Q _ {d _ xd _ x}, Q _ {d _ yd _ y}, Q _ {d _ zd _ z}, Q _ {d _ ad _ a}) = (Q _ {xx}, Q _ {yy}, Q _ {zz}, Q _ {aa})\tag{8}\]</span></p>
<h2 id="observation-noise-model">2.2. Observation Noise Model</h2>
<p>　　在训练集上，找到检测与真值的匹配对 \(\left\{\left\{(D _ t^k, G _ t^k)\right\} _ {k=1}^K\right\} _ {t=1}^T\)，从而计算观测噪声： <span class="math display">\[\begin{align}
&amp;R _ {xx} = \mathbf{Var}\left(D _ {x _ t}^k-G _ {x _ t}^k\right)\\
&amp;R _ {yy} = \mathbf{Var}\left(D _ {y _ t}^k-G _ {y _ t}^k\right)\\
&amp;R _ {zz} = \mathbf{Var}\left(D _ {z _ t}^k-G _ {z _ t}^k\right)\\
&amp;R _ {aa} = \mathbf{Var}\left(D _ {a _ t}^k-G _ {a _ t}^k\right)\\
&amp;R _ {ll} = \mathbf{Var}\left(D _ {l _ t}^k-G _ {l _ t}^k\right)\\
&amp;R _ {ww} = \mathbf{Var}\left(D _ {w _ t}^k-G _ {w _ t}^k\right)\\
&amp;R _ {hh} = \mathbf{Var}\left(D _ {h _ t}^k-G _ {h _ t}^k\right)\\
\end{align}\tag{8}\]</span> 初始的状态协方差 \(\Sigma _ 0 = \mathbf{R}\)。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Chiu, Hsu-kuang, et al. &quot;Probabilistic 3D Multi-Object Tracking for Autonomous Driving.&quot; arXiv preprint arXiv:2001.05673 (2020).</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
        <tag>Uncertainty</tag>
        <tag>MOT</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Reconfigurable Voxels, A New Representation for LiDAR-Based Point Clouds&quot;</title>
    <url>/paper-reading-Reconfigurable-Voxels/</url>
    <content><![CDATA[<p>　　Voxel-based 点云特征提取虽然损失了一定的信息，但是计算高效。Voxel-based 方法一个比较大的问题是，由于<strong>点云分布的不均匀性</strong>，作卷积时会导致可能计算的区域没有点，从而不能有效提取局部信息。为了解决栅格化后栅格中点云分布的不均匀问题，目前看到的有以下几种方法：</p>
<ol type="1">
<li>Deformable Convolution，采用可变形卷积方法，自动学习卷积核的连接范围，理论上应该能更有效得使卷积核连接到点密度较高的栅格；</li>
<li><a href="/paper-reading-PolarNet/" title="PolarNet">PolarNet</a>
提出了一种极坐标栅格化方式，因为点云获取的特性，这种方法获得的栅格中点数较为均匀;</li>
<li>手动设计不同分辨率的栅格，作特征提取，然后融合。比如近处分辨率较高，远处较低的方式；</li>
<li>本文<a href="#1" id="1ref"><sup>[1]</sup></a> 提出了一种自动选择栅格领域及分辨率，从而最大化卷积区域点数的方法；</li>
</ol>
<p><img src="/paper-reading-Reconfigurable-Voxels/reconfig.png" width="80%" height="80%" title="图 1. Reconfig Voxels"> 　　如图 1. 所示，本文提出的 Reconfigurable Voxel 方法，能自动选择领域内点数较多的栅格特征提取，进而作卷积运算，避免点数较少，从而信息量较少的栅格作特征提取操作；此外还可根据点数自动调整分辨率以获得合适的栅格点数。通过这种方法，每个栅格输入到网络前都能有效提取周围点数较多区域的特征信息。</p>
<h2 id="framework">1. Framework</h2>
<p><img src="/paper-reading-Reconfigurable-Voxels/pipeline.png" width="80%" height="80%" title="图 2. Framework"> 　　如图 2. 所示，本文以检测任务为例，分三部分：Voxel/Pillar Feature Extraction，Backbone，RPN/Detection Head。后两个采用传统的方法，本文主要是改进 Voxel/Pillar Feature Extraction，这是输入到网络前的特征提取阶段。</p>
<h2 id="voxelpillar-feature-extraction">2. Voxel/Pillar Feature Extraction</h2>
<p>　　传统的输入到 2D 卷积网络的特征要么是手工提取的，要么是用 <a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a> 网络去学习每个 Voxel 的特征。由此输入到网络的特征不是最优的，因为点云的稀疏性会导致后面的 2D 卷积网络作特征提取时遇到很多“空”的 Voxel。本文提出的方法就能显式得搜索每个 Voxel 周围有点的区域作特征提取，使得之后 2D 卷积特征提取更加有效。其步骤为：</p>
<ul>
<li>点云栅格化，并存储每个 Voxel 周围 Voxel 的索引；</li>
<li>每个 Voxel 周围 Voxel 作 Biased Random Walk，去搜索有更稠密点云的 Voxel；</li>
<li>将每个 Voxel 与新搜索到的周围 Voxel 作特征提取与融合，得到该 Voxel 特征；</li>
</ul>
<h3 id="biased-random-walking-neighbors">2.1. Biased Random Walking Neighbors</h3>
<p>　　邻域 Voxel 搜索目标是：<strong>在距离较近的情况下寻找较稠密的 Voxel</strong>。由此设计几种策略：</p>
<ul>
<li>点数越少的 Voxel，有更高概率作 Random Walk，以及更多 Step 去周围相邻的 Voxel；</li>
<li>点数越多的 Voxel，有更高概率被其它 Voxel Random Walk 到；</li>
</ul>
<p>　　将以上策略数学化。设第 \(j\) 个 Voxel 有 \(N(j)\) 个点，最大点数为 \(n\)，其作 Random Walk 的概率为 \(P _ w(j)\)，步数 Step 为 \(S(j)\)，第 \(i\) 步到达的 Voxel 为 \(w _ j(i)\)，其四领域 Voxel 集合为 \(V(w _ j(i))\)，从该 Voxel 走到下一个 Voxel 的概率为 \(P(w _ j(i+1)|w _ j(i))\)。由此得到以上策略的数学描述： <span class="math display">\[P _ w(j)=\frac{1}{N(j)} \tag{1}\]</span> <span class="math display">\[S(j)=n-N(j)\tag{2}\]</span> <span class="math display">\[P\left(w _ j(i+1)|w _ j(i)\right) = \frac{N\left(w _ j(i+1)\right)}{\sum _ {v\in V(w _ j(i))}N(v)}\tag{3}\]</span> 需要注意的是，\(S(j)\) 是在开始时计算的，此后每走一步就减1。 <img src="/paper-reading-Reconfigurable-Voxels/random_walk.png" width="90%" height="90%" title="图 3. Random walk"> 　　如图 3. 所示，左边为单分辨率下 Voxel 搜索过程。</p>
<h3 id="reconfigurable-voxels-encoder">2.2. Reconfigurable Voxels Encoder</h3>
<p>　　每个 Voxel \(v _ i\) 搜索到最优的 4 领域 Voxel 集 \(V(v _ i)\) 后，需要融合得到该 Voxel 的特征： <span class="math display">\[\begin{align}
F(v _ i) &amp;= \psi\left(f _ {v _ i}, f _ {V(v _ i)}\right)\\
&amp;= \varphi _ 1\left[\varphi _ 2(f _ {v _ i}), \varphi _ 2\left(\sum _ {j=1}^4 W _ j(f _ {v _ i})f _ {V _ {j(v _ i)}}\right)\right] _ f
\tag{4}\end{align}\]</span> 其中 \(\varphi _ 1\) 为 low-level 操作，如 average pooling，\(\varphi _ 2\) 为 high-level 操作，如 MLP。</p>
<h3 id="multi-resolution-reconfigurable-voxels">2.3. Multi-resolution Reconfigurable Voxels</h3>
<p>　　图 3. 左边是单分辨率情况，Random Walking 可以拓展到多分辨率情形。当点云非常稀疏的时候，就很有必要降低栅格的分辨率。如图 3. 所示，\(P _ w\) 计算时除以 4，以维持与高分辨率的一致性；高分辨率到低分辨率搜索概率为 \(0.25P _ w\)，低分辨率到高分辨率搜索概率为 \(0.5P _ w\)。其余准则与单分辨率一致。实验结果表面多分辨率有一定提升，但是相比单分辨率提升不明显。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Wang, Tai, Xinge Zhu, and Dahua Lin. &quot;Reconfigurable Voxels: A New Representation for LiDAR-Based Point Clouds.&quot; arXiv preprint arXiv:2004.02724 (2020).</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;RandLA-Net&quot;</title>
    <url>/paper-reading-RandLA-Net/</url>
    <content><![CDATA[<p>　　不同与点云 3D 检测，可以 Voxel 化牺牲一定的分辨率，点云语义分割则要求点级别的分辨率，所以栅格化做点云分割信息会有一定的损失。但是直接对所有点进行特征提取，计算量又相当巨大，为了平衡效率与性能，一般也不得不对点云进行采样处理。这种点云级别的处理方式有 <a href="/PointNet-系列论文详读/" title="PointNet++">PointNet++</a>， <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 等。 <img src="/paper-reading-RandLA-Net/arch2.png" width="90%" height="90%" title="图 1. RandLA-Net"> 　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出的方法主要为了解决大尺度点云集下，如何高效提取点云局部特征的问题。针对大尺度点云集，作者对比了不同采样算法，得出随机采样最简单高效的结论；针对随机采样丟失信息的问题，以及为了提高局部特征提取能力，本文提出了局部特征聚合(Local Feature Aggregation)模块，该模块包含 Local Spatial Encoding，Attentive Pooling，以及 Dilated Residual Block。<br>
　　如图 1. 所示，LFA 作为基本模块用于特征提取，下采样采用随机采用，上采样过程类似图像中的 dconv，包含向上插值以及 MLP 过程。</p>
<h2 id="sampling">1. Sampling</h2>
<p>　　关于点云采样，在 <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 中有简单介绍。本文将采样算法分为两大类：</p>
<ul>
<li>Heuristic Sampling
<ol type="1">
<li>Farthest Point Sampling(FPS)， <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a> 中有介绍，是一种均匀采样方法。其算法复杂度为 \(\mathcal{O}(N^2)\)。</li>
<li>Inverse Density Importance Sampling(IDIS)，计算每个点的密度属性，根据属性选取 K 个点，其复杂度为 \(\mathcal{O}(N)\)。</li>
<li>Random Sampling(RS)，随机采样，复杂度为 \(\mathcal{O}(1)\)。</li>
</ol></li>
<li>Learning-based Sampling<br>
...</li>
</ul>
<p>　　本文作者认为随机采样复杂度最低，其它采样复杂度太高。我认为也不能这么说，在一定策略及加速下，其它采样算法效率也可以很高。比如栅格化后在采样，可以高效的并行加速，并且使得稀疏区域保留更多信息。</p>
<h2 id="local-feature-aggregation">2. Local Feature Aggregation</h2>
<p><img src="/paper-reading-RandLA-Net/arch1.png" width="90%" height="90%" title="图 2. RandLA-Net"> 　　特征提取非常关键，尤其在本文采用随机采样后，稀疏区域信息丢失比较严重的情况下。如图 2. 所示，本文提出了局部特征聚合(Local Feature Aggregation)模块，包含 Local Spatial Encoding，Attentive Pooling，以及 Dilated Residual Block。</p>
<h3 id="local-spatial-encoding">2.1. Local Spatial Encoding</h3>
<p>　　在原始点云中提取每个点的局部特征，类似 <a href="/paperreading-FlowNet3D/" title="FlowNet3D">FlowNet3D</a>(PointNet++) 中的 set conv 层，这里多了手工特征信息，其步骤为：</p>
<ol type="1">
<li>针对每个点 \(p_i\)，用 KNN 找到与其最近的 K 个点: \(\{p _ i^1,...p _ i^k,...p _ i^K\}\)；</li>
<li>针对最近邻的每个点 \(p_i^k\)，设计其相对位置的特征： <span class="math display">\[ \mathrm{r}_i^k = \mathrm{MLP}\left(p_i\oplus p_i^k\oplus (p_i-p_i^k)\oplus ||p_i-p_i^k||\right) \tag{1}\]</span></li>
<li>针对最近领的每个点 \(p_i^k\)，其本来的特征为 \(\mathrm{f}_i^k\)，叠加相对位置特征 \(\mathrm{r}_i^k\) 后得到每个点的特征为 \(\mathrm{\hat{f}}_i^k\)。由此最近领点集的特征为： \(\mathrm{\hat{F}}_i=\{\hat{\mathrm{f}}_i^1,...\hat{\mathrm{f}}_i^k,...\hat{\mathrm{f}}_i^K\}\)。</li>
</ol>
<h3 id="attentive-pooling">2.2. Attentive Pooling</h3>
<p>　　该模块的作用是聚合 \(p_i\) 的最近邻点集特征 \(\hat{\mathrm{F}}_i\)。PointNet 的 SA 层(FlowNet3D 中的 set conv 层)直接用 Max/Mean 这种对称函数聚合，本文采用一种更有效的基于注意力机制的 pooling 方式，其步骤为：</p>
<ol type="1">
<li>计算注意力分数，对每个特征设计分数计算方式为： <span class="math display">\[ \mathrm{s}_i^k = \mathrm{g}\left(\hat{\mathrm{f}}_i^k, W\right) \tag{2}\]</span> 其中 \(\mathrm{g}\) 表示一个感知机 MLP(W 为其权重) 以及一个 softmax 函数。</li>
<li>聚合，根据注意力分数，权重求和，得到 \(p_i\) 点的特征： <span class="math display">\[ \bar{\mathrm{f}}_i = \sum_{k=1}^K \left(\hat{\mathrm{f}}_i^k \cdot \mathrm{s}_i^k \right) \tag{3}\]</span></li>
</ol>
<h3 id="dilated-residual-block">2.3.  Dilated Residual Block</h3>
<p><img src="/paper-reading-RandLA-Net/LA.png" width="60%" height="60%" title="图 3. LA Module"> 　　如图 2. 及 3. 所示，连续堆叠多个 LA 模块，能起到增加感受野的效果，然后引入 residual 思想，图 2. 下图就构成了一个 LFA 的基础模块。</p>
<p><a id="1" href="#1ref">[1]</a> Hu, Qingyong, et al. &quot;RandLA-Net: Efficient Semantic Segmentation of Large-Scale Point Clouds.&quot; arXiv preprint arXiv:1911.11236 (2019).</p>
]]></content>
      <categories>
        <category>Semantic Segmentation</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
        <tag>Segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>The Normal Distributions Transform for Laser Scan Matching</title>
    <url>/paper-reading-The-Normal-Distributions-Transform/</url>
    <content><![CDATA[<p>　　机器人系统中，定位是非常重要的模块。基于 SLAM/VO/VIO 技术的算法能实时作机器人的自定位，但是这种开环下的里程计方案很容易累积绝对误差，使得定位漂移。而离线建立的地图因为有闭环检测，精度很高，所以基于地图的定位方法有很高的绝对定位精度。<br>
　　<a href="/LOAM/" title="LOAM">LOAM</a> 是一种基于点云的实时建图与定位方法，其中当前帧点云与前序建立的地图点云配准的方法，采用了提取线、面特征并建立点-线，点-面特征匹配误差函数，从而最小二乘非线性优化求解位姿。这种方案如果特征点噪声较大无匹配对，那么就会有较大的误差。本文<a href="#1" id="1ref"><sup>[1]</sup></a> 将地图点云栅格化，每个栅格又统计点云的高斯分布，匹配的时候计算该帧点云在每个栅格的概率，从而迭代至最优匹配位姿。<br>
　　<strong>有闭环检测</strong>的 SLAM 建立的地图即可作为离线定位地图，定位的过程就是当前时刻点云与地图配准的过程，当然后续可以融合其它传感器(GPS，IMU)输出最终的绝对位姿。<strong>点云与地图配准的过程与建图时点云与局部地图或上一时刻点云配准的过程非常相似</strong>。本文介绍一种区别于 <a href="/LOAM/" title="LOAM">LOAM</a> 特征匹配的基于概率统计优化的 NDT 配准方法。</p>
<h2 id="点云配准算法过程">1. 点云配准算法过程</h2>
<p>　　考虑二维情况，本文点云配准算法过程为：</p>
<ol type="1">
<li>建立 \(t-1\) 帧点云的 NDT；</li>
<li>初始化待优化的相对位姿参数 \(T\);</li>
<li>用 \(T\) 将 \(t\) 帧点云变换到 \(t-1\) 坐标系；</li>
<li>找到变换每个变换点对应的 \(t-1\) 帧栅格的高斯分布；</li>
<li>该变换 \(T\) 的度量分数为变换点在高斯分布下的概率和；</li>
<li>用 Newton 法迭代优化 \(T\);</li>
<li>重复 3. 直到收敛；</li>
</ol>
<p>　　这里主要涉及 NDT，目标函数构建(即 \(T\) 的度量分数)，Newton 法优化三个内容。</p>
<h3 id="ndt">1.1. NDT</h3>
<p>　　NDT 是点云栅格化后一系列高斯分布的表示，其过程为：</p>
<ol type="1">
<li>将点云进行栅格化；</li>
<li>统计每个栅格的点 \(\mathbf{x} _ {i=1..n}\)；</li>
<li>计算每个栅格高斯分布的 Mean: \(\mathbf{q} = \frac{1}{n}\sum _ i\mathbf{x} _ i\);</li>
<li>计算 Covariance Matrix: \(\Sigma = \frac{1}{n}\sum _ i(\mathbf{x} _ i -\mathbf{q})(\mathbf{x} _ i-\mathbf{q})^t\)；</li>
</ol>
<p>　　由此，<strong>NDT 描述了栅格内每个位置出现点的概率</strong>，即 \(\mathbf{x}\) 有点的概率为： <span class="math display">\[ p(\mathbf{x}) \sim \mathrm{exp}\left(-\frac{(\mathbf{x-q})^t\sum ^ {-1}(\mathbf{x-q})}{2}\right) \tag{1}\]</span> 需要注意的是 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 描述的是每个栅格有点的概率，NDT 描述的是每个栅格点云的概率分布。为了更准确的建模，采用重叠栅格化的设计以消除离散化的影响，以及限定 Covariance 矩阵的最小奇异值。</p>
<h3 id="目标函数构建">1.2. 目标函数构建</h3>
<p>　　考虑二维情况，需要优化的位姿参数为 \(\mathbf{p}=(t _ x, t _ y, \varphi)^t\)，第2个点云(待配准点云)中的点为 \(\mathbf{x} _ i\)，其变换到第1个点云坐标系后的表示为 \(\mathbf{x}' _ i\)，对应的第1个点云栅格的 NDT 表示为 \(\mathbf{\Sigma} _ i, \mathbf{q} _ i\)。由此可计算该变换位姿下，其度量分数为： <span class="math display">\[\mathrm{score}(\mathbf{p})=\sum _ i\mathrm{exp}\left(-\frac{(\mathbf{x}&#39; _ i-\mathbf{q} _ i)^t\sum _ i ^ {-1}(\mathbf{x}&#39; _ i-\mathbf{q} _ i)}{2}\right) \tag{2}\]</span> 最大化度量函数即可求解最优的位姿，优化过程一般都是最小化目标函数，所以设定目标函数为 \(-\mathrm{score}\)。</p>
<h3 id="newton-法优化迭代">1.3. Newton 法优化迭代</h3>
<p>　　设 \(\mathbf{q}=\mathbf{x}' _ i-\mathbf{q} _ i\)，那么目标函数为： <span class="math display">\[ s = -\mathrm{exp}\frac{-\mathbf{q^t\sum ^ {-1}q}}{2} \tag{3}\]</span> 每次迭代过程为： <span class="math display">\[\mathbf{p\gets p+\Delta p} \tag{4}\]</span> 而 \(\mathbf{\Delta p}\) 来自： <span class="math display">\[\mathbf{H\Delta p} = \mathbf{-g} \tag{5}\]</span> 其中 \(\mathbf{g}\) 是目标函数对优化参数的导数，\(\mathbf{H}\) 为目标函数的 Hessian 矩阵： <span class="math display">\[\left\{\begin{array}{l}
g _ i=\frac{\partial s}{\partial p _ i}\\
H _ {ij} = \frac{\partial s}{\partial p _ i\partial p _ j}
\end{array}\tag{6}\right.\]</span></p>
<h2 id="建图与定位">2. 建图与定位</h2>
<p>　　本文的建图是通过<strong>关键帧集合与关键帧之间的位姿变化实现的</strong>，定位的时候去找重合度最高的关键帧作点云配准。此外，当找不到重合度较高的关键帧时，可以实时更新当前帧作为关键帧添加到地图中，还可以对地图作进一步的全局，半全局优化。</p>
<h2 id="一些思考">3. 一些思考</h2>
<p>　　本文建图是关键帧的形式，更鲁棒的做法是将点云配准到一起，在世界坐标系下获得场景的稠密点云，然后再 NDT 化，这样能更准确的建模点云分布。<br>
　　<a href="/LOAM/" title="LOAM">LOAM</a> 维护的是栅格化的地图，每个栅格限制特征点的数量，所以本质上存储的是原始点云图(被选出是特征点的点云)。为了更好的描述栅格内的特征分布，可以对其作类似 NDT 近似，同时加入能描述该分布的特征，比如对于面特征，加入法向量。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Biber, Peter &amp; Straßer, Wolfgang. (2003). The Normal Distributions Transform: A New Approach to Laser Scan Matching. IEEE International Conference on Intelligent Robots and Systems. 3. 2743 - 2748 vol.3. 10.1109/IROS.2003.1249285.</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>SLAM</tag>
        <tag>Localization</tag>
      </tags>
  </entry>
  <entry>
    <title>ADH(Annealed Dynamic Histograms) Tracker</title>
    <url>/ADH-Tracker/</url>
    <content><![CDATA[<p>　　<a href="/卡尔曼滤波详解/" title="卡尔曼滤波详解">卡尔曼滤波详解</a>中详细推导了卡尔曼滤波及其扩展卡尔曼滤波基于贝叶斯的推导过程。由贝叶斯法则式(7)，<strong>状态估计问题可定义为：已知似然及先验概率，最大化后验概率的过程</strong>。其中先验即为“运动学模型(motion model)”，似然即为“观测”，后验概率即为待估计的状态量。对于卡尔曼滤波，对应了式(1)的运动方程及测量方程。<br>
　　用扩展卡尔曼滤波来估计目标状态的原理可见<a href="/卡尔曼滤波器在三维目标状态估计中的应用/" title="卡尔曼滤波器在三维目标状态估计中的应用">卡尔曼滤波器在三维目标状态估计中的应用</a>。该文重点讨论基于质点的一系列运动学模型，以及基于刚体的前转向车模型；测量模型则没做深入研究，默认是目标重心级别的测量量。比如，观测量如果是三维框，那么自然可得到目标的位置，相减就得到速度的观测量。<br>
　　但是基于点云的目标检测中，目标的观测量更准确的应该是点集(cluster)。<strong>如何在贝叶斯框架下，定义点集的运动学模型及观测模型</strong>，对提高目标状态的估计显得尤其重要。ADH Tracker<a href="#1" id="1ref"><sup>[1]</sup></a> 就是一种点集状态估计方法，其描述了一种可跟踪目标表面形状特性的概率模型，本文主要阐述 ADH Tracker 的原理及实现细节。</p>
<h2 id="点集状态估计的概率模型">1. 点集状态估计的概率模型</h2>
<h3 id="贝叶斯框架">1.1. 贝叶斯框架</h3>
<p><img src="/ADH-Tracker/bayesian.png" width="50%" height="50%" title="图 1. 点集状态估计的贝叶斯概率模型"> 　　如图 1. 所示，状态量为 \(x_t\)，点集状态为 \(s_t\)，测量/观测量为 \(z_t\)，\(s_t\) 表示为从目标点集中采样的点集。 <img src="/ADH-Tracker/gaussian.png" width="50%" height="50%" title="图 2. 传感器噪声"> 　　如图 2. 所示，由于传感器的噪声 \(\Sigma_e\)，实际的目标上的点集 \(s_t\) 需要加上传感器噪声，以及目标的当前位置，才是最终的观测量点集 \(z_t\): <span class="math display">\[z_{t,j} \sim \mathcal{N}(s_{t,j},\Sigma_e) + x_{t,p}  \tag{1}\]</span> 注意坐标系是在前一时刻目标的中心，状态量中的位置是相对位置，所以前一时刻目标点服从分布： <span class="math display">\[z_{t-1,i} \sim \mathcal{N}(s_{t-1,i},\Sigma_e)  \tag{2}\]</span> 图 1. 的贝叶斯模型下： <span class="math display">\[p(z_{t-1}|x_t,s_{t-1}) = p(z_{t-1}|s_{t-1}) \tag{3}\]</span> 由于目标的遮挡等位置变换，目标上的点集 \(s_t\) 又是随时间变化的，假设 \(p(V)\) 表示当前时刻点集从前一时刻点集采样的先验概率，那么当前时刻每个点从前一时刻采样的概率为： <span class="math display">\[p(s_{t,j}|s_{t-1}) = p(V)p(s_{t,j}|s_{t-1},V) + p(\neg V)p(s_{t,j}|s_{t-1},\neg V) \tag{4}\]</span> 假设当前点在前一时刻不可见的均为被遮挡的情况，那么： <span class="math display">\[p(s_{t,j}|s_{t-1},\neg V) = k_1(k_2-(s_{t,j}|s_{t-1},V))\]</span> 合并可得： <span class="math display">\[p(s_{t,j}|s_{t-1}) = \eta(p(s_{t,j}|s_{t-1},V) +k) \tag{5}\]</span></p>
<h3 id="状态估计问题">1.2. 状态估计问题</h3>
<p>　　式(1)~(5)描述了该贝叶斯网络下各变量之间的关系，状态估计求解的目标是：在所有观测量的基础上估计当前状态，即\(p(x_t|z_1...z_t)\)。根据贝叶斯法则： <span class="math display">\[p(x_t|z_1...z_t)=\eta\; p(z_t|x_t,z_1...z_{t-1}) p(x_t|z_1...z_{t-1}) \tag{6}\]</span> 其中 \(\eta\) 为归一化常数，<strong>第一项是观测模型，第二项是运动模型</strong>。如果依据条件独立，观测模型则可简化为： <span class="math display">\[p(z_t|x_t,z_1...z_{t-1}) = p(z_t|x_t)\]</span> 但是这里考虑到 \(s_t\) 均是从同一目标采样的，所以条件独立性不成立，将观测模型简化近似为： <span class="math display">\[p(z_t|x_t,z_1...z_{t-1}) \approx p(z_t|x_t,z_{t-1}) \tag{7}\]</span> 直观上理解为，当前观测不仅依赖当前状态，还依赖上一时刻的观测量。</p>
<h2 id="adh-tracker-观测模型">2. ADH Tracker 观测模型</h2>
<p>　　观测模型式(7)可重写为： <span class="math display">\[\begin{align}
p(z_t|x_t,z_{t-1}) &amp;= \int p(z_t,s_t|x_t,z_{t-1})ds_t \\
&amp;= \int p(z_t|s_t,x_t)p(s_t|x_t,z_{t-1})ds_t \\
&amp;= \int p(z_t|s_t,x_t)\left(\int p(s_t,s_{t-1}|x_t,z_{t-1})ds_{t-1}\right)ds_t \\
&amp;= \int p(z_t|s_t,x_t)\left(\int p(s_t|s_{t-1})p(s_{t-1}|x_t,z_{t-1})ds_{t-1}\right)ds_t \\
&amp;= \int p(z_t|s_t,x_t)\left(\int \eta\;p(s_t|s_{t-1})p(z_{t-1}|x_t,s_{t-1})p(s_{t-1})ds_{t-1}\right)ds_t \\
&amp;= \int p(z_t|s_t,x_t)\left(\int \eta\;p(s_t|s_{t-1})p(z_{t-1}|s_{t-1})p(s_{t-1})ds_{t-1}\right)ds_t
\tag{8}
\end{align}\]</span> 式(1)(2)(5)可得高斯模型: <span class="math display">\[\left\{\begin{array}{l}
p(z_t|s_t,x_t) = \mathcal{N}(z_t;s_t+x_{t,p},\Sigma_e) \\
p(z_{t-1}|s_{t-1}) = \mathcal{N}(z_{t-1};s_{t-1},\Sigma_e) \\ 
p(s_t|s_{t-1}) = \eta\left(\mathcal{N}(s_{t};s_{t-1},\Sigma_r)+k \right) \\ 
\end{array}\tag{9}\right.\]</span> 其中 \(\Sigma_e \) 为传感器噪声方差，\(\Sigma_r\) 为传感器不同距离的分辨率。因为两个高斯分布相乘还是高斯分布，所以由式(8)(9-2)(9-3)，可得： <span class="math display">\[ p(s_t|x_t,z_{t-1}) = \eta (\mathcal{N}(s_t;z_{t-1},\Sigma_r+\Sigma_e)+k) \tag{10}\]</span> 进一步由式(8)(9-1)(10)可得： <span class="math display">\[p(z_t|x_t,z_{t-1}) = \eta \left(\mathcal{N}(z_t;z_{t-1}+x_{t,p},\Sigma_r+2\Sigma_e)+k \right) \tag{11}\]</span> 　　观测模型实际计算中，令 \(\bar{z} _ {t-1}\) 为点集 \(z_{t-1}\) 经过状态量变换后的点集，即 \(\bar{z} _ {t-1}=z _ {t-1}+x _ {t,p}\)；对于 \(z _ j\in z _ t\)，令 \(\bar{z} _ i \) 为 \(z _ j\) 在点集 \(\bar{z}_ { t-1}\) 中的最近点。那么: <span class="math display">\[ p(z_t|x_t,z_{t-1}) = \eta \left(\prod_{z_j\in z_t} \mathrm{exp}\left(-\frac{1}{2}(z_j-\bar{z_i})^T\Sigma^{-1}(z_j-\bar{z}_i)\right)+k\right) \tag{12}\]</span> 其中 \(\Sigma=2\Sigma_e+\Sigma_r\)。</p>
<h2 id="adh-tracker-运动模型">3. ADH Tracker 运动模型</h2>
<p>　　这里使用的是质点匀速模型，因为在 \((R,t)\) 搜索空间中得到了一组不同概率的解，所以可用多变量高斯分布去拟合这组解： <span class="math display">\[\left\{\begin{array}{l}
\mu_t=\sum_i p(x_{t,i}|z_i...z_t)x_{t,i}\\
\Sigma_t = \sum_i p(x_{t,i}|z_1...z_t)(x_{t,i}-\mu_t)(x_{t,i}-\mu_t)^T
\end{array}\tag{13}\right.\]</span> 其中 \(x_{t,i}\) 为第 \(i\) 组解对应的状态量。得到该状态量的高斯分布后，就可以用匀速运动模型预测下一时刻的状态。<br>
　　同时针对每一组解空间中的候选解，还可计算其匀速模型下的速度概率项，叠加到观测概率中。</p>
<h2 id="adh-算法">4. ADH 算法</h2>
<p><img src="/ADH-Tracker/adh.png" width="60%" height="60%" title="图 3. ADH 原理"> 　　对 \((R,t)\) 解空间进行有效搜索直接决定求解速度，如图 3. 所示，将解空间(state space)分割成一系列搜索区域，每个区域基于后验概率 \(p(x_t|z_1...z_t)\) 计算区域离散概率： <span class="math display">\[\begin{align}
p(c_i) &amp;= p(c_i\cap R) \\
&amp;= p(c_i|R)p(R) \\
&amp;= \frac{p(x_i|z_1...z_t)\vert c_i\vert}{\sum_{j\in R}p(x_j|z_1...z_t)\vert c_i\vert} p(R) \\
&amp;= \eta p(x_i|z_1...z_t)p(R)
\tag{14}
\end{align}\]</span> 其中 \(R\) 为待细分的区域集合(cells)，其被划分为子区域 \(c_i\in R\)，所以区域概率满足 \(\sum_{i\in R}p(c_i) = p(R)\)。对拥有较大离散概率的区域，进一步细分搜索区域，进行迭代搜索。初始化时，\(p(R)=1\)。<br>
　　这里需要制定区域细分的策略，考虑最大化划分前后区域概率分布的 KL-divergence，即 KL-divergence 能描述划分后，后验概率与真实分布的相似性，越接近真实分布，前后区域离散概率分布的 KL-divergence 会越小。而为了提高搜索效率，要求前后离散概率分布的 KL-divergence 要最大，最终收敛到真实分布。<br>
　　假设 \(R\) 区域的离散概率分布为 \(P_i\)，需要划分 \(k\) 个区域。那么划分前，可以认为其概率分布为每个 cell 概率为 \(P_i/k\)；划分后，其概率分布为：\(\sum_{j=1}^kp_j=P_i\)。这两个分布的 KL-divergence 为： <span class="math display">\[ D_{KL}(A\Vert B)=\sum_{j=1}^k p_j \mathrm{In}\left(\frac{p_j}{P_i/k}\right) \tag{15} \]</span> 当某个细分区域 \(p_{j'} = P_i\) 时： <span class="math display">\[ D_{KL}(A\Vert B)=P_i \mathrm{In}k  \tag{16}\]</span> 如果每个 cell 后验概率计算需要时间 \(t\) 秒，那么每秒能获得最大的 DL-divergence 为 \(P_i\mathrm{In}k/(kt)\)，由此可以选择策略：</p>
<ul>
<li>对 \(P_i\) 大于一定阈值的区域进行划分；</li>
<li>每个搜索维度划分的区域个数设定为 \(k=3\)。因为该函数在 \(k=e\) 时取得最大值。</li>
</ul>
<p><img src="/ADH-Tracker/adh_alg2.png" width="80%" height="80%" title="图 4. ADH Tracker"> 　　图 4. 为 ADH Tracker 算法的伪代码。</p>
<h2 id="adh-tracker-实现细节2">5. ADH Tracker 实现细节<a href="#2" id="2ref"><sup>[2]</sup></a></h2>
<h3 id="kalman-部分">5.1. Kalman 部分</h3>
<p>　　ADH 代码中 centroid-based kalman 的运动模型为质点匀速模型，较为简单。 其设置为：状态量 \(x=[v_x,v_y,v_z]\)，测量量 \(z=\frac{1}{\delta t}[p_x,p_y,p_z]\)。状态转移矩阵 \(A\) 以及观测矩阵 \(C\) 均为单位阵。过程噪声为高斯分布，其协方差矩阵为 \(Q_k = diag(\sigma_a,\sigma_a,\sigma_{a_z})\cdot \delta ^2 t\)，测量噪声的协方差矩阵为 \(R_k = diag(\sigma_m,\sigma_m,\sigma_m)\)。由此可方便的计算 kalman 预测及更新两个过程。</p>
<h3 id="adh-部分">5.2. ADH 部分</h3>
<p>　　ADH 算法中，每个采样分辨率下需要多次计算解空间中各 \((R,t)\) 下的观测模型，而观测模型计算中，每次需要通过 KD-Tree 寻找两个点集的匹配点，再通过式(12)计算观测概率模型。这样会非常耗时，因为观测模型本质上就是求解两个点集相似度，所以代码实现中，作者采用的策略为：首先将被匹配的点集进行栅格化，然后将点集中每个点以稠密度(density)高斯概率分布的形式拓展一定栅格范围，每个栅格取拓展到该栅格的点的高斯概率值的最大值。之后任何一个点集需要与之计算观测模型(相似度)，只要直接统计索引这个点集在该栅格下的概率值即可。</p>
<h2 id="参考文献">6. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Held, David, et al. &quot;Robust real-time tracking combining 3D shape, color, and motion.&quot; The International Journal of Robotics Research 35.1-3 (2016): 30-49.<br>
<a id="2" href="#2ref">[2]</a> https://github.com/davheld/precision-tracking</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter Pruning</title>
    <url>/Filter-Pruning/</url>
    <content><![CDATA[<p>　　文章 <a href="/pruning/" title="pruning">pruning</a> 中详细阐述了模型压缩中 Pruning 的基本方法与理论。Pruning 可分为 Structured Pruning 与 Unstructured Pruning 两种，由于 Structured Pruning 不需要特定的芯片支持，可直接在现有 CPU/GPU 架构下进行加速，所以值得作研究及应用。而 Structured Pruning 主要指 Filter Pruning，以及伴随的 Channel Pruning。本文对近期 Filter Pruning 的进展作一个阐述及思考。<br>
　　<a href="#1" id="1ref">[1]</a> 得出结论：<strong>Pruning 的本质并不应该是选择重要的 filter/channel，而应该是确定 filter/channel 的数量，在此基础上，从零开始训练也能达到原来的性能</strong>。所以 Pruning 其实只是 AutoML/NAS 领域的一个子任务，即用 AutoML/NAS 是能解决 Pruning 问题的，但是 AutoML/NAS 方法又相对复杂且耗时，所以短期内可能传统的预定义剪枝方法更容易得到应用。本文从预定义剪枝方法和自动学习剪枝方法两大块来作归纳思考。</p>
<h2 id="问题描述">1. 问题描述</h2>
<p>　　假设预训练好的网络 \(F\)，其有 \(L\) 层卷积，所有卷积层的 Filter 表示为： <span class="math display">\[ W=\{W^i\} _ {i=1}^L= \left\{\{W^i_j\} _ {j=1}^{c_i}\in\mathbb{R}^{d_i\times c_i}\right\} _ {i=1}^L \tag{1} \]</span> 其中 \(d_i=c_{i-1}\times h_i\times w_i\)；\(c_i,h_i,w_i\) 分别是第 \(i\) 层卷积的 filter 数量，高，宽；\(W_j^i\) 是第 \(i\) 层卷积第 \(j\) 个 filter。<br>
　　目标是搜索被剪枝的网络 \(\mathcal{F}\)，剪枝后的 Filter 表示为： <span class="math display">\[ \mathcal{W}=\{\mathcal{W}^i\} _ {i=1}^L= \left\{\{\mathcal{W}^i_j\} _ {j=1}^{\tilde{c}_i}\in\mathbb{R}^{d_i\times \tilde{c} _ i}\right\} _ {i=1}^L \tag{2} \]</span> 其中 \(\tilde{c} _ i=\lfloor p_i\cdot c_i\rceil\)，\(p_i\) 为 Pruning Rate。<br>
　　Filter Pruning 会导致输出的特征 Channel 数减少，对应的下一层的每个 Filter 参数需要相应的裁剪，如 <a href="/pruning/" title="pruning">pruning</a> 中提到的三种结构下的 Pruning，尤其需要注意后两种有交点的结构，剪枝时需要作一定的约束(为了简单，交点对应的 Filter 可以选择不剪枝)。</p>
<h2 id="预定义剪枝方法">2. 预定义剪枝方法</h2>
<p>　　预定义剪枝网络方法通常预定义的是 \(P=\{p_i\} _ {i=1}^L\)，其剪枝步骤为：</p>
<ol type="1">
<li>Training<br>
根据任务训练网络；</li>
<li>Pruning<br>
设计 Filter 重要性度量准则，然后根据预定义的剪枝率，进行 Filter 剪枝；</li>
<li>Fine-tuning<br>
对剪枝好的网络，进行再训练；</li>
</ol>
<h3 id="soft-filter-pruning212">2.1. Soft Filter Pruning<a href="#2" id="2ref"><sup>[2]</sup></a><a href="#12" id="12ref"><sup>[12]</sup></a></h3>
<p><img src="/Filter-Pruning/soft_filter_pruning.png" width="50%" height="50%" title="图 1. Soft Filter Pruning"> 　　如图 1. 所示，其核心思想就是剪枝后的 Filter 在 Fine-tuning 阶段还是保持更新，由此 Pruning，Fine-tuning 迭代获得较优剪枝结果。Filter 重要性度量准则为： <span class="math display">\[\left\Vert W_j^i\right\Vert _ p = \sqrt[p]{\sum_{cc=0}^{c_{i-1}-1}\sum_{k_1=0}^{h_i-1}\sum_{k_2=0}^{w_i-1}\left\vert W_j^i(cc,k_1,k_2)\right\vert ^p} \tag{3}\]</span></p>
<h3 id="filter-sketch313">2.2. Filter Sketch<a href="#3" id="3ref"><sup>[3]</sup></a><a href="#13" id="13ref"><sup>[13]</sup></a></h3>
<p>　　选择 Filter 进行剪枝，另一种思路是，如何选择一部分 Filter，使得该 Filter 集合的信息量与原 Filter 集合信息量近似: <span class="math display">\[\Sigma_{W^i}\approx \Sigma_{\mathcal{W}^i} \tag{4}\]</span> 这里的信息量表达方式采用了协方差矩阵: <span class="math display">\[\begin{align}
\Sigma_{W^i} &amp;= \left(W^i-\bar{W}^i \right)\left(W^i-\bar{W}^i \right)^T \\
\Sigma_{\mathcal{W}^i} &amp;= \left(\mathcal{W}^i-\mathcal{\bar{W}}^i \right)\left(\mathcal{W}^i-\mathcal{\bar{W}}^i \right)^T \\
\end{align} \tag{5}\]</span> 其中 Filter 权重符合高斯分布，即 \(\bar{W}^i=\frac{1}{c_i}\sum _ {j=1}^{c _ i}W _ j ^ i\approx 0\)，\(\mathcal{\bar{W}} ^ i=\frac{1}{\tilde{c} _ i}\sum _ {j=1}^{\tilde{c} _ i}\mathcal{W} _ j^i\approx 0\)。由式(4)(5)，构建最小化目标函数： <span class="math display">\[\mathop{\arg\min}\limits_{\mathcal{W}^i}\left\Vert W^i(W^i)^T-\mathcal{W}^i(\mathcal{W}^i)^T \right\Vert \tag{6}\]</span> 将该问题转换为求取 \(W^i\) 矩阵的 Sketch 问题，则： <span class="math display">\[\left\Vert W^i(W^i)^T-\mathcal{W}^i(\mathcal{W}^i)^T \right\Vert _F \leq \epsilon\left\Vert W^i\right\Vert^2_F \tag{7}\]</span> <img src="/Filter-Pruning/sketch.png" width="50%" height="50%" title="图 2. Frequent Direction"> <img src="/Filter-Pruning/filter_sketch.png" width="50%" height="50%" title="图 3. FilterSketch"> 　　式(7)可用图 2. 所示的算法求解，最终的 Pruning 算法过程如图 3. 所示，改进的地方主要是 Filter 选择的部分，采用了 Matrix Sketch 算法。 <img src="/Filter-Pruning/pruning.png" width="60%" height="60%" title="图 4. 网络裁剪示意图"> 　　<a href="/pruning/" title="pruning">pruning</a> 中提到有分支结构的裁剪会比较麻烦，所以如图 4. 所示，本方法对分支节点的 Filter 不做裁剪处理，简化了问题。</p>
<h3 id="filter-pruning-via-geometric-median414">2.3. Filter Pruning via Geometric Median<a href="#4" id="4ref"><sup>[4]</sup></a><a href="#14" id="14ref"><sup>[14]</sup></a></h3>
<p>　　在预定义剪枝网络方法的三个步骤中，大家普遍研究步骤二中 Filter 的重要性度量设计。Filter 重要性度量基本是 Smaller-norm-less-informative 思想，<a href="#5" id="5ref">[5]</a> 中则验证了该思想并不一定正确。<strong>Smaller-norm-less-informative 假设成立的条件是</strong>：</p>
<ol type="1">
<li>Filter 权重的规范偏差(norm deviation)要大；</li>
<li>Filter 权重的最小规范要小；</li>
</ol>
<p>只有满足这两个条件，该假设才成立，即可以裁剪掉规范数较小的 Filter。 <img src="/Filter-Pruning/norm_dist.png" width="60%" height="60%" title="图 5. Filter Norm Distribution"> 　　但是，如图 5. 所示，实际 Filter 的权重分布和理想的并不一致，当 Filter 分布是绿色区域时，采用 Smaller-norm-less-informative 就不合理了，而这种情况还比较多。一般性的，前几层网络的权重规范数偏差会比较大，后几层则比较小。<br>
<img src="/Filter-Pruning/criterion.png" width="50%" height="50%" title="图 6. Criterion for Filter Pruning"> 　　由此，本方法提出一种基于 Geometric Median 的 Filter 选择方法，如图 6. 所示，基于 Smaller-norm-less-informative 的裁剪后留下的均是规范数较大的 Filter，这还存在一定的冗余性，本方法则通过物理距离测算，剪掉冗余的 Filter。<strong>另一个角度可理解为最大程度的保留 Filter 集合的大概及具体信息，其思想与 FilterSketch 类似</strong>。<br>
　　根据 Geometric Median 思想，第 \(i\) 层卷积要裁剪掉的 Filter 为： <span class="math display">\[W^i_{j^\ast}=\mathop{\arg\min}\limits_{W^i_{j^\ast}\,|\,j^\ast\in[0,c_i-1]}\sum_{j&#39;=0}^{c_i-1}\left\Vert W^i_{j^\ast}-W^i_{j&#39;}\right\Vert_2 \tag{8}\]</span> 由此裁剪掉满足条件的 \(W _ {j^*}^i\)，直至符合裁剪比率。<strong>本方法的思想非常类似于 Farthest Point Sampling 采样，留下的 Filter 即为原 Filter 集合采样的结果，且最大程度的保留了集合的信息</strong>。</p>
<h2 id="自动学习剪枝方法">3. 自动学习剪枝方法</h2>
<h3 id="abcpruner616">3.1. ABCPruner<a href="#6" id="6ref"><sup>[6]</sup></a><a href="#16" id="16ref"><sup>[16]</sup></a></h3>
<p><img src="/Filter-Pruning/ABCPruner.png" width="60%" height="60%" title="图 7. ABCPruner"> 　　出于<a href="#1" id="1ref">[1]</a>的结论：<strong>剪枝的本质应该是直接找到每层卷积最优的 Filter 数量，在此基础上从零开始训练也能达到原来的性能</strong>。ABCPruner 的目标就是搜索每层最优的 Filter 数量，如图 7. 所示，ABCPruner 步骤为：</p>
<ol type="1">
<li>初始化一系列不同 Filter 数量的网络结构；</li>
<li>每个网络结构从 pre-trained 网络中继承权重值，fine-tune 获得每个网络的 fitness(即 accuracy)；</li>
<li>用 ABC 算法更新网络结构；</li>
<li>重复迭代 2,3 步骤，获取最高的 fitness 网络作为最终网络结构；</li>
</ol>
<h3 id="metapruning717">3.2. MetaPruning<a href="#7" id="7ref"><sup>[7]</sup></a><a href="#17" id="17ref"><sup>[17]</sup></a></h3>
<p><img src="/Filter-Pruning/metapruning.png" width="50%" height="50%" title="图 8. MetaPruning"> 　　同样，本方法也是基于<a href="#1" id="1ref">[1]</a>的结论。这里设计 PruningNet 来控制裁剪，步骤为：</p>
<ol type="1">
<li>Training PruningNet<br>
PruningNet 输入为网络编码向量，即每层卷积的 Filter 数量，输出为产生网络权重的编码量，如 size reshape，crop。每次训练时随机生成网络编码量，网络编码量与 PruningNet 输出共同决定了 PrunedNet 权重，两个网络联合训练；</li>
<li>Searching for the Best Pruned Net<br>
即 Inference 过程，寻找最优的网络编码量，使得 PrunedNet 精度最高；得到最优网络后，不需要 fine-tuning。</li>
</ol>
<h3 id="generative-adversarial-learning8">3.3. Generative Adversarial Learning<a href="#8" id="8ref"><sup>[8]</sup></a></h3>
<p><img src="/Filter-Pruning/GAL.png" width="90%" height="90%" title="图 9. Generative Adversarial Learning"> 　　本方法主要思想来自知识蒸馏(Knowledge Distillation)和生成对抗网络(Generative Adversarial Network)，如图 9. 所示，Baseline 为完整的原始网络，PrunedNet 是为了学习一个 soft mask 来动态选择 block，branch，channel，最终裁剪后的网络由 soft mask 决定。<br>
　　从知识蒸馏的角度：Baseline 就是一个大容量的教师网络，Pruned Net 就是个小容量的学生网络，用大容量网络来监督小容量网络学习。从生成对抗学习的角度：Baseline 是原始网络，PrunedNet 是生成的对抗网络，用一个 Discriminator 网络来区分原始网络与生成的对抗网络的区别，使生成的对抗网络输出逼近于原始网络。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Liu, Zhuang, et al. &quot;Rethinking the Value of Network Pruning.&quot; International Conference on Learning Representations. 2018.<br>
<a id="2" href="#2ref">[2]</a> He, Yang, et al. &quot;Soft filter pruning for accelerating deep convolutional neural networks.&quot; arXiv preprint arXiv:1808.06866 (2018).<br>
<a id="3" href="#3ref">[3]</a> Lin, Mingbao, et al. &quot;Filter Sketch for Network Pruning.&quot; arXiv preprint arXiv:2001.08514 (2020).<br>
<a id="4" href="#4ref">[4]</a> He, Yang, et al. &quot;Filter pruning via geometric median for deep convolutional neural networks acceleration.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="5" href="#5ref">[5]</a> Ye, Jianbo, et al. &quot;Rethinking the smaller-norm-less-informative assumption in channel pruning of convolution layers.&quot; arXiv preprint arXiv:1802.00124 (2018).<br>
<a id="6" href="#6ref">[6]</a> Lin, Mingbao, et al. &quot;Channel Pruning via Automatic Structure Search.&quot; arXiv preprint arXiv:2001.08565 (2020).<br>
<a id="7" href="#7ref">[7]</a> Liu, Zechun, et al. &quot;Metapruning: Meta learning for automatic neural network channel pruning.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2019.<br>
<a id="8" href="#8ref">[8]</a> Lin, Shaohui, et al. &quot;Towards optimal structured cnn pruning via generative adversarial learning.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="9" href="#9ref">[9]</a> Singh, Pravendra, et al. &quot;Play and prune: Adaptive filter pruning for deep model compression.&quot; arXiv preprint arXiv:1905.04446 (2019).<br>
<a id="11" href="#11ref">[11]</a> https://github.com/Eric-mingjie/rethinking-network-pruning<br>
<a id="12" href="#12ref">[12]</a> https://github.com/he-y/softfilter-pruning<br>
<a id="13" href="#13ref">[13]</a> https://github.com/lmbxmu/FilterSketch<br>
<a id="14" href="#14ref">[14]</a> https://github.com/he-y/filter-pruning-geometric-median<br>
<a id="16" href="#16ref">[16]</a> https://github.com/lmbxmu/ABCPruner<br>
<a id="17" href="#17ref">[17]</a> https://github.com/liuzechun/MetaPruning</p>
]]></content>
      <categories>
        <category>Model Compression</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Model Compression</tag>
      </tags>
  </entry>
  <entry>
    <title>KLT 光流算法详解</title>
    <url>/KLT/</url>
    <content><![CDATA[<p>　　光流（Optical Flow）是物体在三维空间中的运动（运动场）在二维图像平面上的投影，由物体与相机的相对速度产生，反映了微小时间内物体对应的图像像素的运动方向和速度。<br>
　　KLT 是基于光流原理的一种特征点跟踪算法，本文首先介绍光流原理，然后介绍 KLT 及相关 KLT 变种算法。</p>
<h2 id="optical-flow">1. Optical Flow</h2>
<p>　　光流法假设：</p>
<ul>
<li>亮度恒定，图像中物体的像素亮度在连续帧之间不会发生变化；</li>
<li>短距离(短时)运动，相邻帧之间的时间足够短，物体运动较小；</li>
<li>空间一致性，相邻像素具有相似的运动；</li>
</ul>
<p>　　记 \(I(x,y,t)\) 为 \(t\) 时刻像素点 \((x,y)\) 的像素值，那么根据前两个假设，可得到： <span class="math display">\[I(x,y,t)=I(x+dx,y+dy,t+dt)\]</span> 一阶泰勒展开： <span class="math display">\[I(x+dx,y+dy,t+dt)=I(x,y,t)+\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt\]</span> 由此可得： <span class="math display">\[\frac{\partial I}{\partial x}dx+\frac{\partial I}{\partial y}dy+\frac{\partial I}{\partial t}dt=0 \iff \frac{\partial I}{\partial x}\frac{dx}{dt}+\frac{\partial I}{\partial y}\frac{dy}{dt}=-\frac{\partial I}{\partial t}\]</span> 记 \(\left(\frac{dx}{dt},\frac{dy}{dt}\right)=(u,v)\)，即为所要求解的像素光流；\(\left(\frac{\partial I}{\partial x},\frac{\partial I}{\partial y}\right)=(I_x,I_y)\) 为像素灰度空间微分；\(\frac{\partial I}{\partial t}=I_x\) 为像素坐标点的时间灰度微分。整理成矩阵形式： <span class="math display">\[\begin{bmatrix}
I_x &amp;I_y\\
\end{bmatrix}
\begin{bmatrix}
u\\
v\\
\end{bmatrix}=-I_t
\]</span> 该式表示相同坐标位置的时间灰度微分是空间灰度微分与这个位置上相对于观察者的速度的乘积。由空间一致性假设，对于周围多个点，有： <span class="math display">\[\begin{bmatrix}
I_{x1} &amp;I_{y1}\\
I_{x2} &amp;I_{y2}\\
I_{x3} &amp;I_{y3}\\
\vdots &amp;\vdots \\
\end{bmatrix}
\begin{bmatrix}
u\\
v\\
\end{bmatrix}=-
\begin{bmatrix}
I_{t1}\\
I_{t2}\\
\vdots\\
\end{bmatrix} \iff A\vec{u}=b
\]</span> 这是标准的线性方程组，可用最小二乘法求解 \(\vec{u}=\left(A^ TA\right)^ {-1}A^ Tb\)，也可以迭代求解。这种方式得到的光流，称为 Lucas-Kanade 算法。</p>
<h2 id="klt">2. KLT</h2>
<p>　　KLT 算法本质上也基于光流的三个假设，不同于前述直接比较像素点灰度值的作法，KLT 比较像素点周围的窗口像素，来寻找最相似的像素点。由光流假设，在很短时间 \(\tau\) 内，前后两帧图像满足： <span class="math display">\[J(A\mathrm{x}+d)=I(\mathrm{x}), 其中 A=1+D=1+\begin{bmatrix}
d_{xx} &amp; d_{xy}\\
d_{yx} &amp; d_{yy}\\
\end{bmatrix}\]</span> 像素位移(displacement)向量满足仿射运动模型(Affine Motion) \(=Dx+d\)，其中 \(D\) 称为变形矩阵(Deformation Matrix)，\(d\) 称为位移向量(Displacement Vector)。\(D\) 表示两个像素窗口块运动后的变形量，所以当窗口较小时，会比较难估计。通常 \(D\) 可以用来衡量两个像素窗口的相似度，即衡量特征点有没有漂移。而对于光流跟踪量，一般只考虑平移模型(Translation Model)： <span class="math display">\[J(\mathrm{x}+d)=I(\mathrm{x})\]</span> 　　为了普遍性，我们用仿射运动模型来推到 KLT 算法原理。在像素窗口下，构造误差函数： <span class="math display">\[\epsilon=\iint_W [J(A\mathrm{x}+d)-I(x)]^2 w(\mathrm{x})d\mathrm{x}\]</span> 其中 \(w(\mathrm{x})\) 是权重函数，可定义为高斯形式。上式分别对变量 \(D\) 和 \(d\) 求导： <span class="math display">\[\left\{\begin{array}{l}
\frac{\partial \epsilon}{\partial D}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,\mathrm{x}^T\,w\,d\mathrm{x}&amp;=0\\
\frac{\partial \epsilon}{\partial d}=2\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}&amp;=0\\
\end{array}\right.\]</span> 其中 \(g=\left(\frac{\partial J}{\partial x},\frac{\partial J}{\partial y}\right)^ T\)。记光流 \(u=D\mathrm{x}+d\)，则对运动后的像素点进行泰勒展开： <span class="math display">\[J(A\mathrm{x}+d)=J(x)+g^T(u)\]</span> 仿射运动模型结果可见<a href="#1" id="1ref">[1]</a><a href="#5" id="5ref">[5]</a>，这里给出平移运动模型结果。令 \(D=0\)： <span class="math display">\[\begin{align}
&amp;\iint_W[J(A\mathrm{x}+d)-I(\mathrm{x})]g\,w\,d\mathrm{x}=0\\
\iff &amp;\iint_W[J(\mathrm{x})-I(\mathrm{x})]g\,w\,d\mathrm{x}=-\iint_Wg^T\,\mathrm{d}\,g\,w\,d\mathrm{x}=-\left[\iint_Wg\,g^T\,w\,d\mathrm{x}\right]\mathrm{d}\\
\iff &amp;Z\mathrm{d}=e
\end{align}\]</span> 其中 \(Z\) 是 \(2\times 2\) 矩阵，\(e\) 是 \(2\times 1\) 向量。这是线性方程组优化问题，当 \(Z\) 可逆时，这个方程可容易求解。因为推导过程用到了泰勒展开，所以只有当像素位移较小时，才成立。实际操作中，一般迭代式的来求解，每次用上次结果做初始化，进一步求解(In a Newton-Raphson Fasion)。</p>
<h2 id="pyramidal-iterative-klt">3. Pyramidal Iterative KLT</h2>
<p>　　以上标准的迭代式 KLT 计算过程只在位移较小时成立（泰勒展开），所以需要更优的金字塔式迭代求解。图像金字塔有多重定义方式，这里定义： <span class="math display">\[\begin{align}
I^L(x,y)&amp;=\frac{1}{4}I^{L-1}(2x,2y)\\
&amp;+\frac{1}{8}\left(I^{L-1}(2x-1,2y)+I^{L-1}(2x+1,2y)+I^{L-1}(2x,2y-1)+I^{L-1}(2x,2y+1)\right)\\
&amp;+\frac{1}{16}\left(I^{L-1}(2x-1,2y-1)+I^{L-1}(2x+1,2y+1)+I^{L-1}(2x-1,2y+1)+I^{L-1}(2x+1,2y-1)\right)
\end{align}\]</span> 　　特征点跟踪有两个关键指标：<strong>准确性(accuracy)</strong>，以及<strong>鲁棒性(robustness)</strong>。大的窗口，对大的运动量比较鲁棒，但是为了提高准确性，又不得不减小窗口。所以窗口的选择需要权衡跟踪准确性与鲁棒性。金字塔迭代 KLT 则能有效弱化窗口的局限性。这里介绍平移模型下金字塔迭代 KLT 算法，仿射模型算法过程可见<a href="#1" id="1ref">[1]</a><a href="#5" id="5ref">[5]</a>。<br>
　　定义金字塔迭代 KLT 算法的目标：图像 \(I\) 中某坐标点 \(\mathrm{x}\)，在图像 \(J\) 中找到其对应点 \(\mathrm{}\)。算法流程为：</p>
<blockquote>
<p>建立图像金字塔：\(\{I^ L\}_ {L=0,...,L_m}\)，\(\{J^ L\}_ {L=0,...,L_m}\)<br>
初始化光流在金字塔之间的传递值：\(g^ {L_m}=[g_x^ {L_m},g_y^ {L_m}]^ T=[0,0]^ T\)<br>
<strong>for \(L=L_m\) down to 0 with step of -1</strong></p>
<blockquote>
<p>计算图像 \(I^ L\) 中的 \(\mathrm{x}\) 坐标: \(\mathrm{x}^ L=[x,y]^ T=\mathrm{x}/2^ L\)<br>
计算空间梯度矩阵 \(Z\)<br>
初始化 KLT 迭代值：\(v^ 0=[0,0]^ T\)<br>
<strong>for \(k=1\) to \(K\) with step of 1</strong> or until \(\Vert\eta^ k\Vert\) &lt; accuracy threshold</p>
<blockquote>
<p>计算图像差矩阵 \(I^ L(\mathrm{x}^ L)-J^ L(\mathrm{x}^ L)=I^ L(x,y)-J^ L(x+g_x^ L+v_x^ {k-1},y+g_y^ L+v_y^ {k-1})\)<br>
计算图像差矩阵 \(e_k\)<br>
计算光流 \(\eta^ k=Z^ {-1}e_k\)<br>
更新下次迭代的初值 \(v^ k=v^ {k-1}+\eta^ k\)</p>
</blockquote>
<p><strong>end of for-loop on k</strong><br>
第 \(L\) 层金字塔下光流为：\(\mathrm{d}^ L=v^ K\)<br>
初始化第 \(L-1\) 层金字塔的光流： \(g^ {L-1}=[g_x^ {L-1}, g_y^ {L-1}]^ T=2(g^ L+\mathrm{d}^ L)\)</p>
</blockquote>
<p><strong>end of for-loop on L</strong> 最终的光流结果：\(\mathrm{d}=g^ 0+\mathrm{d}^ 0\)<br>
对应的 \(J\) 上的坐标点为：\(\hat{\mathrm{x}}=\mathrm{x}+\mathrm{d}\)</p>
</blockquote>
<h2 id="feature-selection">4. Feature Selection</h2>
<p>　　在特征点跟踪之前，特征点的选择也很重要，以上计算过程中，我们期望 \(Z\) 可逆，也就是其最小特征值要足够大。如果已经提取了角点，则可进一步做选择。因此特征点选择准则为：</p>
<ol type="1">
<li>计算图像每个像素(或已提取的角点)的 \(Z\) 矩阵，及其最小的特征值 \(\lambda_m\)</li>
<li>从所有 \(\lambda_m\) 中取最大值为 \(\lambda_{max}\)</li>
<li>保留 \(\lambda_m\) 大于一定百分比(10%) \(\lambda_{max}\) 的像素(角点)</li>
<li>在这些像素(角点)中，保留局部最大值</li>
<li>视计算能力，保留其中的子集</li>
</ol>
<p>以上特征点提取的过程类似于 <a href="https://blog.csdn.net/u010103202/article/details/73331440" target="_blank" rel="noopener">Harris 角点</a>。要注意的是选择特征计算 \(Z\) 时，\(3\times3\) 窗口足够，但是跟踪时，一般大于 \(3\times3\)。</p>
<h2 id="dissimilarity">5. Dissimilarity</h2>
<p>　　相似性度量决定该特征点是否已经漂移而不能使用了，即外点检测(Outlier Detection)，所以非常重要。相比于平移模型，仿射模型对特征点的相似性度量更有效果。在长距离跟踪下，相似性度量可能解决不了是否漂移的问题，但是好的相似性度量能从一开始就剔除漂移的特征点。此外，也可用其它更高层面的外点检测技术替代。</p>
<p><a id="1" href="#1ref">[1]</a> Shi, Jianbo, and Carlo Tomasi. Good features to track. Cornell University, 1993.<br>
<a id="2" href="#2ref">[2]</a> Birchfield, Stan. &quot;Derivation of kanade-lucas-tomasi tracking equation.&quot; unpublished notes (1997).<br>
<a id="3" href="#3ref">[3]</a> Bouguet, J.-Y.. “Pyramidal implementation of the lucas kanade feature tracker.” (2000).<br>
<a id="4" href="#4ref">[4]</a> Suhr, Jae Kyu. &quot;Kanade-lucas-tomasi (klt) feature tracker.&quot; Computer Vision (EEE6503) (2009): 9-18.<br>
<a id="5" href="#5ref">[5]</a> Bouguet, Jean-Yves. &quot;Pyramidal implementation of the affine lucas kanade feature tracker description of the algorithm.&quot; Intel Corporation 5.1-10 (2001): 4.</p>
]]></content>
      <categories>
        <category>Scene Flow</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>tracking</tag>
        <tag>ADAS</tag>
      </tags>
  </entry>
  <entry>
    <title>MOT 综述-&#39;Multiple Object Tracking: A Literature Review&#39;</title>
    <url>/MOT-%E7%BB%BC%E8%BF%B0-Multiple-Object-Tracking-A-Literature-Review/</url>
    <content><![CDATA[<p>　　之前做 MOT 还是沿着 SOT 的思路，这篇文章对 MOT 有一个很深入且很有框架性的综述，以下对这篇文章做一个提炼，并加入一些自己的想法。<br>
　　MOT 作为一个中层任务，是一些高层任务的基础，比如行人的 pose estimation，action recognition，behavior analysis，车辆的 state estimation。单目标跟踪(SOT)主要关注 appearance model 以及 motion model 的设计，解决尺度、旋转、光照等影响因素。而 MOT 包含两个任务：目标数量以及目标ID，这就要求 MOT 还需要解决其它问题：</p>
<ul>
<li>frequent occlusions</li>
<li>initialization and termination of tracks</li>
<li>similar appearance</li>
<li>interactions among multiple objects</li>
</ul>
<h2 id="问题描述">1. 问题描述</h2>
<p>　　多目标跟踪实际上是多参数估计问题。给定图像序列\(\{I_1,I_2,...,I_t,...\}\)，第\(t\)帧中目标个数为\(M_t\)，第\(t\)帧中所有目标的状态表示为\(S_t=\{s_t^ 1,s_t^ 2,...,s_t^ {M_t}\}\)，第\(i\)个目标的轨迹表示为\(s_{1:t}^ i=\{s_1^ i,s_2^ i,...,s_t^ i\}\)，所有图像中所有目标的状态序列为\(S_{1:t}=\{S_1,S_2,...,S_t\}\)。相应的，所有图像中所有目标观测到的状态序列为\(O_{1:t}=\{O_1,O_2,...,O_t\}\)。多目标跟踪的优化目标是求解最优的各目标状态，即求解一个后验概率问题，<span class="math display">\[ \widehat{S}_{1:t}=\mathop{\arg\max}_{S_{1:t}}P(S_{1:t}|O_{1:t})\]</span> 这种形式有两种实现方法：</p>
<ul>
<li><p><strong>probabilistic inference</strong><br>
适合用于 online tracking 任务，Dynamic Model 为 \(P(S_t|S_{t-1})\)，Observation Model 为 \(P(O_t|S_t)\)，两步求解过程：<br>
　\(\circ\)　Predict: \(P(S_t|O_{1:t-1})=\int P(S_t|S_{t-1})dS_{t-1}\)<br>
　\(\circ\)　Update: \(P(S_t|O_{1:t}) \propto P(O_t|S_t)P(S_t|O_{1:t-1})\)</p></li>
<li><p><strong>deterministic optimization</strong><br>
适合用于 offline tracking 任务，直接利用多帧信息进行最优化求解。</p></li>
</ul>
<h2 id="分类方法">2. 分类方法</h2>
<ul>
<li><strong>initialization method</strong><br>
初始化方式分为：<br>
　\(\circ\)　Detection-Based Tracking，优势明显，除了只能处理特定的目标类型；<br>
　\(\circ\)　Detection-Free Tracking，能处理任何目标类型；</li>
<li><strong>processing mode</strong><br>
根据是否使用未来的观测，处理方式可分为：<br>
　\(\circ\)　online tracking，适合在线任务，缺点是观测量会比较少；<br>
　\(\circ\)　offline tracking，输出结果存在时延，理论上能获得全局最优解；</li>
<li><p><strong>type of output</strong><br>
根据问题求解方式输出是否存在随机性：<br>
　\(\circ\)　probabilistic inference，概率性推断；<br>
　\(\circ\)　deterministic inference，求解最大后验概率；</p>
<p><strong>自动驾驶等在线任务主要关注 Detection-Based，online tracking。</strong></p></li>
</ul>
<h2 id="框架">3. 框架</h2>
<p>　　MOT 主要考虑两个问题：</p>
<ul>
<li>目标在不同帧之间的相似性度量，即对appearance, motion, interaction, exclusion, occlusion的建模；</li>
<li>恢复出目标的ID，即 inference 过程；</li>
</ul>
<h3 id="appearance-model">3.1. Appearance Model</h3>
<h4 id="visual-representation">3.1.1. Visual Representation</h4>
<p>　　视觉表达即目标的特征表示方式：</p>
<ol type="1">
<li><strong>local features</strong><br>
本质上是点特征，点特征由 corner+descriptor(角点+描述子) 组成。KLT(good features to track)在 SOT 中应用广泛，用它可以生成短轨迹，估计相机运动位姿，运动聚类等；Optical Flow也是一种局部特征，在数据关联之前也可用于将检测目标连接到短轨迹中去。</li>
<li><strong>region features</strong><br>
在一个块区域内提取特征，根据像素间作差的次数，可分为：
<ul>
<li>zero-order, color histogram &amp; raw pixel template</li>
<li>first-order, HOG &amp; level-set formulation(?)</li>
<li>up-to-second-order, Region covariance matrix</li>
</ul></li>
<li><strong>others</strong><br>
其它特征本质上也需要 local 或 region 的方式提取，只是原始信息并不是灰度或彩图。如 depth,probabilistic occupancy map, gait feature.</li>
</ol>
<p>　　Local features，比如颜色特征，在计算上比较高效，但是对遮挡，旋转比较敏感；Region features 里，HOG 对光照有一定的鲁棒性，但是对遮挡及形变效果较差；Region covariance matrix 更加鲁棒，但是需要更高的计算量；深度特征也比较有效，但是需要额外的获取深度信息的代价。</p>
<h4 id="statistical-measuring">3.1.2. Statistical Measuring</h4>
<p>　　有了目标的特征表示方式之后，就可以评价两个观察的目标的相似性。特征表示的线索(cue)可分为：</p>
<ol type="1">
<li><strong>single cue</strong><br>
因为只有一个线索，相似性(similarity)可以直接通过两个向量的距离转换得到。可以将距离指数化，高斯化。也可以将不相似度转为可能性，用协方差矩阵表示。</li>
<li><strong>multiple cues</strong><br>
多线索，即多种特征的融合，能极大提高鲁棒性，融合的策略有：
<ul>
<li>Boosting, 选取一系列的特征，用 boost 算法选取表达能力最强的特征；</li>
<li>Concatenation, 各个特征直接在空间维度上串起来，形成一个 cue 的表达方式；</li>
<li>Summation, 加权融合各个特征，形成一个 cue 的表达方式；</li>
<li>Product, 各个特征相乘的方式，比如目标 \(s_0\) 的某个潜在匹配 \(s_1\) 的颜色，形状特征为 \(color\), \(shape\) 的概率为 \(p(color|s_0)\), \(p(shape|s_0)\), 假设特征独立，那么， 　　　　　　　<span class="math display">\[p(s_1|s_0)=p(color, shape|s_0)=p(color|s_0)\cdot p(shape|s_0)\]</span></li>
<li>Cascading, coarse-to-fine 的方式，逐步精细化搜索；</li>
</ul></li>
</ol>
<h3 id="motion-model">3.2. Motion Model</h3>
<p>　　运动模型对关联两个 tracklets 比较管用，而 online tracking 任务，对输出的时延要求较高，所以其中一个 tracklet 可以任务就是当前帧与上一帧形成的轨迹，所以这里很难去计算两个 tracklets 的相似度。能看到的一个应用点就是，通过 motion model 模型，预测下一时刻目标的位置，作为一个线索项目。以下讨论的各模型主要是为了度量 tracklets 的相似性，从而做 tracklets 的匹配。</p>
<h4 id="linear">3.2.1. Linear</h4>
<ul>
<li>Velocity Smoothness. N 帧 M 个目标轨迹: \(C_{dyn}=\sum_{t=1}^ {N-2}\sum_{i=1}^ {M}\parallel v_i^ t-v_i^ {t+1}\parallel^ 2\)</li>
<li>Position Smoothness. \(G(p^ {tail}+v^ {tail}\Delta t-p^ {head}, \sum_p)\cdot G(p^ {head}-v^ {head}\Delta t-p^ {tail}, \sum_p)\)</li>
<li>Acceleration Smoothness.</li>
</ul>
<h4 id="non-linear">3.2.2. Non-linear</h4>
<p>　　运动模型假设是非线性的，相似度计算还是按照以上高斯形式。引为中提到，非线性运动模型并不作为目标的惩罚因子，因为目标并不需要满足该模型，但是只要有目标满足，就降低惩罚系数。</p>
<h3 id="interaction-model">3.3. Interaction Model</h3>
<h4 id="social-force-models">3.3.1. Social Force Models</h4>
<ol type="1">
<li><strong>Individual Force</strong>
<ul>
<li>fidelity, 目标不会改变它的目的地方向；</li>
<li>constancy, 目标不会突然改变速度和方向；</li>
</ul></li>
<li><strong>Group Force</strong>
<ul>
<li>attraction, 目标间应该尽量靠近；</li>
<li>repulsion, 目标间也得保留适当的距离；</li>
<li>coherence, 同一个 group 里面的目标速度应该差不多；</li>
</ul></li>
</ol>
<h4 id="crowd-motion-pattern-models">3.3.2. Crowd Motion Pattern Models</h4>
<p>　　当一个 group 比较密集的时候，单个目标的运动模型不太显著了，这时候群体的运动模型更加有效，可以用一些方法来构建群体运动模型。</p>
<h3 id="exclusion-model">3.4. Exclusion Model</h3>
<h4 id="detection-level">3.4.1. Detection-level</h4>
<p>　　同一帧两个检测量不能指向同一个目标。匹配 tracklets 时，可以将这一项作为惩罚项。不过目前的检测技术都做了 NMS，基本可以消除这种情况。</p>
<h4 id="trajectory-level">3.4.2. Trajectory-level</h4>
<p>　　两个轨迹不能非常靠近。对于 online tracking 来说，就是 tracking 结果的两个量不能挨在一起，如果挨在一起，就说明有问题，比如遮挡，或跟丢。</p>
<h3 id="occlusion-handling">3.5. Occlusion Handling</h3>
<ul>
<li>Part-to-whole, 将目标分成栅格来处理；</li>
<li>Hypothesize-and-test,</li>
<li>Buffer-and-recover, 在遮挡产生前，记录一定量的观测，遮挡后恢复；</li>
<li>Others</li>
</ul>
<h3 id="inference">3.6. Inference</h3>
<h4 id="probabilistic-inference">3.6.1. Probabilistic Inference</h4>
<p>　　概率法只需要用到当前时刻之前的信息，所以适合用于 online tracking 任务。首先，如果假设一阶马尔科夫，当前目标的状态之依赖于前一时刻目标的状态，即 <em>dynamic model</em>： <span class="math display">\[P(S_t|S_{1:t-1})=P(S_t|S_{t-1})\]</span> 其次，观测是独立的，即当前目标的观测只由当前目标的状态决定，<em>observation model</em>： <span class="math display">\[P(O_{1:t}|S_{1:t})=\prod_{i=1}^t P(O_t|S_t)\]</span> dynamic model 对应的就是跟踪算法策略，observation model 是状态观测手段，包括检测方法。目标状态估计的迭代过程为：</p>
<ul>
<li><strong>predict step</strong><br>
根据 dynamic model，由目标的上一状态预测当前状态的后验概率分布；</li>
<li><strong>update step</strong><br>
根据 observation model，更新当前目标状态的后验概率分布；</li>
</ul>
<p>　　状态估计的过程伴随着噪音等因素的影响，常用的概率推断模型有：</p>
<ul>
<li>Kalman filter</li>
<li>Extended Kalman filter</li>
<li>Particle filter</li>
</ul>
<h4 id="deterministic-optimization">3.6.2. Deterministic Optimization</h4>
<p>　确定性优化法需要至少一个时间窗口的观测量，所以适合 offline tracking 任务。优化方法有：</p>
<ul>
<li>Bipartite graph matching</li>
<li>Dynamic Programming</li>
<li>Min-cost max-flow network flow</li>
<li>Conditional random field</li>
<li>MWIS(Maximum-weight independent set)</li>
</ul>
<h2 id="评价方法">4. 评价方法</h2>
<p>　　评价方法是非常重要的，一方面对算法系统进行调参优化，另一方面比较各个不同算法的优劣。评价方法 (evaluation) 包括评价指标 (metrics) 以及数据集 (datasets)，多类别的数据集主要有：</p>
<ul>
<li><a href="https://motchallenge.net/results/MOT17/" target="_blank" rel="noopener">MOT Challenge</a></li>
<li><a href="http://www.cvlibs.net/datasets/kitti/eval_tracking.php" target="_blank" rel="noopener">KITTI</a>　　</li>
</ul>
<p>评价指标可分为：</p>
<p>A. <strong>检测指标</strong><br>
　\(\lozenge\)　准确性(Accuracy)</p>
<ul>
<li>Recall &amp; Precision</li>
<li>False Alarme per Frame(FAF) rate, from <a href="https://www.google.com/search?q=Learning+affinities+and+dependencies+for+multi-target+tracking+using+a+CRF+model&amp;oq=Learning+affinities+and+dependencies+for+multi-target+tracking+using+a+CRF+model&amp;aqs=chrome..69i57.1077j0j9&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">paper</a></li>
<li>False Positive Per Image(FPPI), from <a href="https://www.google.com/search?q=Multiple+target+tracking+in+world+coordinate+with+single%2C+minimally+calibrated+camera&amp;oq=Multiple+target+tracking+in+world+coordinate+with+single%2C+minimally+calibrated+camera&amp;aqs=chrome..69i57j0.1134j0j9&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">paper</a></li>
<li>MODA(Multiple Object Detection Accuracy), 包含了 false positive &amp; miss dets. from <a href="https://www.google.com/search?q=Framework+for+performance+evaluation+of+face%2C+text%2C+and+vehicle+detection+and+tracking+in+video%3A+Data%2C+metrics%2C+and+protocol&amp;oq=Framework+for+performance+evaluation+of+face%2C+text%2C+and+vehicle+detection+and+tracking+in+video%3A+Data%2C+metrics%2C+and+protocol&amp;aqs=chrome..69i57j69i61.973j0j9&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">paper</a></li>
</ul>
<p>　\(\lozenge\)　精确性(Precision)</p>
<ul>
<li>MODP(Multiple Object Detection Precision), 衡量检测框与真值框的位置对齐程度；from <a href="https://www.google.com/search?q=Framework+for+performance+evaluation+of+face%2C+text%2C+and+vehicle+detection+and+tracking+in+video%3A+Data%2C+metrics%2C+and+protocol&amp;oq=Framework+for+performance+evaluation+of+face%2C+text%2C+and+vehicle+detection+and+tracking+in+video%3A+Data%2C+metrics%2C+and+protocol&amp;aqs=chrome..69i57j69i61.973j0j9&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">paper</a></li>
</ul>
<p>B. <strong>跟踪指标</strong><br>
　\(\lozenge\)　准确性(Accuracy)</p>
<ul>
<li>ID switches(IDs), from <a href="https://www.google.com/search?safe=strict&amp;ei=agXyXMaQEKyl_Qa4zJrQCg&amp;q=who+are+you+with+and+where+are+you+going&amp;oq=Who+are+you+with+and+where+are+you+going&amp;gs_l=psy-ab.1.0.0i203.53050.53050..55771...0.0..0.559.559.5-1......0....2j1..gws-wiz.nigYYAJc4jQ" target="_blank" rel="noopener">paper</a></li>
<li>MOTA(Multiple Object Tracking Accuracy), 包含了FP，FN，mismatch；from <a href="https://www.google.com/search?safe=strict&amp;ei=0ATyXP6lPIO6ggfIk6GAAQ&amp;q=evaluating+multiple+object+tracking+performance+the+clear+mot+metrics&amp;oq=Evaluating+Multiple+Object+Tracking+Performance&amp;gs_l=psy-ab.1.1.35i39j0j0i30j0i67.46576.46576..50024...0.0..0.436.436.4-1......0....2j1..gws-wiz.KAREeooiDMo" target="_blank" rel="noopener">paper</a></li>
</ul>
<p>　\(\lozenge\)　精确性(Precision)</p>
<ul>
<li>MOTP(Multiple Object Tracking Precision), from <a href="https://www.google.com/search?safe=strict&amp;ei=0ATyXP6lPIO6ggfIk6GAAQ&amp;q=evaluating+multiple+object+tracking+performance+the+clear+mot+metrics&amp;oq=Evaluating+Multiple+Object+Tracking+Performance&amp;gs_l=psy-ab.1.1.35i39j0j0i30j0i67.46576.46576..50024...0.0..0.436.436.4-1......0....2j1..gws-wiz.KAREeooiDMo" target="_blank" rel="noopener">paper</a></li>
<li>TDE(Tracking Distance Error), from <a href="https://www.google.com/search?safe=strict&amp;ei=fATyXNnwEvCH_QaG17fwDA&amp;q=%E2%80%9CTracking+with+local+spatio-temporal+motion+patterns+in+extremely+crowded+scenes&amp;oq=%E2%80%9CTracking+with+local+spatio-temporal+motion+patterns+in+extremely+crowded+scenes&amp;gs_l=psy-ab.12..0i30.82181.82181..83291...0.0..0.292.292.2-1......0....2j1..gws-wiz.hs0Je90zzHU" target="_blank" rel="noopener">paper</a></li>
<li>OSPA(optimal subpattern assignment), from <a href="https://www.google.com/search?safe=strict&amp;ei=_gDyXPKINY21ggeKtb2oDg&amp;q=a+metric+for+performance+evaluation+of+multi-target+tracking+algorithms&amp;oq=A_Metric_for_Performance_Evaluation_of_Multi-Targe&amp;gs_l=psy-ab.1.0.0i30.106502.106502..109413...0.0..0.303.303.3-1......0....2j1..gws-wiz.vrzc0MG18OM" target="_blank" rel="noopener">paper</a></li>
</ul>
<p>　\(\lozenge\)　完整性(Completeness)</p>
<ul>
<li>MT, the numbers of Mostly Tracked, from <a href="https://www.google.com/search?q=Learning+to+associate%3A+Hybridboosted+multi-target+tracker+for+crowded+scene&amp;oq=Learning+to+associate%3A+Hybridboosted+multi-target+tracker+for+crowded+scene&amp;aqs=chrome..69i57.1261j0j9&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">paper</a></li>
<li>PT, the numbers of Partly Tracked</li>
<li>ML, the numbers of Mostly Lost</li>
<li>FM, the numbers of Fragmentation</li>
</ul>
<p>　\(\lozenge\)　鲁棒性(Robustness)</p>
<ul>
<li>RS(Recover from Short-term occlusion), from <a href="https://www.google.com/search?safe=strict&amp;ei=_gDyXPKINY21ggeKtb2oDg&amp;q=A+stochastic+graph+evolution+framework+for+robust+multi-target+tracking&amp;oq=A+stochastic+graph+evolution+framework+for+robust+multi-target+tracking&amp;gs_l=psy-ab.12..0i30.453442.453442..454691...0.0..0.315.315.3-1......0....2j1..gws-wiz.OPYJ8mRFgYg" target="_blank" rel="noopener">paper</a></li>
<li>RL(Recover from Long-term occlusion)</li>
</ul>
<p>评价指标汇总： <img src="/MOT-综述-Multiple-Object-Tracking-A-Literature-Review/metrics.png" width="50%" height="50%"></p>
<h2 id="总结">5. 总结</h2>
<h3 id="还存在的问题">5.1. 还存在的问题</h3>
<p>　　MOT 算法模块较多，参数也较复杂，但是最依赖于检测模块的性能，所以算法间比较性能时，需要注意按模块进行变量控制。</p>
<h3 id="未来研究方向">5.2. 未来研究方向</h3>
<ul>
<li><strong>MOT with video adaptation</strong>，检测模块式预先训练的，需要在线更新学习；</li>
<li><strong>MOT under multiple camera</strong>: \(\circ\)　multiple views，不同视野相同场景信息的记录， \(\circ\)　non-overlapping multi-camera，不同视野不同场景的 reidentification；</li>
<li><strong>Multiple 3D object tracking</strong>，能更准确预测位置，大小，更有效处理遮挡；</li>
<li><strong>MOT with scene understanding</strong>，拥挤场景，用场景理解来有效跟踪；</li>
<li><strong>MOT with deep learning</strong></li>
<li><strong>MOT with other cv tasks</strong>，和其他任务融合，比如目标分割等；</li>
</ul>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>MOT Metrics in Academia and Industry</title>
    <url>/MOT-Metrics-in-Academia-and-Industry/</url>
    <content><![CDATA[<p>　　MOT 是一个比较基本的技术模块，在视频监控中，常用于行人行为分析、姿态估计等任务的前序模块；在自动驾驶中，MOT 是动态目标状态估计的重要环节。在学术界，MOT 算法性能的评价准则已经较为完善，其指标主要关注，尽可能地覆盖所有性能维度，以及指标的简洁性（上一篇有较多介绍，<a href="https://leijiezhang001.github.io/MOT-%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87-Evaluating-Multiple-Object-Tracking-Performance-the-CLEAR-MOT-Metrics/#more">the CLEAR MOT Metrics</a>）。而工业界则尚无统一的标准，实际的指标需求情况也比学术界复杂。<br>
　　指标的计算过程可由三部分组成，真值过滤(Filter)，匹配构建(Establishing Correspondences)与指标计算(Calculating Metrics)。其中真值过滤，更多的是工程细节，学术界没有文章对这一部分进行讨论研究。本文首先介绍学术界各评价指标详情，然后讨论工业界需要的评价指标又是怎样的。</p>
<h2 id="metrics-in-academia">1. Metrics in Academia</h2>
<p>　　在学术界，因为数据集质量较高，噪声相对较小，匹配构建中距离的度量偏向于严格且简单的方式。对于区域(框)跟踪器，采用重叠区域来度量；对于点跟踪器，采用中心点的欧式距离来度量。指标汇总如下：</p>
<p>A. <strong>检测指标</strong><br>
　\(\lozenge\)　准确性(Accuracy)</p>
<ul>
<li><strong>Recall</strong> = \(\frac{TP}{GT}\)；</li>
<li><strong>Precision</strong> = \(\frac{TP}{TP+FP}\)；</li>
<li><strong>FAF/FPPI</strong><a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a> ，Average False Alarms per Frame；False Positive Per Image;</li>
<li><strong>MODA</strong><a href="#3" id="3ref"><sup>[3]</sup></a>，Multipe Object Detection Precision，整合了 FN 与 FP，设 \(c_m, c_f\) 分别为 FN，FP 的权重： <span class="math display">\[MODA=1-\frac{\sum_{t=1}^{N_frames}(c_m(fn_t)+c_f(fp_t))}{\sum_{t=1}^{N_frames}gt_t}\]</span></li>
</ul>
<p>　\(\lozenge\)　精确性(Precision)</p>
<ul>
<li><strong>MODP</strong><a href="#3" id="3ref"><sup>[3]</sup></a>，Multiple Object Detection Accuracy， <span class="math display">\[MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; dist}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}\]</span> 其中 \(N_{mapped}^{(t)}\) 为第 \(t\) 帧匹配的目标数；\(dist\) 为距离度量方法，如框的交并比度量法： <span class="math display">\[Mapped Overlap Ratio = \frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|}\]</span></li>
</ul>
<p>B. <strong>跟踪指标</strong><br>
　\(\lozenge\)　准确性(Accuracy)</p>
<ul>
<li><strong>IDS</strong><a href="#4" id="4ref"><sup>[4]</sup></a>，ID switch，a tracked target changes its ID with another target(预测关联真值)；</li>
<li><strong>MOTA</strong><a href="#5" id="5ref"><sup>[5]</sup></a>，Multiple Object Tracking Accuracy，整合了 FN，FP，ID-Switch： <span class="math display">\[MOTA=1-\frac{\sum_{t=1}^{N_{frames}} \;\; (c_m(fn_t)+c_f(fp_t)+c_s(ID-SWITCHES_t))}{\sum_{t=1}^{N_{frames}} \;\; gt_t}\]</span> 其中权重方程一般可设为：\(c_m=c_f=1, \quad c_s=log_{10}\)；</li>
</ul>
<p>　\(\lozenge\)　精确性(Precision)</p>
<ul>
<li><strong>MOTP</strong><a href="#5" id="5ref"><sup>[5]</sup></a>，Multiple Object Tracking Precision， <span class="math display">\[MODP=\frac{\sum_{t=1}^{N_frames} \sum_{i=1}^{N_{mapped}^{(t)}} \;\; \left(\frac{\lvert G_i^{(t)}\bigcap D_i^{(t)}\rvert}{|G_i^{(t)}\bigcup D_i^{(t)}|} \right)}{\sum_{t=1}^{N_frames} N_{mapped}^{(t)}}\]</span></li>
<li><strong>TDE</strong><a href="#6" id="6ref"><sup>[6]</sup></a>，Distance between the ground-truth annotation and the tracking result；像素级别的误差计算，适用于人群跟踪；</li>
<li><strong>OSPA</strong><a href="#7" id="7ref"><sup>[7]</sup></a><a href="#8" id="8ref"><sup>[8]</sup></a>，Optimal Subpattern assignment，由定位 (localization) 误差及基数 (cardinality) 误差构成，对于第 \(t\) 帧： <span class="math display">\[e^t=\left[\frac{1}{n^t}\left( \mathop{\min}_{\pi\in\Pi_n} \sum_{i=1}^{m^t} d^{(c)}(x_i^t,y_{\pi(i)}^t)^p + (n^t-m^t)\cdot c^p \right) \right]^{1/p}\]</span> 其中，\(n^t\) 为目标真值与算法输出中数量较大者。\(\Pi_n\) 为从 \(n^t\) 中取出的 \(m\) 个目标。\(p\) 为距离指数范数。其中定位截断误差为： <span class="math display">\[d^{(c)}(x_i^t,y_{\pi(i)}^t) = \mathop{\min}\left(c,d(x_i^t,y_{\pi(i)}^t)\right)\]</span> \(c\) 为截断参数。定位误差又由距离误差和标签误差组成： <span class="math display">\[d(x_i^t,y_{\pi(i)}^t=\parallel x_i^t-y_{\pi(i)}^t\parallel + \alpha \; \bar{\delta}(l_x, l_y)\]</span> 其中 \(\alpha\in[0,c]\)，为标签误差的权重系数。如果 \(l_x=l_y\)，\(\bar{\delta}(l_x, l_y)=0\)，否则 \(\bar{\delta}(l_x, l_y)=1\).</li>
</ul>
<p>　\(\lozenge\)　完整性(Completeness)</p>
<ul>
<li><strong>MT</strong><a href="#9" id="9ref"><sup>[9]</sup></a>，Mostly Tracked，真值轨迹长度被跟踪大于80%的比例；</li>
<li><strong>ML</strong><a href="#9" id="9ref"><sup>[9]</sup></a>，Mostly Lost，真值轨迹长度被跟踪小于20%的比例；</li>
<li><strong>PT</strong><a href="#9" id="9ref"><sup>[9]</sup></a>，Partially Tracked，\(1-MT-ML\);</li>
<li><strong>FM</strong><a href="#9" id="9ref"><sup>[9]</sup></a>，Fragments，ID of a target changed along a GT trajectory, or no ID(真值关联预测)；</li>
</ul>
<p>　\(\lozenge\)　鲁棒性(Robustne)</p>
<ul>
<li><strong>RS</strong><a href="#10" id="10ref"><sup>[10]</sup></a>，Recover from short term occlusion;</li>
<li><strong>RL</strong><a href="#10" id="10ref"><sup>[10]</sup></a>，Recover from long term occlusion;</li>
</ul>
<h2 id="metrics-in-industry">2. Metrics in Industry</h2>
<p>　　工业界的数据噪声较大，传感器配置也比较多样，不同的产品（传感器+算法），对 MOT 性能维度要求也不一样。更重要的是，评价指标应该从功能层面进行定义，在模块层面 (MOT) 进行调整及细化。可以说，工业界是以学术界为基础来设计 MOT 指标的，不同的产品没有统一的标准，但有比较通用的设计准则。<br>
　　这里以自动驾驶/辅助驾驶中动态目标状态估计模块为例，模块详细分析<a href>日后再写</a>。该模块的基本输入为：</p>
<ul>
<li><strong>传感器数据</strong>，可以是图像，激光等；</li>
<li><strong><em>自定位系统</em></strong>，可以是基于视觉的 VO，基于视觉-IMU 的 VINS等；</li>
</ul>
<p>其中自定位系统能使目标状态估计在世界坐标系（惯性系）下优化，否则只能在本体（ego）非惯性系下优化，会减少一些约束量。该功能的基本输出为：</p>
<ul>
<li><strong>位置</strong>，本体坐标系下目标的三维位置，\(x,y,z\)；</li>
<li><strong>尺寸</strong>，目标的物理尺寸大小，包括立方体的长宽高；或者图像坐标系下的像素大小；或者图像/点云下目标的 mask，即分割后的目标；</li>
<li><strong><em>朝向</em></strong>，一般只考虑目标的航向角；</li>
<li><strong>速度</strong>，本体坐标系或世界坐标系下的三维速度，一般只考虑航向平面的速度；</li>
</ul>
<p>其中朝向是非必须项，有了朝向后，能更有效地进行状态优化。该模块的子模块有（注意，MOT 只包含前三者）：</p>
<ul>
<li><strong>检测(Detection)</strong>，进行多目标检测；</li>
<li><strong>跟踪(Tracking)</strong>，根据上一帧结果，进行多目标跟踪；</li>
<li><strong>数据关联(Association)</strong>，检测结果与跟踪结果的融合，出目标的 tracklets，生成 ID；</li>
<li><strong>状态估计(State Estimation)</strong>，不同的方法包括不同的部分；</li>
</ul>
<p>　　工业界设计产品时，基本遵循自顶向下的策略：产品需求-功能需求-模块需求，层层推倒。所以我们设计评价准则时，一般会问几个问题：</p>
<ul>
<li>该模块服务的产品功能，其需求及对应的指标是什么？</li>
<li>要达到功能指标，本模块的输出需要哪些指标来评测？</li>
<li>各个子模块对模块的影响是怎样的，对应需要增加哪些指标？</li>
</ul>
<p>这里提到了功能指标，模块指标，子模块指标三层概念。功能指标及部分模块指标是可以写入产品手册的，所以需要突出重点，易于理解；部分模块及子模块指标则主要是为了产品上工程优化迭代，这就要求这部分指标要相当细致，将模块的不足尽可能解耦，且完全暴露出来。以下通过两个例子来分析设计过程。</p>
<h3 id="adas-中的-fcw-功能">2.1. ADAS 中的 FCW 功能</h3>
<p>　　FCW 基本功能要求为：</p>
<ul>
<li>不允许误报，尽可能不漏报；</li>
<li>在 V km/h 下，以一定的刹车加速度 a，能避免与静止的前车相碰撞；</li>
</ul>
<p>　　由以上两个功能需求，可确定必须的功能指标：</p>
<ul>
<li>（百公里）误报率；</li>
<li>（百公里）漏报率；</li>
<li>观测距离，可由第二项功能要求推到出（人反应时间已知）；</li>
</ul>
<p>　　相应的 MOT +状态估计模块输出的指标为<strong>各距离维度各类别维度</strong>下的：</p>
<ul>
<li>误检率；</li>
<li>漏检率；</li>
<li>ID Switch；</li>
<li>定位精度；</li>
<li>速度估计精度；</li>
</ul>
<p>　　其中 MOT 主要涉及误检率，漏检率，ID Switch（直接影响状态估计模块）。这些指标的计算方式可以在学术界定义的基础上做进一步改进，比如漏检率，就需要体现出百公里漏报率的性能，所以可以考虑将连续 N 帧漏检的目标才归为漏检，分母可以定义为每多少帧。此外，要在各距离维度各类别维度下进行计算，这就涉及到过滤（filter）策略。对于 FCW 而言，首要关注的是本车前方近距离位置，距离维度上的功能重要程度要突显出来，类别维度也要区别对待，以便算法模块可以重点优化。</p>
<h3 id="自动驾驶中的动态障碍物检测功能">2.2. 自动驾驶中的动态障碍物检测功能</h3>
<p>　　自动驾驶中动态障碍物检测的要求就高了，子模块也较为复杂，指标除了评估功能模块的性能，还需要指导迭代各子模块算法，包括本子模块的迭代比较，以及上下游模块相关指标的对比。<br>
　　功能需求，我们简单列举几项：</p>
<ul>
<li>不允许漏检，尽可能不误检；</li>
<li>前向，后向，侧向观测距离分别要达到 x, y, z；</li>
</ul>
<p>　　相应的功能指标为：</p>
<ul>
<li>漏检率；</li>
<li>误检率；</li>
<li>观测距离；</li>
<li>观测精度；</li>
<li>观测时延(delay)；</li>
</ul>
<p>　　MOT +状态估计模块输出的指标依然在<strong>各距离维度各类别维度</strong>下：</p>
<ul>
<li>误检率；</li>
<li>漏检率；</li>
<li>ID Switch；</li>
<li>定位精度；</li>
<li>尺寸，朝向，速度估计精度；</li>
<li>状态估计收敛时间；</li>
<li>一系列描述时序稳定性的指标；</li>
</ul>
<p>　　与前述 FCW 功能类似，只是多了较多的指标。过滤操作也做的更加细致，我们还可以将目标做重要性等级划分，比如本车道前车多少米内，那指标基本都要达到 99%+；还可以将地面区域做重要性划分（比距离维度更加细致，可以认为是三维层面），周围几米内，那误检率肯定要非常低。除了过滤策略需要仔细设计外，匹配策略也需要进一步思考。如果传感器本身精度就有限，那么匹配策略就要相应放宽。还需注意的是引入过滤策略后，FP与FN计算的细微差别，比如有个过滤条件为去除目标像素面积小于一定阈值的目标集 A，观测值与真值匹配时，如果与 A 中的目标匹配上，那么不应该记为 FP，如果没匹配上 A 中的目标，那么 A 中地目标也不应该被记为 FN。这种类似的情况逻辑要思考清楚。</p>
<h2 id="summary">3. Summary</h2>
<p>　　以上设计的出发点是，我们要承认<strong>算法的不完美性</strong>以及<strong>传感器的局限性</strong>，在工程领域，一定要首先解决主要矛盾，再打磨细节。本文还对以下内容未作进一步分析（以后有机会再写文细究）：</p>
<ul>
<li>状态估计时序相关指标，描述估计的时序稳定性，也可以用于 MOT 的评估；</li>
<li>标注与过滤策略的关系，过滤策略往往依赖于标注策略；</li>
<li>各个指标的阈值确定，确定阈值也是产品中一件重要而又系统的事，有时候比指标设计更复杂； 　　</li>
</ul>
<p><a id="1" href="#1ref">[1]</a> Yang B, Huang C, Nevatia R. <a href="https://scholar.google.com/scholar?lookup=0&amp;q=Learning+affinities+and+dependencies+for+multi-target+tracking+using+a+CRF+model&amp;hl=zh-CN&amp;as_sdt=0,5&amp;as_vis=1" target="_blank" rel="noopener">Learning affinities and dependencies for multi-target tracking using a CRF model</a>[C]//CVPR 2011. IEEE, 2011: 1233-1240.<br>
<a id="2" href="#2ref">[2]</a> Choi W, Savarese S. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=Multiple+target+tracking+in+world+coordinate+with+single%2C+minimally+calibrated+camera&amp;btnG=" target="_blank" rel="noopener">Multiple target tracking in world coordinate with single, minimally calibrated camera</a>[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 553-567.<br>
<a id="3" href="#3ref">[3]</a> Kasturi, Rangachar, et al. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=Framework+for+performance+evaluation+of+face%2C+text%2C+and+vehicle+detection+and+tracking+in+video%3A+Data%2C+metrics%2C+and+protocol&amp;btnG=" target="_blank" rel="noopener">Framework for performance evaluation of face, text, and vehicle detection and tracking in video: Data, metrics, and protocol</a> IEEE transactions on Pattern Analysis and Machine intelligence 31.2 (2008): 319-336.<br>
<a id="4" href="#4ref">[4]</a> Yamaguchi K, Berg A C, Ortiz L E, et al. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=who+are+you+with+and+where+are+you+going&amp;btnG=" target="_blank" rel="noopener">Who are you with and where are you going?</a>[C]//CVPR 2011. IEEE, 2011: 1345-1352.<br>
<a id="5" href="#5ref">[5]</a> Bernardin K, Stiefelhagen R. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=evaluating+multiple+object+tracking+performance+the+clear+mot+metrics&amp;btnG=" target="_blank" rel="noopener">Evaluating multiple object tracking performance: the CLEAR MOT metrics</a>[J]. Journal on Image and Video Processing, 2008, 2008: 1.<br>
<a id="6" href="#6ref">[6]</a> Kratz L, Nishino K. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=%E2%80%9CTracking+with+local+spatio-temporal+motion+patterns+in+extremely+crowded+scenes&amp;btnG=" target="_blank" rel="noopener">Tracking with local spatio-temporal motion patterns in extremely crowded scenes</a>[C]//2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition. IEEE, 2010: 693-700.<br>
<a id="7" href="#7ref">[7]</a> Ristic B, Vo B N, Clark D, et al. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=a+metric+for+performance+evaluation+of+multi-target+tracking+algorithms&amp;btnG=" target="_blank" rel="noopener">A metric for performance evaluation of multi-target tracking algorithms</a>[J]. IEEE Transactions on Signal Processing, 2011, 59(7): 3452-3457.<br>
<a id="8" href="#8ref">[8]</a> Schuhmacher D, Vo B T, Vo B N. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=A+Consistent+Metric+for+Performance+Evaluation+of+Multi-Object+Filters&amp;btnG=" target="_blank" rel="noopener">A consistent metric for performance evaluation of multi-object filters</a>[J]. IEEE transactions on signal processing, 2008, 56(8): 3447-3457.<br>
<a id="9" href="#9ref">[9]</a> Li Y, Huang C, Nevatia R. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=Learning+to+associate%3A+Hybridboosted+multi-target+tracker+for+crowded+scene&amp;btnG=" target="_blank" rel="noopener">Learning to associate: Hybridboosted multi-target tracker for crowded scene</a>[C]//2009 IEEE Conference on Computer Vision and Pattern Recognition. IEEE, 2009: 2953-2960.<br>
<a id="10" href="#10ref">[10]</a> Song B, Jeng T Y, Staudt E, et al. <a href="https://scholar.google.com/scholar?hl=zh-CN&amp;as_sdt=0%2C5&amp;as_vis=1&amp;q=A+stochastic+graph+evolution+framework+for+robust+multi-target+tracking&amp;btnG=" target="_blank" rel="noopener">A stochastic graph evolution framework for robust multi-target tracking</a>[C]//European Conference on Computer Vision. Springer, Berlin, Heidelberg, 2010: 605-619.</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Point-based 3D Detetection</title>
    <url>/Point-based-3D-Det/</url>
    <content><![CDATA[<p>　　基于激光点云的 3D 目标检测是自动驾驶系统中的核心感知模块。由于点云的稀疏性以及空间结构的无序性，一系列 Voxel-based 3D 检测方法得以发展：<a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a>，<a href="/paperreading-Fast-and-Furious/" title="FaF">FaF</a>，<a href="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/" title="MVF">MVF</a> 等。然而 Voxel-based 方法需要预定义空间栅格的分辨率，其特征提取的有效性依赖于空间分辨率。同时在点云语义分割领域，对点云的点级别特征提取方法研究较为广泛，<a href="/PointCloud-Feature-Extraction/" title="PointCloud Feature Extraction">PointCloud Feature Extraction</a> 中已经较详细的介绍了针对点云的点级别特征提取方法，<a href="/paper-reading-Grid-GCN-for-Fast-and-Scalable-Point-Cloud-Learning/" title="Grid-GCN">Grid-GCN</a> 提出了几种策略来加速特征提取。<br>
　　由此高效的 Point-based 3D 检测方法成为可能，这种方法首先提取点级别的特征(相比 Voxel-based，理论上没有信息损失)，然后用点级别的 Anchor-based 或 Anchor-free 方法作 3D 检测。</p>
<h2 id="anchor-based">1. Anchor-based</h2>
<h3 id="ipod1">1.1. IPOD<a href="#1" id="1ref"><sup>[1]</sup></a></h3>
<p><img src="/Point-based-3D-Det/ipod.png" width="90%" height="90%" title="图 1. IPOD Framework"> 　　如图 1. 所示， IPOD 与 F-PointNet 类似，只不过 IPOD 在俯视图下生成 Proposal 取点，而 F-PointNet 是直接在锥形视野的点云中作分割。IPOD 由三部分组成：</p>
<ol type="1">
<li><strong>Semantic Segmentation</strong><br>
目的是将点云中的背景点过滤掉，只生成前景点的 Anchor。作者采用图像语义分割的方法，这里也可直接用点云分割来做；</li>
<li><strong>Point-based Proposal Generation</strong><br>
生成点级别的候选框，去掉冗余的候选框；</li>
<li><strong>Head for Classification and Regression</strong><br>
根据候选框，提取特征，作分类和回归；</li>
</ol>
<p>这里的前两步是要得到少量但又能保证召回率的 Proposal，其中 Anchor 是根据每个点来设置的，然后作 NMS 操作，这里不做展开。 <img src="/Point-based-3D-Det/proposal_feat.png" width="80%" height="80%" title="图 2. Proposal Feature Generation"> 　　如图 2. 所示，每个 Proposal 提取出点云信息，然后通过 PointNet++ 直接来预测该 Proposal 的 3D 属性。这里用到了 T-Net(Spatial Transformation Network 的一种) 将点云变换到规范坐标系(Canonical coordinates)，这个套路用的也比较多。其它细节就是正常的 3D 属性回归策略，不作展开。</p>
<h3 id="std2">1.2. STD<a href="#2" id="2ref"><sup>[2]</sup></a></h3>
<p><img src="/Point-based-3D-Det/STD.png" width="80%" height="80%" title="图 3. STD Framework"> 　　如图 3. 所示，STD 模块有：</p>
<ol type="1">
<li><strong>Backbone</strong><br>
用 PointNet++ 提取点级别特征以及作点级别的 Classification；</li>
<li><strong>PGM(Proposal Generation Module)</strong><br>
根据点级别的分类结果，对目标点设计球状 Spherical Anchor；不同类别设计不同的球状 Anchor 半径。将球状 Anchor 里面的点收集起来，作坐标规范化并且 concate 点级别特征，然后用 PointNet 来预测实际的矩形 proposal：包括中心 Offsets 以及 size offsets。同时对角度进行预测，角度预测通过分类加预测 Offsets 实现。</li>
<li><strong>Proposal Feature Generation</strong><br>
有了 proposal 后，其实可以直接通过 PointNet 作进一步的预测及分类，但是作者为了加速，这时候采用了 Voxel Feature Encoding。将 proposal 里面的点都转换到中心点坐标系，然后栅格化提取特征；</li>
<li><strong>Box Prediction</strong><br>
除了通常的类别预测以及 3D Box 相关属性的 Offsets 预测，作者还加入了与真值的 IoU 预测，该 IoU 值与类别分数相乘作为最终的该预测分数(这个在 2D Detection 中已经有应用)。</li>
</ol>
<h2 id="anchor-free">2. Anchor-free</h2>
<h3 id="pointrcnn3">2.1. PointRCNN<a href="#3" id="3ref"><sup>[3]</sup></a></h3>
<p><img src="/Point-based-3D-Det/PointRCNN.png" width="80%" height="80%" title="图 4. PointRCNN Framework"> 　　如图 4. 所示，PointRCNN 是一个 two-stage 3D 检测方法，类似 Faster-RCNN，其由 Bottom-up 3D Proposal Generation 和 Canonical 3D Box Refinement 两个模块组成。</p>
<h4 id="bottom-up-3d-proposal-generation">2.1.1 Bottom-up 3D Proposal Generation</h4>
<p>　　Proposal 的生成要求是，数量少，召回率高。3D Anchor 由于要覆盖 3D 空间，所以数量会很大(如 AVOD)，本文采用目标点生成 Proposal 的方法。与 IPOD，STD 类似，首先对点云进行点级别的特征提取并作前景分割(或语义分割)，对前景的每个点用 Bin-based 方法生成 3D proposal。由此在生成尽量少的 Proposal 下，保证目标的高召回率。<br>
　　点级别的特征提取及前景分割，可以采用任意的语义分割网络，这里前景的真值即为目标框内的点云，用 Focal Loss 来平衡正负样本。<br>
<img src="/Point-based-3D-Det/bin-based.png" width="60%" height="60%" title="图 5. Bin-based Localization"> 　　如图 5. 所示，对每个前景点用 Bin-based 方法生成 proposal。将平面的 \(x,z\) (与一般的雷达坐标系不同) 方向分成若干个 bin，然后对每个前景点，预测目标中心点属于哪个 bin，以及中心点与该 bin 的 Offsets(与角度处理的方式非常像)。针对尺寸，预测该类别平均尺寸的 Residual；针对角度，还是分解成分类加回归任务进行处理。最后再作 NMS 即可得到较少的 Proposal，给到下一模块作 refine。本模块的 Loss 设计为： <span class="math display">\[\begin{align}
\mathcal{L} _ 1 &amp;= \mathcal{L} _ {seg} + \mathcal{L} _ {proposal} \\
&amp;= \mathcal{L} _ {seg} + \frac{1}{N _ {pos}} \sum _ {p\in pos} \left(\mathcal{L} _ {bin} ^ {(p)} + \mathcal{L} _ {res} ^ {(p)}\right) \\
&amp;= \mathcal{L} _ {seg} + \sum _ {u\in{\{x,z,\theta\}}} \left(\mathcal{F} _ {cls}(\widehat{bin} _ u^{(p)}, bin _ u^{(p)})+\mathcal{F} _ {reg}(\widehat{res} _ u^{(p)}, res _ u^{(p)})\right) + \sum _ {v\in\{y,h,w,l\}} \mathcal{F} _ {reg}(\widehat{res} _ v^{(p)}, res _ v^{(p)})\\
\tag{1}
\end{align}\]</span> 其中 \(\mathcal{F} _ {cls}, \mathcal{F} _ {reg}\) 分别为 cross-entropy Loss 和 smooth L1 Loss。</p>
<h4 id="canonical-3d-box-refinement">2.1.2 Canonical 3D Box Refinement</h4>
<p>　　有了 3D proposal 后，经过 Point Cloud Region Pooling 提取该 proposal 的点特征，步骤如下：先对 proposal 进行一定程度的扩大，然后提取内部点的 semantic features，foreground mask score，Point distance等。由此获得每个 proposal 的点及点特征，用来作 3D Box Refinement。<br>
<img src="/Point-based-3D-Det/canonical.png" width="60%" height="60%" title="图 6. Canonical Transformation"> 　　如图 4. 所示，为了更好的学习 proposal 的局部空间特征，增加每个 proposal 在自身 Canonical 坐标系下的空间点。Canonical 变换如图 6. 所示，因为这里每个 proposal 的位置及角度已经有了，所以直接对其内的点作变换。如果没有，那就需要 STN(T-Net) 来学习这个变换。<br>
　　Loss 也是在 Canonical 坐标系下计算的，假设 proposal：\(\mathrm{b _ i} = (x _ i,y _ i,z _ i,h _ i,w _ i,l _ i,\theta _ i)\)，真值: \(\mathrm{b} _ i^{gt} = (x _ i^{gt}, y _ i^{gt},z _ i^{gt},h _ i^{gt},w _ i^{gt},l _ i^{gt},\theta _ i^{gt})\)。那么两者变换到 Canonical 坐标系后： <span class="math display">\[\begin{align}
\mathrm{\tilde{b}} _ i &amp;=(0,0,0,h _ i,w _ i,l _ i,0) \\
\mathrm{\tilde{b}} _ i^{gt} &amp;= (x _ i^{gt}-x _ i, y _ i^{gt}-y _ i,z _ i^{gt}-z _ i,h _ i^{gt},w _ i^{gt},l _ i^{gt},\theta _ i^{gt}-\theta _ i)
\tag{2}
\end{align}\]</span> 对于中心点，还是 bin 分类加 Residual 回归，但是可以减少 bin 的尺度；对于尺寸，还是回归 Residual；对于角度，由于限定 positive 与 gt 的 IoU&gt;0.55，所以可以将回归的角度限定为 \((-\frac{\pi}{4},\frac{\pi}{4})\) 的范围，由此进行 bin 分类及 Residual 回归。最终本阶段的 Loss 为： <span class="math display">\[ \mathcal{L} _ 2= \frac{1}{N _ {pos}+ N _ {neg}} \sum _ {p\in all} \mathcal{L} _ {label} ^{(p)}+ \frac{1}{N _ {pos}} \sum _ {p\in pos} \left(\mathcal{\tilde{L}} _ {bin} ^ {(p)} + \mathcal{\tilde{L}} _ {res} ^ {(p)}\right) \tag{3}\]</span></p>
<h3 id="dssd4">2.2. 3DSSD<a href="#4" id="4ref"><sup>[4]</sup></a></h3>
<p><img src="/Point-based-3D-Det/3DSSD.png" width="100%" height="100%" title="图 7. 3DSSD Framework"> 　　如图 7. 所示，3DSSD 是 one-stage 网络，由 Backbone，Candidate Generation Layer，Head 构成。Backbone 作者提出了 Fusion Sampling 以提升前景点在采样时候的召回率。Candidate Generation Layer 中根据前景点，生成 3D box 预测的 Candidate 锚点。最后 Head 根据锚点，作 Anchor-free 的 3D Box 预测。</p>
<h4 id="fusion-sampling">2.2.1 Fusion Sampling</h4>
<p>　　为了扩大感受野提取局部特征，点云通常需要作下采样处理，一般采用 D-FPS 方法(点空间距离作为采样度量)，但是这样会使前景点大量丢失。前面几种方法不管是用图像分割还是点云分割，都会去除背景点云，保留前景点云以提高生成 Proposal 的召回率。<br>
　　这里作者提出了 Feature-FPS，加入特征间的距离作为采样的度量方式。对于地面等背景，其特征基本类似，所以很容易就去除了；而对于目标区域，其点特征都不太一样，又得以保留。如果只保留同一目标的点，也会产生冗余，所以融合点特征距离及空间距离，设计采样度量方式为： <span class="math display">\[ C(A,B) = \lambda L _ d(A,B) + L _ f(A,B) \tag{4}\]</span> 　　因为 F-FPS 去除了大量的背景点，虽然有利于回归，但是不利于分类，所以设计了融合 D-FPS 和 F-FPS 的 Fusion Sampling 方法。如图 7. 所示，最终分别输出 F-FPS 与 D-FPS 的特征点。</p>
<h4 id="candidate-generation-layer">2.2.2 Candidate Generation Layer</h4>
<p><img src="/Point-based-3D-Det/candidate_pts.png" width="60%" height="60%" title="图 8. Candidate Generation"> 　　如图 8. 所示，根据 F-FPS 采样的点，在真值框中心点的监督下，用一个 T-Net 去学习采样点与中心点的变换。变换后的点即作为 Candidate 锚点。对每个 Candidate 点提取周围一定距离的 F-FPS 与 D-FPS(大量背景点利于分类)中点集的特征(空间坐标作归一化或变换到 Candidate 坐标系，类似 Canonical 坐标系)，然后作 MaxPool 提取该 Candidate 对应区域的特征。</p>
<h4 id="prediction-head">2.2.3 Prediction Head</h4>
<p>　　对于每个 Candidate 特征，作 3D Box 属性的回归。本文采用 Anchor-free 的方法。对于中心点，直接回归 Candidate 坐标点与真值框中心点的 Offsets；对于尺寸，直接回归与该类别平均尺寸的 Residual；对于角度，还是采用 bin 分类加 Residual 回归的策略。<br>
　　这里期望的是 Candidate 点能接近目标框中心点，所以作者借鉴 FCOS(详见 <a href="/Anchor-Free-Detection/" title="Anchor-Free Detection">Anchor-Free Detection</a>)中的 Center-ness Loss 来选取靠近中心点的 Candidate，真值 Label 为: <span class="math display">\[l _ {ctrness}=\sqrt[3]{\frac{\mathrm{min}(f,b)}{\mathrm{max}(f,b)}+\frac{\mathrm{min}(l,r)}{\mathrm{max}(l,r)}+\frac{\mathrm{min}(t,d)}{\mathrm{max}(t,d)}} \tag{5}\]</span> 其中 \(f,b,l,r,t,d\) 分别表示前后左右上下与中心点的距离。FCOS 中，加了一个与分类平行的分支来预测 Center-ness，最终的预测 Score 是分类 Score 乘以 Center-ness 得到(与预测 IoU 套路一样，本质上都是引入与真值的距离度量)，该预测 Score 用于之后的 NMS 等处理。本文则没有显示的预测 Center-ness，其直接将真值 Center-ness 与真值类别相乘，作为类别真值，所以一个类别分支即得到最终的预测 Score。<br>
　　最终的 Loss 为： <span class="math display">\[L = \frac{1}{N _ c}\sum _ iL _ c(s _ i, u _ i) + \lambda _ 1\frac{1}{N _ p}\sum _ i[u _ i&gt;0]L _ r + \lambda _ 2\frac{1}{N _ p}L _ s \tag{5}\]</span> 其中 \(s _ i\) 为预测的类别 Score，\(u _ i\) 为经过 Center-ness 处理后的类别真值；\(L _ c\) 表示类别预测 Loss；\(L _ r\) 表示 3D Box Loss，包括中心点距离，尺寸，角度，8个角点位置；\(L _ s\) 表示生成 Candidate 点的 shift 变换 Loss。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Yang, Zetong, et al. &quot;Ipod: Intensive point-based object detector for point cloud.&quot; arXiv preprint arXiv:1812.05276 (2018).<br>
<a id="2" href="#2ref">[2]</a> Yang, Zetong, et al. &quot;Std: Sparse-to-dense 3d object detector for point cloud.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2019.<br>
<a id="3" href="#3ref">[3]</a> Shi, Shaoshuai, Xiaogang Wang, and Hongsheng Li. &quot;Pointrcnn: 3d object proposal generation and detection from point cloud.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="4" href="#4ref">[4]</a> Yang, Zetong, et al. &quot;3DSSD: Point-based 3D Single Stage Object Detector.&quot; arXiv preprint arXiv:2002.10187 (2020).</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>OctoMap</title>
    <url>/OctoMap/</url>
    <content><![CDATA[<p>　　地图是机器人领域非常重要的模块，也可以认为是自动驾驶保障安全的基础模块。根据存储建模类型，地图可分为拓扑地图，栅格地图，点云地图等。<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 就是一种能在线检测静态障碍物的栅格地图。自动驾驶领域，地图的用处有：</p>
<ul>
<li><strong>高精度定位</strong>，一般是 3D 栅格地图，但是栅格中近似存储点云原始信息；</li>
<li><strong>路径规划</strong>，不同规划算法依赖不同地图，自动驾驶中比较靠谱又简单的规划算法一般依赖拓扑地图，俗称高精度语义地图，描述一些车道线等路面拓扑关系；而在室内或低速无道路信息场景，则会用如 \(A ^ * \) 算法在栅格地图上进行路径规划；</li>
<li><strong>辅助感知检测未定义类别的障碍物</strong>，有人称之为静态地图，一般是 2.5D 栅格地图，图层可以自定义一些语义信息；</li>
</ul>
<p>下游不同模块对不同存储方式的利用效率是不同的，所以需要针对不同下游任务设计不同地图建模方式。本文<a href="#1" id="1ref"><sup>[1]</sup></a>介绍了一种基于八叉树的栅格地图建模方法。<br>
　　对于机器人而言，类似 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 能建模 FREE，OCCUPIED，UNMAPPED AREAS 的地图是信息量比较丰富的，但是 Grid-Mapping 是 2D 的。这里对 3D 地图有以下要求：</p>
<ul>
<li><strong>Probabilistic Representation</strong><br>
测量都会有不确定性，这种不确定性需要用概率表征出来；另外多传感器融合也需要基于概率的表示；</li>
<li><strong>Modeling of Unmapped Areas</strong><br>
对机器人导航而言，显式得表示哪些区域是观测未知的也非常重要；</li>
<li><strong>Efficiency</strong><br>
地图构建与存储需要非常高效，一般而言，地图的内存消耗会是瓶颈；</li>
</ul>
<p><img src="/OctoMap/maps.png" width="90%" height="90%" title="图 1. Different Representations of Maps"> 　　如图 1. 所示，原始点云地图信息量丰富，但是不能结构化存储；Elevation Maps 与 Multi-level Surface Maps 虽然高效，但是不能表征未观测的区域信息。OctoMap 可以认为是 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 的 3D 版本，信息量丰富且高效。</p>
<h2 id="octomap-mapping-framework">1. OctoMap Mapping Framework</h2>
<h3 id="octrees">1.1. Octrees</h3>
<p><img src="/OctoMap/OctoMap.png" width="40%" height="40%" title="图 2. 八叉树地图存储"> 　　如图 2. 所示，八叉树是将空间递归得等分成八份(QuadTree 四叉树则等分为四份)，每个节点可以存储 Occupied，Free，Unknown 信息(Occupied 概率即可)。此外，如果子节点的状态都一样，那么可以进行剪枝，只保留大节点低分辨率的 Voxel，达到紧凑存储的目的。<br>
　　时间复杂度上，对于有 \(n\) 个节点，深度为 \(d\) 的八叉树，那么单次查询的时间复杂度为 \(\mathcal{O}(d)=\mathcal{O}(\mathrm{log}\,n)\)；遍历节点的时间复杂度为 \(\mathcal{O}(n)\)。\(d = 16, r = 1cm\)，可以覆盖 \((655.36m)^3\)的区域。</p>
<h3 id="probabilistic-sensor-fusion">1.2. Probabilistic Sensor Fusion</h3>
<p>　　时序概率融合也是基于贝叶斯滤波，详见 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a>，只不过这里是 3D Mapping，作 Raycasting 的时候采用 <a href="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/" title="What You See is What You Get">What You See is What You Get</a> 中提到的 Fast Voxel Traversal 算法。实际应用中，一般都会采用上下界限制概率值，这种限制也能提高八叉树的剪枝率。</p>
<h3 id="multi-resolution-queries">1.3. Multi-Resolution Queries</h3>
<p>　　由于八叉树的特性，OctoMap 支持低于最高分辨率的 Voxel 概率查询，即父节点是子节点的平均概率，或是子节点的最大概率: <span class="math display">\[
\bar{l}(n)=\frac{1}{8}\sum _ {i=1}^8 L (n _ i)\\
\hat{l}(n)=\max\limits _ iL(n _ i)
\tag{1}\]</span> 其中 \(l\) 是测量模型下概率的 log-odds 值。</p>
<h2 id="implementation-details-statics">2. Implementation Details &amp; Statics</h2>
<h3 id="memory-efficient-node-map-file-generation">2.1. Memory-Efficient Node &amp; Map File Generation</h3>
<p><img src="/OctoMap/save.png" width="60%" height="60%" title="图 3. Node Memory Consumption and Serialization"> 　　如图 3. 左图所示，每个节点只分配一个 float 型的数据存储以及指向子节点地址数组的地址指针(而不是直接包含子节点地址的指针)，只有存在子节点时，才会分配子节点的地址数组空间。由此在 32-bit 系统中(4 字节对齐)，每个父节点需要 40B，子节点需要 8B；在 64-bit 系统中(8 字节对齐)，每个父节点需要 80B(\(4+9\times 8\))，子节点需要 16B(\(4+8)\)。<br>
　　地图存储需要在信息量损失最小的情况下进行压缩。如图 3. 右图所示，存储序列化时，每个叶子节点总共需要 4B 概率值，不需要状态量；每个父节点总共需要 2B，表示 8 个子节点的 2bit 状态量(貌似与论文有出入，其不是最优的压缩)。在这种压缩方式下，大范围地图的存储大小一般也能接受。根据存储的地图重建地图时，只需要知道坐标原点即可。</p>
<h3 id="accessing-data-memory-consumption">2.2. Accessing Data &amp; Memory Consumption</h3>
<p><img src="/OctoMap/memusage1.png" width="60%" height="60%" title="图 4. Memory Usage VS. Scan Num."> 　　Freiburg 建图大小为 \((202\times 167\times 28) m^3\)，如图 4. 所示，随着点云扫描区域扩大，OctoMap 表示方式能有效降低建图大小。 <img src="/OctoMap/memusage2.png" width="60%" height="60%" title="图 5. Memory Usage VS. Resolution"> 　　图 5. 则说明建图大小与分辨率的关系。 <img src="/OctoMap/inserttime.png" width="60%" height="60%" title="图 6. Insert Date Time VS. Resolution"> <img src="/OctoMap/traversetime.png" width="60%" height="60%" title="图 7. Traverse Data Time VS. Depth"> 　　图 6. 显示了往图中插入一个节点所需时间，1000 个节点在毫秒级；图 7. 显示了遍历所有节点所需的时间，基本也在毫秒级。 <img src="/OctoMap/compress.png" width="60%" height="60%" title="图 8. Compression Ratio"> 　　通过限制概率上下界，可以剪枝压缩图，用 KL-diverge 来评估压缩前后图的分布相似性，图 8. 显示了压缩比与网络大小及相似性的关系。</p>
<h3 id="some-strategies">2.3. Some Strategies</h3>
<p><img src="/OctoMap/case.png" width="60%" height="60%" title="图 9. Corner Case Handle"> 　　如图 9. 所示，前后帧位姿的抖动，会导致 Occupied 持续观测的不稳定，所以需要一些领域约束策略来保证 Occupied 的稳定观测。这种类似的策略在 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 工程实现中也需要采用，因为实际的 Pose 肯定会有噪声，导致同一目标的栅格前后有一定概率不能完全命中。</p>
<h2 id="rethinking">3. ReThinking</h2>
<p>　　对于自动驾驶来说，高度方向的范围不需要很大，甚至四叉树足矣，如果采用八叉树，那么需要将高度方向的分辨率降低，从而更加紧凑的构建地图。<br>
　　此外自动驾驶肯定是需要大范围建图的，如平方千公里级别。所以切片式的地图存储与查询就显得尤为重要，换句话说，需要动态得载入局部地图，这就有两种思路：</p>
<ul>
<li>动态载入完全局部地图<br>
要求前后局部地图有一定的重叠，通过索引式的存储可以不存储重叠区域的地图信息；</li>
<li>动态载入部分局部地图<br>
随着机器人本体的运动，实时动态载入前方更远处的地图，丢掉后方远处的历史地图。这对在线地图结构的灵活性要求比较高，如果基于八叉树，那么需要作片区域剪枝及插入的操作，效率不一定高；</li>
</ul>
<p>　　在自动驾驶领域，目前用于高精度定位的栅格地图与用于 PNC 规划控制的拓扑地图(高精地图)已经比较成熟；而用于环境感知的静态语义地图还没形成大范围的共识。不管从工程实现效果及效率上，还是语义信息描述定义上，还需作很多探索与实践。比如，可以定义最底层的语义信息：地面高度，此外也可以把车道线信息打到栅格图层中去(但是可能加大对 PNC 的搜索计算量)，等等。所以可能最优的存储查询方式并不是八叉树，<strong>可能还是栅格化后并对每个栅格哈希化，牺牲一定的内存空间，然后作 \(O(1)\) 的快速插入与查询</strong>。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Hornung, Armin, et al. &quot;OctoMap: An efficient probabilistic 3D mapping framework based on octrees.&quot; Autonomous robots 34.3 (2013): 189-206.</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>Point Cloud</tag>
        <tag>SLAM</tag>
        <tag>Mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>PointCloud Feature Extraction</title>
    <url>/PointCloud-Feature-Extraction/</url>
    <content><![CDATA[<p>　　机器学习中，特征提取是非常重要的一个环节（认为是最重要的一环也不为过）。对图像数据的特征提取操作已经较为成熟，如卷积；而点云数据由于无序性，所以对其进行高效的特征提取则比较困难。 一个好的点云特征提取操作需要具备以下特征：</p>
<ul>
<li>能提取点云的<strong>局部以及全局特征</strong>；</li>
<li>计算高效；</li>
</ul>
<p>　　目前已知的点云特征提取方法可分为两大类：Voxel-level，以及 Point-level。Voxel-Level 的特征提取也已经相当成熟，基本思路是将点云空间网格化，每个网格进行手工特征填充或者 Point-level 的特征提取，然后就可以应用标准的 2D/3D 卷积操作进行局部及全局特征提取。这种方法提取的特征细粒度取决于空间栅格化的分辨率，针对点级别的任务（如 semantic segmentation，Scene flow等），其特征的细粒度还是不够的。<br>
　　本文主要介绍 Point-level 的方法，这种方法能提取点级别的局部、全局特征信息，是处理点云的有效手段。这种方法首先要将无序的点云进行一定的结构化组织，由此可分为若干方法，如下阐述。</p>
<h2 id="基于原始三维空间操作">1. 基于原始三维空间操作</h2>
<p>　　在三维空间下进行点的局部特征提取，需要快速找到每个点周围的点，所以需要对点云构建 Kd-tree(或 Ball-tree)，来加速邻近点的快速查询。Kd-tree 的算法复杂度为：</p>
<ul>
<li>构建：\(\mathcal{O}(\mathrm{log}^2n)\)</li>
<li>插入：\(\mathcal{O}(\mathrm{log}n)\)</li>
<li>删除：\(\mathcal{O}(\mathrm{log}n)\)</li>
<li>查询：\(\mathcal{O}(n^{1-\frac{1}{k}}+m)\)，其中 \(m\) 为要查询的最近点个数</li>
</ul>
<h3 id="问题描述">1.1. 问题描述</h3>
<p>　　设点云集合：\(P=\{p_1,...,p_n\}\in R^{F}\)，每个点有 \(F\) 维的特征，以及每个点的三维坐标为：\(p_i=(x_i,y_i,z_i)\)（注意，坐标也可作为特征包含于 \(F\) 维中）。因为点云的无序性，定义点云集合的最近邻图(k-nearest neighbor graph) \(\mathcal{G=(V,E)}\)，其中 \(\mathcal{V}\) 表示点云中的点，\(\mathcal{E}\) 表示点 \(p_i\) 与最近的 \(k\) 个点 \(P_i^k=\{p_j ^ {i1},...,p_j ^ {ik}\}\) 所构成的有向边集合 \(\{(i,j_{i1}),...,(i,j_{ik})\}\)。由此定义<strong>点级别特征提取操作</strong>： <span class="math display">\[ p_i&#39; = \displaystyle\Box_{j:(i,j)\in\mathcal{E}} h_\Theta(p_i,p_j) \tag{1}\]</span> 其中 \(h _ {\Theta}\) 表示非线性映射函数，将特征空间：\(\mathbb{R} ^ F \times \mathbb{R} ^ F \to \mathbb{R} ^ {F'}\)；\(\Box\) 为用于特征聚合的对称函数。该操作类似图像二维卷积操作，将输入的点云集合：\(P=\{p_1,...,p_n\}\in R^{F}\) 映射到相同点数的：\(P'=\{p_1',...,p_n'\}\in R^{F'}\)。</p>
<h3 id="hbox-的选择">1.2. \(h,\Box\) 的选择</h3>
<h4 id="euclidean-conv">1.2.1. Euclidean Conv</h4>
<p>　　设计 \(h_{\Theta}(p_i,p_j)=\theta_jp_j\)，\(\Box=\sum\)，得到传统的 Euclidean convolution： <span class="math display">\[ p_i&#39; = \displaystyle\sum_{j:(i,j)\in\mathcal{E}}(\theta_jp_j) \tag{2}\]</span> 其中 \(\Theta=(\theta_i,...,\theta_k)\) 为滤波器的权重。</p>
<h4 id="pointnet1">1.2.2. PointNet<a href="#1" id="1ref"><sup>[1]</sup></a></h4>
<p>　　设计 \(h_{\Theta}(p_i,p_j)=h_{\Theta}(p_i) = \mathrm{MLP}(p_i)\)，\(\Box=\mathrm{MAX} 或 \sum\)，得到 PointNet 中的操作： <span class="math display">\[ p_i&#39; = \displaystyle\left\{ \sum|\mathrm{MAX}\right\}(\theta_ip_i) = \displaystyle\left\{\sum|\mathrm{MAX}\right\}\, \mathrm{MLP}(p_i) \tag{3}\]</span> 感知机的权重可以共享。</p>
<h4 id="deep-parametric-continuous-convoluion2">1.2.3. Deep Parametric Continuous Convoluion<a href="#2" id="2ref"><sup>[2]</sup></a></h4>
<p>　　设计 \(h_{\Theta}(p_i,p_j)=\mathrm{MLP}(p_j^{xyz}-p _ i^{xyz})\cdot p _ j^{\mathrm{exclude}\,xyz}\)，\(\Box=\mathrm{\sum}\)，得到 Deep Parametric Continuous Convolution 操作： <span class="math display">\[ p_i&#39; = \displaystyle\sum_{j:(i,j)\in\mathcal{E}}\left(\mathrm{MLP}(p_j^{xyz}-p _ i^{xyz})\cdot p _ j^{\mathrm{exclude}\,xyz}\right) \tag{4}\]</span> 根据邻近点的距离，显示的来学习其对中心点的特征贡献。Continuous Fusion Layer 中证明没必要显示的学习，直接将相对距离 Concate 到特征上，隐式的学习同样有效。</p>
<h4 id="pointnet3flownet3d4continuous-fusion-layer5">1.2.4. PointNet++<a href="#3" id="3ref"><sup>[3]</sup></a>/FlowNet3D<a href="#4" id="4ref"><sup>[4]</sup></a>/Continuous Fusion Layer<a href="#5" id="5ref"><sup>[5]</sup></a></h4>
<p>　　设计 \(h _ {\Theta}(p_i,p_j)=\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus (p _ j ^ {xyz}-p _ i^{xyz})\right)\)，\(\Box=\left\{\mathrm{MAX}|\sum\right\}\)，得到 PointNet++/FlowNet3D/Continuous Fusion Layer(前两者是 \(\mathrm{MAX}\)，后者是 \(\sum\) 操作) 中的操作： <span class="math display">\[ p_i&#39; = \displaystyle\left\{\mathrm{MAX}|\sum\right\}_{j:(i,j)\in\mathcal{E}}\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus (p _ j ^ {xyz}-p _ i^{xyz})\right) \tag{5}\]</span> 将点 \(p_j\) 中的坐标都转换到以中心点 \(p_i\) 为参考的局部坐标。这样能更好的提取局部信息，但是丢失了点的绝对坐标信息。</p>
<h4 id="edgeconvdgcnn6">1.2.5. EdgeConv(DGCNN)<a href="#6" id="6ref"><sup>[6]</sup></a></h4>
<p>　　设计 \(h _ {\Theta}(p_i,p_j)=\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus (p _ j ^ {xyz}-p _ i^{xyz})\oplus p _ i^{xyz}\right)\)(这里只是猜测是这么做的，EdgeConv paper 中没有具体说怎么做的)，\(\Box=\mathrm{MAX}\)，得到 EdgeConv 中的操作： <span class="math display">\[ p_i&#39; = \displaystyle\mathrm{MAX}_{j:(i,j)\in\mathcal{E}}\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus( p _ j ^ {xyz}-p _ i^{xyz})\oplus p _ i^{xyz}\right) \tag{6}\]</span> 额外加上点　\(p_i\) 的世界坐标，保留点的全局信息。 <img src="/PointCloud-Feature-Extraction/DGCNN.png" width="80%" height="80%" title="图 1. DGCNN"> 　　如图 1. 所示，DGCNN 网络结构与 PointNet 网络差不多，区别就在核心的点特征提取操作。<br>
　　代码实现可参考<a href="#14" id="14ref">[14]</a>, <a href="#15" id="15ref">[15]</a>，其中 <a href="#15" id="15ref">[15]</a>是完整的 DGCNN，每次卷积操作都是要在该点的新特征下取寻找 \(k\) 个最近邻，而 <a href="#14" id="14ref">[14]</a> 是简化版，最近邻点是固定的，分析代码可知其步骤：</p>
<ol type="1">
<li>针对每个点 \(p_i\)，首先找到该点最近的 \(k\) 个点及对应的特征，得到 tensor 维度：\(B\times N\times k\times F\);</li>
<li>然后将本点 \(p_i\) 的特征 concate 到对应的 \(k\) 个点特征，得到 tensor 维度： \(B\times N\times k\times 2F\)；</li>
<li>不同层 conv，bn，relu 的作用，得到多个 tensor，其维度：\(B\times N\times k\times \{F'|F'_1,...,F'_s\}\)；</li>
<li>对 \(k\) 个点作最大化聚合，得到各 tensor 维度：\(B\times N\times \{F'|F_1',...,F_s'\}\)</li>
<li>每个点的特征进行 concate，然后作 conv，bn，relu 操作，最终得到点的特征 tensor，维度为 \(B\times N\times F^{final}\)；</li>
</ol>
<p>该实现与式 (6) 有点出入，该实现没有显示计算本点坐标与对应的 \(k\) 个点坐标的差值。但是总体思想一致。</p>
<h4 id="randla-net7">1.2.6. RandLA-Net<a href="#7" id="7ref"><sup>[7]</sup></a></h4>
<p>　　设计 \(h _ {\Theta}(p_i,p_j)=\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus\left\Vert p _ j^{xyz}-p _ i^{xyz}\right\Vert\oplus (p _ j ^ {xyz}-p _ i^{xyz})\oplus p _ j^{xyz}\oplus p _ i^{xyz}\right)\)，\(\Box=\sum \mathrm{softmax\,MLP}(h_{\Theta}(p_i,p_j))\)，得到 RandLA-Net 中的操作(详见 <a href="/paper-reading-RandLA-Net/" title="RandLA-Net">RandLA-Net</a>)： <span class="math display">\[ p_i&#39; = \displaystyle\sum_{j:(i,j)\in\mathcal{E}}\left(\mathrm{softmax\,MLP&#39;}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus\left\Vert p _ j^{xyz}-p _ i^{xyz}\right\Vert\oplus (p _ j ^ {xyz}-p _ i^{xyz})\oplus p _ j^{xyz}\oplus p _ i^{xyz}\right)\right)\cdot \left(\mathrm{MLP}\,\left(p _ j^{\mathrm{exclude}\,xyz}\oplus\left\Vert p _ j^{xyz}-p _ i^{xyz}\right\Vert\oplus (p _ j ^ {xyz}-p _ i^{xyz})\oplus p _ j^{xyz}\oplus p _ i^{xyz}\right)\right) \tag{7}\]</span> 这里的 \(\Box\) 函数称为 Attention Pooling，即将特征维度进行加权求和。</p>
<h4 id="tanet12">1.2.7. TANet<a href="#12" id="12ref"><sup>[12]</sup></a></h4>
<p><img src="/PointCloud-Feature-Extraction/TANet.png" width="40%" height="40%" title="图 2. TANet"> 　　如图 2. 所示，TANet 中提出了 TA Module，该模块包含三种注意力机制：point-wise，channel-wise，voxel-wise。其中前两种注意力可用于任意点的特征提取。对应的前两种注意力构成了 \(h _ {\Theta}(p_i,p_j)\) 函数： <span class="math display">\[h_{\Theta} = \left(\mathrm{MLP_1}(\mathrm{MaxPool_{feats}}\,P_i^k) \times \mathrm{MLP_2}(\mathrm{MaxPool_{points}}\, P_i^k)\right) \cdot P_i^k \tag{8}\]</span> 其中 point-wise attention 为 \(\mathrm{MLP_1}(\mathrm{MaxPool_{feats}}\,P_i^k) = S \in \mathbb{R}^{K\times 1}\)；channel-wise attention 为 \(\mathrm{MLP_2}(\mathrm{MaxPool_{points}}\,P_i^k) = T \in \mathbb{R}^{F\times 1}\)；由此构成 \(M=S\times T\in\mathbb{R}^{K\times F}\)，作为权重作用于 \(P_i^k\)，最后用 \(\sum |\mathrm{MAX}\) 操作对点维度进行特征聚合。注意，这里的 point-wise attention 是与点的顺序有关的，看起来这里经过训练，可以消除点顺序的影响。</p>
<h4 id="pointconv13">1.2.8. PointConv<a href="#13" id="13ref"><sup>[13]</sup></a></h4>
<p><img src="/PointCloud-Feature-Extraction/PointConv.png" width="60%" height="60%" title="图 3. PointConv"> <img src="/PointCloud-Feature-Extraction/PointConv2.png" width="60%" height="60%" title="图 4. Efficient PointConv"> 　　如图 3. 以及 4. 所示，PointConv 设计的 \(h_{\Theta}\) 有两部分组成。一是根据 \(P_i^k\) 点集计算权重矩阵 \(W\)；二是用核密度函数(Kernel Density Estimation)计算点的密度，然后根据密度计算权重。这里加入基于点密度的权重，是因为，点密度高的区域，需要显式地降低其特征权重，避免最终特征学不到稀疏点的特征。图 4. 是高效版本。</p>
<h2 id="基于映射空间操作">2. 基于映射空间操作</h2>
<p>　　基于原始三维空间的点特征提取操作，<strong>其算法复杂度直接依赖点数</strong>；而如果将其映射到高维空间，则点数只会影响映射与反映射的过程，核心特征提取操作将不受点的个数影响。<br>
　　三维空间下点云无法有序组织，将点云映射到更高维空间，在高维空间下进行结构化组织后，即可应用传统的卷积操作进行特征提取。</p>
<h3 id="bilateral-convolutional-layerbcl8splatnet9hplflownet10">2.1. Bilateral Convolutional Layer(BCL<a href="#8" id="8ref"><sup>[8]</sup></a>)(SPLATNet<a href="#9" id="9ref"><sup>[9]</sup></a>/HPLFlowNet<a href="#10" id="10ref"><sup>[10]</sup></a>)</h3>
<p><img src="/PointCloud-Feature-Extraction/BCL.png" width="60%" height="60%" title="图 3. BCL"> 　　如图 3. 所示，BCL 操作有三部分组成：</p>
<ul>
<li><strong>Splat</strong><br>
将三维空间的点 \(p_i^{xyz}\) 投影到高维空间，实际操作中直接乘以一个预定义的 \(4\times 3\) 矩阵。4 维空间的晶格顶点聚合晶格内映射点的信息，聚合过程中以映射点与格点的距离作为权重；</li>
<li><strong>Convolve</strong><br>
因为晶格空间内空间是栅格化的，所以直接进行传统的 2D 卷积操作；</li>
<li><strong>Slice</strong><br>
卷积得到的是晶格空间的特征图，反映射到三维空间，即得到点级别的包含周围信息的特征向量；</li>
</ul>
<p>　　映射与反映射的操作实现上需要建立哈希表作点的快速查询，需要记录的辅助信息也比较多。后期有时间再对着代码分析。</p>
<h2 id="参考文献">3. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Qi, Charles R., et al. &quot;Pointnet: Deep learning on point sets for 3d classification and segmentation.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017.<br>
<a id="2" href="#2ref">[2]</a> Wang, S., Suo, S., Ma, W.C., Urtasun, R.: Deep parameteric convolutional neural networks. In: CVPR (2018)<br>
<a id="3" href="#3ref">[3]</a> Qi, Charles Ruizhongtai, et al. &quot;Pointnet++: Deep hierarchical feature learning on point sets in a metric space.&quot; Advances in neural information processing systems. 2017.<br>
<a id="4" href="#4ref">[4]</a> Liu, Xingyu, Charles R. Qi, and Leonidas J. Guibas. &quot;Flownet3d: Learning scene flow in 3d point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="5" href="#5ref">[5]</a> Liang, Ming, et al. &quot;Deep continuous fusion for multi-sensor 3d object detection.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018.<br>
<a id="6" href="#6ref">[6]</a> Wang, Yue, et al. &quot;Dynamic graph cnn for learning on point clouds.&quot; ACM Transactions on Graphics (TOG) 38.5 (2019): 146.<br>
<a id="7" href="#7ref">[7]</a> Hu, Qingyong, et al. &quot;RandLA-Net: Efficient Semantic Segmentation of Large-Scale Point Clouds.&quot; arXiv preprint arXiv:1911.11236 (2019).<br>
<a id="8" href="#8ref">[8]</a> Kiefel, Martin, Varun Jampani, and Peter V. Gehler. &quot;Permutohedral lattice cnns.&quot; arXiv preprint arXiv:1412.6618 (2014).<br>
<a id="9" href="#9ref">[9]</a> Su, Hang, et al. &quot;Splatnet: Sparse lattice networks for point cloud processing.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="10" href="#10ref">[10]</a> Gu, Xiuye, et al. &quot;Hplflownet: Hierarchical permutohedral lattice flownet for scene flow estimation on large-scale point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="11" href="#11ref">[11]</a> Xie, Liang, et al. &quot;PI-RCNN: An Efficient Multi-sensor 3D Object Detector with Point-based Attentive Cont-conv Fusion Module.&quot; arXiv preprint arXiv:1911.06084 (2019).<br>
<a id="12" href="#12ref">[12]</a> Liu, Zhe, et al. &quot;TANet: Robust 3D Object Detection from Point Clouds with Triple Attention.&quot; arXiv preprint arXiv:1912.05163 (2019).<br>
<a id="13" href="#13ref">[13]</a> Wu, Wenxuan, Zhongang Qi, and Li Fuxin. &quot;Pointconv: Deep convolutional networks on 3d point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="14" href="#14ref">[14]</a> https://github.com/WangYueFt/dcp/blob/master/model.py<br>
<a id="15" href="#15ref">[15]</a> https://github.com/WangYueFt/dgcnn/blob/master/pytorch/model.py</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Stereo R-CNN based 3D Object Detection for Autonomous Driving&quot;</title>
    <url>/%5Bpaper_reading%5D-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/</url>
    <content><![CDATA[<p>　　Learning 方法有什么致命缺点吗？我认为目前 Learning 方法还存在的较为棘手的问题是，有时候结果会出现非常低级的错误，或是说不可思议不合常理的 cornercases。所以我认为一个工程系统或是一个鲁棒的算法系统，在 Learning 之后做一个基于常理（如 geometry 约束或专家系统）的验证，能有效抑制这个问题。本文就是一个比较好的 learning+geometry 想结合的方法。<br>
　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>基于图像语义及几何信息，通过 3D 目标的稀疏与密集约束，提出了一种准确的 3D 目标检测方法。根据输入数据的类型，作者将 3D 检测分为三大类：</p>
<ul>
<li>LiDAR-based，近期被研究的较多，基本是自动驾驶所必须的；</li>
<li>Monocular-based，低成本方案；</li>
<li>Stereo-based，相比 Monocular-based，有优势，但是研究较少；</li>
</ul>
<p>本文就是 Stereo-based 3D 检测方案。不同于一般的 rgb+depth 作为输入的方案，本文直接将左右目 rgb 作为输入，没有显示地 depth 生成过程。工程上来说，这也极大地缩短了 3D Detection 的时延(latency)。<br>
　　本文方法如图 1 所示，主要有三部分组成：</p>
<ol type="1">
<li> Network，又有三部分构成：
<ul>
<li>Stereo RPN Module，输出左右图的 RoI；</li>
<li>Classification and Regression branches，输出目标类别，朝向，尺寸；</li>
<li>Keypoint branch，输出左目目标的关键点；</li>
</ul></li>
<li> Sparse constraints，3D 框-2D 框的稀疏约束；</li>
<li> Dense constraints，准确定位的关键模块；</li>
</ol>
<p><img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/net_arch.png" width="100%" height="100%" title="图 1. 网络结构"></p>
<h2 id="stereo-r-cnn-network">1. Stereo R-CNN Network</h2>
<p>　　Stereo R-CNN 是在 Faster R-CNN 基础上，同时检测与关联左右目图像 2D 框的微小差异。</p>
<h3 id="stereo-rpn">1.1. Stereo RPN</h3>
<p>　　在传统 RPN 网络的基础上，本文先对左右图做 paramid features 提取，然后将不同尺度的特征 concatenate 一起，进入 RPN 网络。 <img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/target.png" width="60%" height="60%" title="图 2. 真值框定义方式"> 　　关键的一点是 objectness classification与 stereo box regression 的真值框定义不一样。如图 2 所示，</p>
<ul>
<li>对于 objectness classification，真值框定义为左右目真值框的外接合并（union GT box），一个 anchor 在与真值框的交并比（Intersection-over-Union）大于 0.7 时标记为正样本，小于 0.3 时标记为负样本。分类任务的候选框包含了左右目真值框区域的信息。</li>
<li>对于 stereo box regression，真值框定义为左右目分别的真值框。待回归的参数定义为 \([u, w, u', w', v, h]\)，分别为左目的水平位置及宽，右目的水平位置及宽，垂直位置及高。因为输入为矫正过的左右目图像，所以可认为左右目的垂直方向上已经对齐。</li>
</ul>
<p>每个左右目的 proposal 都是通过同一个 anchor 产生的，自然左右目的 proposal 是关联的。通过 NMS 后，保留左右目都还存在的 proposal 关联对，取前 2000 个用于训练，测试时取前 300 个。</p>
<h3 id="stereo-r-cnn">1.2. Stereo R-CNN</h3>
<p><img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/viewpoint.png" width="50%" height="50%" title="图 3. 各角度关系"> 　　网络头包含两大部分：</p>
<ol type="1">
<li><p> <strong>Stereo Regression</strong><br>
左右目的 proposal 关联对，分别在左右目的 feature 上进行 RoI Align 的操作，然后 concatenate 输入到全链接层。左右目的 RoI 对与真值框的 IoU 均大于 0.5 时定位正样本，左右目的 RoI 对与真值框的 IoU 有一个小于 0.5 且大于 0.1，则定位负样本。用四个分支分别预测：</p>
<ul>
<li>object class；</li>
<li>stereo bounding boxes，与 stereo rpn 中一致，左右目的高度已对齐；</li>
<li>dimension，先统计平均的尺寸，然后预测相对量；</li>
<li>viewpoint angle，如图 3 所示，\(\theta\) 为相机坐标系下的朝向角，\(\beta\) 为相机中心点下的方位角(azimuth)，这三个目标在相机视野下是一样的，所以我们回归的量是视野角(viewpoint angle) \(\alpha=\theta+\beta\)，其中 \(\beta=arctan\left(-\frac{x}{z} \right) \)。并且为了连续性，回归量为 \([sin\,\alpha,cos\,\alpha]\)。</li>
</ul></li>
</ol>
<p><img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/keypoints.png" width="70%" height="70%" title="图 4. 语义关键点"></p>
<ol start="2" type="1">
<li> <strong>Keypoint Prediction</strong><br>
如图 4 所示，考虑 3D 框底部矩形的四个关键点，投影到图像平面后，最多只有一个关键点会在图像 2D 矩形框内。对左目图像进行关键点预测，类似 Mask R-CNN，在 6×28×28 的基础上，因为关键点只有图像坐标 u 方向才提供了额外的信息，所以对每列进行累加，最终输出 6×28 的向量。前 4 个通道代表每个关键点作为 perspective keypoint 投影到该 u 坐标下的概率；后 2 个通道代表该 u 坐标是左右边缘关键点(boundary keypoints)的概率。为了找出 perspective keypoint，softmax 应用于 4×28 的输出上；为了找出左右边缘关键点，softmax 分别应用于后两个 1×28 的输出上。训练的时候，4×28 中只有一个被赋予 perspective keypoint，忽略没有 perspective keypoint 的情况（遮挡等），然后最小化 cross-entropy loss；对于边缘关键点，则分别最小化 1×28 维度上的 cross-entropy loss，前景中也会被赋予边缘关键点。</li>
</ol>
<h2 id="d-box-estimation">2. 3D Box Estimation</h2>
<p><img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/projection.png" width="70%" height="70%" title="图 5. 关键点投影关系"> 　　已知关键点，2D 框，尺寸，朝向角，我们可以求解出 3D 框 \(\{x,y,z,\theta\}\)。求解目标是最小化 3D 框投影到 2D 框以及关键点的误差。如图 5 所示，已知 7 个观测量 \(z = \{u_l,v_t,u_r,v_b,u_l',u_r',u_p\}\)，分别代表左目 2D 框的左上坐标，右下坐标，右目 2D 框的左右 u 方向坐标，以及 perspective keypoint 的 u 方向坐标。在图 5 的情况下（其它视角下，注意符号变化），左上点投影关系如下： <span class="math display">\[\require{cancel}
\begin{bmatrix}
u_l\\
v_t\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{cam}^{tl}\\
y_{cam}^{tl}\\
z_{cam}^{tl}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{obj}^{tl}\\
y_{obj}^{tl}\\
z_{obj}^{tl}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
-\frac{w}{2}\\
-\frac{h}{2}\\
-\frac{l}{2}\\
\end{bmatrix}\]</span> 其中 \(K\) 为相机内参，\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)_{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，右下点为： <span class="math display">\[\require{cancel}
\begin{bmatrix}
u_r\\
v_b\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{cam}^{tl}\\
y_{cam}^{tl}\\
z_{cam}^{tl}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{obj}^{tl}\\
y_{obj}^{tl}\\
z_{obj}^{tl}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
\frac{w}{2}\\
\frac{h}{2}\\
-\frac{l}{2}\\
\end{bmatrix}\]</span> 右目两个边缘点以及 perspective keypoint 点也可同样得到，由此可整理出 7 个方程组（论文中第一个公式符号有错）： <span class="math display">\[\left\{\begin{array}{l}
u_l=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
v_t=(y- \frac{h}{2}) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
u_r=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\
v_b=(y+ \frac{h}{2}) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\
u&#39;_l=(x-b- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
u&#39;_r=(x-b+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\
u_p=(x+ \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
\end{array}\right.\]</span> 其中 \(b\) 为双目的基线长(baseline)。以上方程组可用 Gauss-Newton 法求解。</p>
<h2 id="dense-3d-box-alignment">3. Dense 3D Box Alignment</h2>
<p>　　以上得到的目标 3D 位置是 object-level 求解得到的，利用像素信息，还可以进行优化精确求解。首先在图像 2D 目标框内扣取一块 RoI，要使 RoI 能较为确定的在目标上，扣取方式定义为：</p>
<ul>
<li>目标一半以下区域；</li>
<li>perspective keypoint 与边缘关键点包围区域；</li>
</ul>
<p>关键点预测的时候只预测了 u 方向的坐标，边缘关键点无 v 方向的信息，看起来会使某些背景像素被划入为目标像素，更好的方法是加入 instance segmentation 信息。定义误差函数为： <span class="math display">\[E=\sum_{i=0}^N e_i=\sum_{i=0}^N \left\| I_l(u_i,v_i)-I_r(u_i-\frac{b}{z+\Delta z_i},v_i)\right\|\]</span> 可由三角测量关系 \(z=\) 推出。上式中，\(z_i=z_i-z\) 表示某个像素点 \(i\) 所对应的 3D 点与目标中心点之间的距离。最小化总误差即可求得最优的中心点距离 \(z\)。优化过程可以用 coarse-to-fine 的策略，先以 0.5m 的精度找 50 步，再以 0.05m 的精度找 20 次。<br>
　　这个 dense alignment 模块是独立的，可以应用到任意的左右目 3D 检测的后处理中。因为目标 RoI 是物理约束，所以这个方法避免了深度估计中不连续、病态的问题，且对光照是鲁棒的，因为每个像素都会对估计起作用。这里，本文只做了中心点的 align，尺寸，甚至朝向角是否能加入优化?</p>
<h2 id="other-details">4. Other Details</h2>
<p><img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/r1.png" width="110%" height="110%"> <img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/r2.png" width="70%" height="70%"> <img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/r3.png" width="100%" height="100%"> <img src="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/r4.png" width="90%" height="90%"></p>
<p><a id="1" href="#1ref">[1]</a> Li, Peiliang, Xiaozhi Chen, and Shaojie Shen. &quot;Stereo R-CNN based 3D Object Detection for Autonomous Driving.&quot; arXiv preprint arXiv:1902.09738 (2019).</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving&quot;</title>
    <url>/%5Bpaper_reading%5D-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/</url>
    <content><![CDATA[<p>　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>结合 Semantic SLAM 与 Learning-based 3D Det 技术，提出了一种用于自动驾驶的动态目标定位与本车状态估计的方法。本文系统性较强，集成了较多成熟的模块，对工程应用也有较强的指导意义。 <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/arch.png" width="100%" height="100%" title="图 1. 语义跟踪系统框架"> 　　如图 1. 所示，整个系统框架由三部分组成：</p>
<ul>
<li>2D object detection and viewpoint classification，目标位姿通过 2D-3D 约束求解出来；</li>
<li>feature extraction and matching，双目及前后帧的特征提取与匹配；</li>
<li>ego-motion and object tracking，将语义信息及特征量加入到优化中，并且加入车辆动力学约束以获得平滑的运动估计。</li>
</ul>
<h2 id="viewpoint-classification-and-3d-box-inference">1. Viewpoint Classification and 3D Box Inference</h2>
<h3 id="viewpoint-classification">1.1. Viewpoint Classification</h3>
<p>　　选用 Faster R-CNN 作为 2D 检测框架，在此基础上，加入车辆视野（viewpoint）分类分支。由图 2. 所示，水平视野分为八类，垂直视野分为两类，总共 16 类。 <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/view.png" width="90%" height="90%" title="图 2. 车辆视野分类"></p>
<h3 id="d-box-inference-based-on-viewpoint">1.2. 3D Box Inference Based on Viewpoint</h3>
<p>　　网络输出图像 2D 框以及目标车辆的视野类别（viewpoint），此时我们假设：</p>
<ul>
<li>2D 框准确；</li>
<li>每种车辆的尺寸相同；</li>
<li>2D 框能紧密包围 3D 框；</li>
</ul>
<p>在以上假设条件下，我们可以求得 3D 框，该 3D 框作为后续优化的初始值。约束方程的表示在论文中比较晦涩，在这里我做细致的推倒。 3D 框可表示为 \(\{x,y,z,\theta,w,h,l\}\)，其中 \(\{w,h,l\}\) 分别对应 \({x,y,z}\) 维度。如图 2.(b) 所示，这个视角下，四个 3D 框的顶点，可得四个约束方程。推倒过程为： <span class="math display">\[\require{cancel}
\begin{bmatrix}
u_{min}\\
v_1\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{1}^{cam}\\
y_{1}^{cam}\\
z_{1}^{cam}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{1}^{obj}\\
y_{1}^{obj}\\
z_{1}^{obj}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
\frac{w}{2}\\
\frac{h}{2}\\
\frac{l}{2}\\
\end{bmatrix}\]</span> 其中 \(K\) 为相机内参，做归一化处理消去；\(T_{cam}^{obj}\) 为目标中心坐标系在相机坐标系下的表示，\((\cdot)^{cam/obj}\) 分别为点在相机坐标系，目标中心坐标系下的表示。同样的，这个视野下，②，③，④ 点都可以由此获得： <span class="math display">\[\left\{\begin{array}{l}
\require{cancel}
\begin{bmatrix}
u_{min}\\
v_1\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{1}^{cam}\\
y_{1}^{cam}\\
z_{1}^{cam}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{1}^{obj}\\
y_{1}^{obj}\\
z_{1}^{obj}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
\frac{w}{2}\\
\frac{h}{2}\\
\frac{l}{2}\\
\end{bmatrix}\\
\begin{bmatrix}
u_{max}\\
v_2\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{2}^{cam}\\
y_{2}^{cam}\\
z_{2}^{cam}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{2}^{obj}\\
y_{2}^{obj}\\
z_{2}^{obj}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
-\frac{w}{2}\\
\frac{h}{2}\\
-\frac{l}{2}\\
\end{bmatrix}\\
\begin{bmatrix}
u_3\\
v_{min}\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{3}^{cam}\\
y_{3}^{cam}\\
z_{3}^{cam}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{3}^{obj}\\
y_{3}^{obj}\\
z_{3}^{obj}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
\frac{w}{2}\\
-\frac{h}{2}\\
-\frac{l}{2}\\
\end{bmatrix}\\
\begin{bmatrix}
u_4\\
v_{max}\\
1\\
\end{bmatrix}=K\cdot
\begin{bmatrix}
x_{4}^{cam}\\
y_{4}^{cam}\\
z_{4}^{cam}\\
\end{bmatrix}\doteq \xcancel{K} \cdot T_{cam}^{obj} \cdot 
\begin{bmatrix}
x_{4}^{obj}\\
y_{4}^{obj}\\
z_{4}^{obj}\\
\end{bmatrix}=\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}+
\begin{bmatrix}
cos\theta &amp; 0 &amp;sin\theta\\
0 &amp; 1 &amp; 0\\
-sin\theta &amp; 0 &amp; cos\theta\\
\end{bmatrix} \cdot
\begin{bmatrix}
-\frac{w}{2}\\
\frac{h}{2}\\
\frac{l}{2}\\
\end{bmatrix}
\end{array}\right.\]</span></p>
<p>将 \(z\) 方向归一化后，进一步得到最终的四个约束式子： <span class="math display">\[\left\{\begin{array}{l}
u_{min}=(x+ \frac{w}{2} cos\theta+ \frac{l}{2} sin\theta) / (z- \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)\\
u_{max}=(x- \frac{w}{2} cos\theta- \frac{l}{2} sin\theta) / (z+ \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
v_{min}=(y- \frac{h}{2}) / (z- \frac{w}{2} sin\theta - \frac{l}{2} cos\theta)\\
v_{max}=(y+ \frac{h}{2}) / (z+ \frac{w}{2} sin\theta + \frac{l}{2} cos\theta)
\end{array}\right.\]</span> 以上四个方程可以闭式求解 3D 框 \({x,y,z,}\)。该方法将 3D 框的回归求解分解成了 2D 框回归，视野角分类以及解方程组的过程，强依赖于前面的三点假设，实际情况 3D 框与 2D 框不会贴的很紧。这个 3D 框结果只用来作后续的特征提取区域及最大后验概率估计的初始化。</p>
<h2 id="feature-extraction-and-matching">2. Feature Extraction and Matching</h2>
<p>　　这一部分做的是左右目及前后帧特征提取及匹配。选用 ORB 特征，目标区域由投影到图像的 3D 框确定。</p>
<ul>
<li><strong>目标区域内左右目的立体匹配</strong> 由于已知目标的距离及尺寸，所以只需要在一定小范围内进行特征点的行搜索匹配。</li>
<li><strong>目标及背景区域下前后帧的时序匹配</strong> 首先进行 2D 框的关联，2D 框经过相机旋转补偿后，最小化关联框的中心点距离及框形状相似度值。然后在关联上的目标框区域以及背景区域里，分别作 ORB 特征的匹配，异常值在 RANSAC 下通过基础矩阵测试去除。</li>
</ul>
<h2 id="ego-motion-and-object-tracking">3. Ego-motion and Object Tracking</h2>
<p>　　首先进行本车运动状态估计，可在传统 SLAM 框架下做，不同的是将动态障碍物中的特征点去除。有了本车的位姿后，再估计动态障碍物的运动状态。文中符号定义较为复杂，这里不做赘述。</p>
<h3 id="ego-motion-tracking">3.1. Ego-motion Tracking</h3>
<p>　　给定左目前后帧背景区域特征点的观测，本车状态估计可以通过极大似然估计（Maximum Likelihood Estimation）得到。MLE 可以转化为非线性最小二乘问题，也就是 Bundle Adjustment 过程，这是典型的 SLAM 问题。文中给出的误差方程： <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/3.png" width="50%" height="50%"> 需要求解的是本车位姿以及背景特征点坐标，这是后验概率，可转为似然函数求解，然后转化为非线性优化问题。可参考《视觉 SLAM 十四讲》(107-108)来理解。</p>
<h3 id="semantic-object-tracking">3.2. Semantic Object Tracking</h3>
<p>　　得到本车相机的位姿后，运动目标的状态估计可以通过最大后验概率估计（Maximum-a-posterior, MAP）得到。类似的，可转为非线性优化问题进行求解，联合优化每个车辆的<strong>位姿</strong>，<strong>尺寸</strong>，<strong>速度</strong>，<strong>方向盘转角</strong>，<strong>所有特征点 3D 位置</strong>。有四个 loss 项： <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/6.png" width="80%" height="80%"> <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/10.png" width="80%" height="80%"> \(r_Z,r_P,r_M,r_S\) 分别代表：</p>
<ul>
<li><strong>Sparse Feature Observation</strong><br>
目标上的特征点重投影到左右目图像的误差，注意有左右目两个误差项；</li>
<li><strong>Semantic 3D Object Measurement</strong><br>
3D 框投影到图像上与 2D 框的尺寸约束投影误差，即 1.2 节中的形式，区别在车辆尺寸与位姿作为了优化项；</li>
<li><strong>Vehicle Motion Model</strong><br>
对于车辆，前后时刻的状态要有连续性，即误差最小；</li>
<li><strong>Point Cloud Alignment</strong><br>
为了减少 3D 框的整体偏移，引入特征点到 3D 观察面的最小距离误差；</li>
</ul>
<p>这里只对车辆运动模型进行分析，其它几项基本在前文已经有描述或者比较常识化，就不展开，具体公式可参见论文。<br>
　　由实验可知 Sparse Feature Observation 与 Point Cloud Alignment 对性能提升较明显，Motion Model 对困难情景性能才有提升。</p>
<h4 id="vehicle-motion-model">3.2.1. Vehicle Motion Model</h4>
<p>　　<a href="#2" id="2ref">[2]</a> 中介绍了前转向车的两种模型：运动学模型(Kinematic Bicycle Model)，以及更复杂的动力学模型(Dynamic Bicycle Model)。运动学模型假设车辆不存在滑动，这在大多数情况下都是满足的，所以我们只介绍运动学模型。 <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/kinematic.png" width="30%" height="30%" title="图 3. 车辆运动学模型"> 　　如图 3. 所示，前后轮无滑动的约束下，可得方程组： <span class="math display">\[\left\{\begin{array}{rl}
\dot{x}_fsin(\theta+\delta)-\dot{y}_fcos(\theta+\delta)=&amp;0\\
\dot{x}sin(\theta)-\dot{y}cos(\theta)=&amp;0\\
x+Lcos(\theta)=&amp;x_f  \quad\Rightarrow \quad \dot{x}-\dot{\theta}Lsin(\theta)=\dot{x}_f\\
y+Lsin(\theta)=&amp;y_f \quad\Rightarrow \quad \dot{y}+\dot{\theta}Lcos(\theta)=\dot{y}_f
\end{array}\right.\]</span> 由此可得到: <span class="math display">\[\dot{x}sin(\theta+\delta)-\dot{y}cos(\theta+\delta)-\dot{\theta}Lcos(\delta)=0\]</span> 用 \(\left(v \cdot cos(\theta),v\cdot sin(\theta)\right)\) 代替 \((\dot{x},\dot{y})\) 可得： <span class="math display">\[\dot{\theta}=\frac{tan(\delta)}{L}\cdot v\]</span> 最终可整理成矩阵形式： <span class="math display">\[
\begin{bmatrix}
\dot{x}\\
\dot{y}\\
\dot{\theta}\\
\dot{\delta}\\
\dot{v}\\
\end{bmatrix}=
\begin{bmatrix}
0 &amp;0 &amp;0 &amp;0 &amp;cos(\theta)\\
0 &amp;0 &amp;0 &amp;0 &amp;sin(\theta)\\
0 &amp;0 &amp;0 &amp;0 &amp;\frac{tan(\delta)}{L}\\
0 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\theta\\
\delta\\
v\\
\end{bmatrix}+
\begin{bmatrix}
0 &amp;0\\
0 &amp;0\\
0 &amp;0\\
1 &amp;0\\
0 &amp;1\\
\end{bmatrix}
\begin{bmatrix}
\gamma\\
\alpha\\
\end{bmatrix}
\]</span> 其中 \(L\) 为车辆参数。观测量有：</p>
<ul>
<li>\((x,y,\theta)\) 为车辆的位置及朝向角；</li>
<li>\(\delta\) 为方向盘/车轮转角；</li>
<li>\(v\) 为车辆速度；</li>
</ul>
<p>控制量有：</p>
<ul>
<li>\(\gamma\) 为方向盘角度比率；</li>
<li>\(\alpha\) 为加速度；</li>
</ul>
<p>本文的目的是要约束车辆时序上运动(速度及朝向)的平滑一致性，令控制量 \(\gamma,\alpha\) 为 0，然后可得状态量在相邻时刻的关系应满足： <span class="math display">\[\left\{\begin{array}{l}
\hat{x}^t=x^{t-1}+cos(\theta^{t-1})v^{t-1}\Delta t\\
\hat{y}^t=y^{t-1}+sin(\theta^{t-1})v^{t-1}\Delta t\\
\hat{\theta}^t=\theta^{t-1}+\frac{tan(\delta^{t-1})}{L}v^{t-1}\Delta t\\
\hat{\delta}^t=\delta^{t-1}\\
\hat{v}^t=v^{t-1}
\end{array}\right.\]</span> 由此可整理成论文中矩阵的形式及误差项： <img src="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/15.png" width="80%" height="80%"></p>
<p><a id="1" href="#1ref">[1]</a> Li, Peiliang, and Tong Qin. &quot;Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018.<br>
<a id="2" href="#2ref">[2]</a> Gu, Tianyu. Improved trajectory planning for on-road self-driving vehicles via combined graph search, optimization &amp; topology analysis. Diss. Carnegie Mellon University, 2017.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds&quot;</title>
    <url>/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/</url>
    <content><![CDATA[<p>　　在多视角融合 3D 检测上，研究比较多的是俯视图下的激光点云以及前视图下的图像做多传感器融合，而融合点云俯视图(Bird's Eye View)与前视图(Perspective View)的特征则比较少，新鲜出炉的本文<a href="#1" id="1ref"><sup>[1]</sup></a>提供了一种较好的点云前视图与俯视图特征前融合(early fusion)方法。</p>
<h2 id="为什么要融合点云前视图特征">1. 为什么要融合点云前视图特征</h2>
<p>　　目前主流的点云检测算法，都是将点云在俯视图下以一定分辨率体素化(Voxelization)，然后用网络提取特征做 3D 检测。单纯在俯视图下提取特征虽然比单纯在前视图下做有优势，但还是存在几个问题：</p>
<ol type="1">
<li>激光点云在远处，会变得很稀疏，从而空像素会比较多；</li>
<li>行人等狭长型小目标特征所占像素会很小；</li>
</ol>
<p>将点云投影到前视图，这两个问题则能有效减弱，所以本文提出融合点云前视图特征。</p>
<h2 id="贡献点">2. 贡献点</h2>
<p>　　本文是在 <a href="/paperreading-PointPillars/" title="PointPillars">PointPillars</a> 基础上做的工作，PointPillars 主要由三个模块构成：</p>
<ul>
<li>Voxelization；</li>
<li>Point Feature Encoding；</li>
<li>CNN Backbone；</li>
</ul>
<p>本文改进了前两个模块，但是本质思想还是 PointNet 形式。其余包括 Loss 形式等与 PointPillars 一致。<br>
　　针对这两个模块，本文有两个贡献点，Dynamic Voxelization 以及 Point-level Feature Fusion，接下来作详细介绍。</p>
<h3 id="动态体素化dynamic-voxelization">2.1. 动态体素化(Dynamic Voxelization)</h3>
<p><img src="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/voxelization.png" width="90%" height="90%" title="图 1. 体素化过程对比"> 　　如图 1. 所示，PointPillars (包括之前的 VoxelNet 等工作)体素化的过程都是 Hard Voxelization，即 Voxel 数目要采样，每个 Voxel 里面的点数也会采样，比如 PointPillars 将每个 Voxel 的点数定义为 100 个，少于 100 个点，则作补零处理。这样会存在问题：</p>
<ul>
<li>内存消耗大，很多稀疏的区域导致体素中要补零的内存很多；</li>
<li>采样导致信息丢失；</li>
<li>采样导致检测输出有一定的不一致性；</li>
<li>不能作点级别的特征融合；</li>
</ul>
<p>　　由此提出动态体素化(Dynamic Voxelization)，取消所有的采样过程，为什么可以这么做呢？其实这么做也比较自然，PointPillars 中 PointNet 网络将 \((P, N, D)\) 特征映射为 \((P, N, C)\)，这里就是多层感知机将输入的 channel 维度从 \(D\) 变换到 \(C\)，与其它两个维度没有关系，而接下来做的 max-pooling 操作则将 \(N\) 维(N 个点)压缩到 1，PointPillars 中每个柱子的 N 是采样成一样的。但是可以不一样！这就是本文的动态体素化思想了。</p>
<h3 id="点级别特征融合point-level-feature-fusion">2.2. 点级别特征融合(Point-level Feature Fusion)</h3>
<p>　　<a href="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/" title="MMF">MMF</a> 以 Voxel-level 将前视图的图像特征融合到俯视图的点云特征中，并以 ROI-level 融合图像前视图特征及点云俯视图特征做检测分类，本文则提出了更加前序的特征融合-Point-level 融合。 <img src="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/MVF.png" width="90%" height="90%" title="图 2. 点级别特征融合框架"> 　　如图 2. 所示，首先将每个点的特征(x,y,z,intensity...)映射到高维度，然后经过 FC+Maxpool(PointNet 形式) 得到标准卷积网络需要的输入数据形式，再经过 Convolution Tower 模块进行环境上下文特征提取，最终每个体素的特征作为体素内每个点的特征，由此拼接成总的点特征。<br>
<img src="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/encoding.png" width="40%" height="40%" title="图 3. Convolution Tower"> 　　其中 Convolution Tower 网络结构如图 3. 所示，输入输出的尺寸保持不变，类似于 FPN 结构。<br>
　　最终每个点的特征由三部分构成：</p>
<ul>
<li>自身特征维度映射；</li>
<li>俯视图下抽取的 Voxel 级别特征，有一定的感受野；</li>
<li>前视图下抽取的 Voxel 级别特征，有一定的感受野；</li>
</ul>
<p>　　俯视图下点云特征提取过程我们比较熟悉了，这里再详细介绍下点云在前视图下提取特征的过程(还没看懂，论文中好像没有详细信息，看懂了再补充)。</p>
<h2 id="实验结果">3. 实验结果</h2>
<p><img src="/paperreading-End-to-End-Multi-View-Fusion-for-3D-Object-Detection-in-LiDAR-Point-Clouds/eval.png" width="90%" height="90%" title="图 4. 实验结果"> 　　网络参数配置可详见论文，图 4. 是在 Waymo 公开数据集上的实验结果。可知：</p>
<ol type="1">
<li>动态体素化在全距离范围内对检测都有一定的提升；</li>
<li>融合前视图特征能有效提升提升检测性能，尤其是远距离情况，距离越远，提升越明显；</li>
<li>融合前视图特征对小目标提升更加明显，如行人；</li>
</ol>
<h2 id="参考文献">4. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Zhou, Yin, et al. &quot;End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds.&quot; arXiv preprint arXiv:1910.06528 (2019).</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;What You See is What You Get, Exploiting Visibility for 3D Object Detection&quot;</title>
    <url>/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/</url>
    <content><![CDATA[<p>　　Bird-View 3D Detection 都是将点云离散化到 Voxel，有点的 Voxel 提取区域特征，无点的 Voxel 则置为空。而 LiDAR 的测量特性其实还包含更多的信息，<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 中较详细的阐述了 LiDAR 的测量模型，每个栅格可以标记为三个状态：UNKNOWN，FREE，OCCUPIED。传统的 Bird-View 3D Detection 没有显式得提取 UNKNOW 与 FREE 的信息(即没有提取 Visibility 信息)，而 UNKNOW 与 FREE 对数据增广及检测效果非常重要。 <img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/visibility.png" width="90%" height="90%" title="图 1. Visibility or Freespace from LiDAR"> 　　如图 1. 所示，左图是传统的点云表示方式，无法区分红色区域是否有车，而右图则非常容易得区分哪个区域不可能有车，哪个区域可能有车。所以本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了显式提取点云 UNKNOWN 与 FREE 信息来辅助数据增广与提高目标检测精度的方法。</p>
<h2 id="framework">1. Framework</h2>
<p><img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/framework.png" width="90%" height="90%" title="图 2. Framework"> 　　如图 2. 所示，本文的 3D 检测框架与传统的差不多，是 Anchor-Based 方法，主要不同点是输入网络的特征，即点云栅格化后提取出的特征不一样以及融合时序信息。并且，训练过程中，对数据增广做了精心的设计。 <img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/fusion.png" width="90%" height="90%" title="图 3. Frusion Strategy"> 　　如图 3. 所示，点云栅格化后提取的特征不一样是指增加了 Visibility 图层。有两种融合方式，前融合是与点云栅格化后提取的特征作 Concate，然后输入到主干网络；后融合则是二者分别通过主干网络，然后再作 Concate。实验表明前融合效果较好。</p>
<h3 id="object-augmentation">1.1. Object Augmentation</h3>
<p>　　传统的数据增广关注在全帧点云的平移，旋转，翻转变换。本文则采用目标级别的数据增广。首先生成目标的点云集合，可以用 CAD 模型，也可以直接扣实际的目标点云(扣出来的点云增广能力有限)；然后将目标点云集合随机得放到全帧点云中。在放置的过程中需要模拟 LiDAR 的测量模型，也就是 Visibility 计算过程，这在第 2. 节中详细描述。实验表面能提升 ~9 个点。</p>
<h3 id="temporal-aggregation">1.2. Temporal Aggregation</h3>
<p>　　时序点云信息的利用可以有以下几种方法：</p>
<ul>
<li>将每帧点云栅格化，然后直接在 Chanel 层作 Concate，之后作 3D 卷积，或者先在 Chanel 维度作 1D 卷积，然后作 2D 卷积；</li>
<li>将点云中的点增加相对时间戳属性，然后作整体的栅格化，之后直接作传统的 2D 卷积；</li>
</ul>
<p>本文采用第二种方法，实验表明能提升 ~8 个点。</p>
<h2 id="visibility-computing">2. Visibility Computing</h2>
<p>　　<a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 中已经应用了 Raycasting 来计算 Visibility/Free。对于点云中的每一个点，我们不仅能获得该点探测到障碍物的这个信息，还能知道，传感器与该点之间的连线上是 Free 的。这就要求能高效得计算该连线相交 Voxel 的集合。该计算模型也用来修正 Object Augmentation 时的点云。</p>
<h3 id="efficient-voxel-traversal">2.1. Efficient Voxel traversal</h3>
<p>　　对每个点，都需要遍历传感器原点到该点所经过的 Voxel，采用 Fast Voxel Traversal<a href="#2" id="2ref"><sup>[2]</sup></a>方法来进行高效的 Voxel 遍历。</p>
<h3 id="raycasting-with-augmented-objects">2.2. Raycasting with Augmented Objects</h3>
<p><img src="/paper-reading-What-You-See-is-What-You-Get-Exploiting-Visibility-for-3D-Object-Detection/augment.png" width="90%" height="90%" title="图 4. Rectify Object Augmentation"> 　　如图 4. 所示，本文设计了两种策略来修正物体增广：</p>
<ul>
<li>Culling，如果该物体是被遮挡的，那么直接去掉，这样会极大减少增广的物体；</li>
<li>Drilling，如果该物体是被遮挡的，那么将遮挡物去掉，即置为 Free；</li>
</ul>
<p>实验表明 Drilling 效果较好，在训练时采用该策略进行物体增广后的点云修正，作 Inference 时就直接计算 Freespace 即可。</p>
<h3 id="online-occupancy-mapping">2.3. Online Occupancy Mapping</h3>
<p>　　栅格内点云提取特征时融合了时序信息，Visibility 也需要融合时序信息，最直观的方式是将 3D Occupancy Map 进行时间维度的堆叠，获得 4D Map，这样对后续的计算量较大。本文采用 OctoMap<a href="#3" id="3ref"><sup>[3]</sup></a> 计算方式，作贝叶斯滤波，得到时序滤波的 3D Occupancy Map。原理与 <a href="/Grid-Mapping/" title="Grid-Mapping">Grid-Mapping</a> 一样，只不过这里是 3D 的。</p>
<h2 id="reference">3. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Hu, Peiyun, et al. &quot;What You See is What You Get: Exploiting Visibility for 3D Object Detection.&quot; arXiv preprint arXiv:1912.04986 (2019).<br>
<a id="2" href="#2ref">[2]</a> Amanatides, John, and Andrew Woo. &quot;A fast voxel traversal algorithm for ray tracing.&quot; Eurographics. Vol. 87. No. 3. 1987.<br>
<a id="3" href="#3ref">[3]</a> Hornung, Armin, et al. &quot;OctoMap: An efficient probabilistic 3D mapping framework based on octrees.&quot; Autonomous robots 34.3 (2013): 189-206.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Fast and Furious&quot;</title>
    <url>/paperreading-Fast-and-Furious/</url>
    <content><![CDATA[<p>　　动态目标状态估计传统的做法是将其分解为目标检测，目标跟踪，目标运动预测三个子问题进行链式求解，这回导致上游模块的误差在下游模块中会传递并放大。考虑到跟踪与预测能帮助提升检测的性能，比如对于遮挡或远距离目标，跟踪与预测能减少检测的漏检(FN)；而误检(FP)则可通过时域相关信息消除，由此本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种联合 3D 检测，跟踪，运动预测的多任务网络。</p>
<h2 id="model-architecture">1. Model Architecture</h2>
<h3 id="data-representation">1.1. Data Representation</h3>
<p>　　雷达坐标系下，每帧点云限定范围为\((x_{min}, x_{max}, y_{min}, y_{max}, z_{min}, z_{max})\)，那么在分辨率 \(r = (dx,dy,dz)\) 下进行栅格化，可得到体素 \((C, H, W) = (\frac{z_{max}-z_{min}}{dz}, \frac{y_{max}-y_{min}}{dy}, \frac{x_{max}-x_{min}}{dx})\), 如果体素中有点云那么该体素值置为1，否则置为0，这样就得到了俯视图下的伪图像。<br>
　　此外将历史 \(T-1\) 帧点云先转换到当前本体坐标系(需要 ego motion 信息)，然后串成一起，就获得 \((T, C, H, W) \) 维的模型数据输入表示。</p>
<h3 id="model-formulation">1.2. Model Formulation</h3>
<p>　　实际输入网络的应该是 \((N, T, C, H, W) \) 维的数据，首先需要经过一个 fusion 层将数据映射到 \((N, C', H', W') \) 维，然后用一个类似与 SSD 结构的 backbone+head 网络即可。</p>
<h4 id="fusion">1.2.1. Fusion</h4>
<p><img src="/paperreading-Fast-and-Furious/fusion.png" width="80%" height="80%" title="图 1. Fusion 结构"> 　　本文提出了两种融合方式：</p>
<ul>
<li>Early Fusion<br>
如图 1. 所示，直接在 T 维度上进行一维卷积，卷积 \(kernel_ size = T\)，由此得到 \((N, C, H, W) \) 维的特征。</li>
<li>Late Fusion<br>
如图 1. 所示，通过两次 3D 卷积将 \(T=5\) 变换到 \(T=1\)，\(kernel size = (3, 3, 3)\),由此也得到 \((N, C, H, W) \) 维的特征。</li>
</ul>
<p>相比 Early Fusion，Late fusion 有更深的特征提取。</p>
<h4 id="backbonehead">1.2.2. Backbone+Head</h4>
<p><img src="/paperreading-Fast-and-Furious/head.png" width="80%" height="80%" title="图 2. Fusion 结构"> 　　backbone 采用 VGG16 结构，图 1. 可见。<br>
　　head 采用类似 SSD 检测头的形式。anchor 也是有不同比例不同尺寸的矩形组成(另一种方法是，由于俯视图下同种类别的尺寸相似性，所以针对不同类别采用同一尺寸的 anchor 即够用)，角度回归则采用 \(cos, sin\) 形式。<br>
　　如图 2. 所示，检测头有两个分之分支，第一个输出预测的分类 score map(n 个预测的 score map 是共享的)，第二个输出 n 个预测的 3D 框编码信息。</p>
<h3 id="decoding-tracklets">1.3. Decoding Tracklets</h3>
<p>　　由于有检测及预测的信息，所以可用简单的方法解析出跟踪 ID。历史的预测框信息可认为是当前的跟踪框，所以就自然得在 MOT 问题里进行求解。这里可直接计算跟踪框(历史预测框)与当前检测框的 overlap 误差项，然后将重合度高的目标框标记为同一 ID 即可。</p>
<h3 id="loss-function">1.4. Loss Function</h3>
<p>　　总的误差由分类误差与回归误差构成： <span class="math display">\[\xi = \sum\left(\alpha \cdot \xi_{cla} + \sum_{i=t,t+1,...,t+n}\xi_{reg}^t\right)\]</span> 这两项误差具体计算与传统的并无很大差别，此外作者还用了 OHEM 的策略，来平衡正负样本量巨大的差异。</p>
<h2 id="experimental-evaluation">2. Experimental Evaluation</h2>
<p><img src="/paperreading-Fast-and-Furious/test.png" width="80%" height="80%" title="图 3. ablation study"> 　　作者用了比 kitti 大的数据集，图 3. 所示，late fusion 比 early fusion 效果好一点，但是 late fusion 需要 3D 卷积。其它实验结果可参见文章。</p>
<p><a id="1" href="#1ref">[1]</a> Luo, Wenjie, Bin Yang, and Raquel Urtasun. &quot;Fast and furious: Real time end-to-end 3d detection, tracking and motion forecasting with a single convolutional net.&quot; Proceedings of the IEEE conference on Computer Vision and Pattern Recognition. 2018.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Multi-Task Learning Using Uncertainty to Weigh Losses&quot;</title>
    <url>/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/</url>
    <content><![CDATA[<p>　　深度学习网络中的不确定性(Uncertainty)是一个比较重要的问题，本文<a href="#1" id="1ref"><sup>[1]</sup></a>讨论了其中一种不确定性在多任务训练中的应用。目前关于深度学习不确定性的研究基本出自本文作者及其团队，后续我会较系统得整理其研究成果，这篇文章先只讨论一个较为实用的应用。</p>
<h2 id="不确定性概述">1. 不确定性概述</h2>
<p>　　在贝叶斯模型中，可以建模两类不确定性<a href="#2" id="2ref"><sup>[2]</sup></a>：</p>
<ul>
<li><strong>认知不确定性(Epistemic Uncertainty)</strong>，描述模型因为缺少训练数据而存在的未知，可通过增加训练数据解决；</li>
<li><p><strong>偶然不确定性(Aleatoric Uncertainty)</strong>，描述了数据不能解释的信息，可通过提高数据的精度来消除；</p>
<ul>
<li><strong>数据依赖地或异方差不确定性(Data-dependent or Heteroscedastic Uncertainty)</strong>，与模型输入数据有关，可作为模型预测输出；</li>
<li><strong>任务依赖地或同方差不确定性(Task-dependent or Homoscedastic Uncertainty)</strong>，与模型输入数据无关，且不是模型的预测输出，不同任务有不同的值；</li>
</ul></li>
</ul>
<p>本文讨论同方差不确定性，其描述了不同任务间的相关置信度，所以可用同方差不确定性来设计不同任务的 \(Loss\) 权重项。</p>
<h2 id="为什么需要设计不同任务的-loss-权重项">2. 为什么需要设计不同任务的 \(Loss\) 权重项</h2>
<p><img src="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/mt_weight.png" width="90%" height="90%" title="图 1. Multi-task loss weightings"> 　　如图 1. 所示，多任务学习能提高单任务的性能，但是要充分发挥多任务的性能，那么得精心调节各任务的 \(Loss\) 权重。当任务多的时候，人工搜索最优的权重项则显得费时费力，依靠模型的同方差不确定性，我们可以自动学习权重项。</p>
<h2 id="多任务似然建模">3. 多任务似然建模</h2>
<p>　　下面推倒基于同方差不确定性的最大化高斯似然过程。设模型权重 \(\mathbf{W}\)，输入 \(\mathbf{x}\)，输出为 \(\mathbf{f^W(x)}\)。对于回归任务，定义模型输出为高斯似然形式： <span class="math display">\[p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) = \mathcal{N}\left(\mathbf{f^W(x)}, \sigma ^2\right) \tag{1}\]</span> 其中 \(\sigma\) 为观测噪声方差，描述了模型输出中含有多大的噪声。对于分类任务，玻尔兹曼分布下的模型输出概率分布为： <span class="math display">\[p\left(\mathbf{y}\vert\mathbf{f^W(x)},\sigma\right) = \mathrm{Softmax}\left(\frac{1}{\sigma ^2}\mathbf{f^W(x)}\right) \tag{2}\]</span> 由此对于多任务，模型输出的联合概率分布为： <span class="math display">\[p\left(\mathbf{y}_1,\dots,\mathbf{y}_K\vert\mathbf{f^W(x)}\right) = p\left(\mathbf{y}_1\vert\mathbf{f^W(x)}\right) \dots p\left(\mathbf{y}_K\vert\mathbf{f^W(x)}\right) \tag{3}\]</span></p>
<p>　　对于回归任务，\(log\)似然函数： <span class="math display">\[\mathrm{log}p\left(\mathbf{y}\vert\mathbf{f^W(x)}\right) \propto -\frac{1}{2\sigma ^2} \Vert \mathbf{y-f^W(x)} \Vert ^2 - \mathrm{log}\sigma \tag{4}\]</span> 对于分类任务，\(log\)似然函数： <span class="math display">\[\mathrm{log}p\left(\mathbf{y}=c\vert\mathbf{f^W(x)}, \sigma\right) = \frac{1}{2\sigma ^2}f_c^{\mathbf{W}}(\mathbf{x})- \mathrm{log}\sum_{c&#39;} \mathrm{exp}\left(\frac{1}{\sigma^2}f^{\mathbf{W}}_{c&#39;}(\mathbf{x}) \right) \tag{5}\]</span></p>
<p>　　现同时考虑回归与分类任务，则多任务的联合 \(Loss\)： <span class="math display">\[\begin{align}
\mathcal{L}(\mathbf{W}, \sigma _1, \sigma _2) &amp;= -\mathrm{log}p\left(\mathrm{y_1,y_2}=c\vert\mathbf{f^W(x)} \right) \\
&amp;= -\mathrm{log}\mathcal{N}\left(\mathbf{y_1};\mathbf{f^W(x)}, \sigma_1^2\right) \cdot \mathrm{Softmax}\left(\mathbf{y_2}=c;\mathbf{f^W(x)},\sigma_2\right) \\
&amp;= \frac{1}{2\sigma_1^2}\Vert \mathbf{y}_1-\mathbf{f^W(x)}\Vert ^2 + \mathrm{log}\sigma_1 - \mathrm{log}p\left(\mathbf{y}_2=c\vert\mathbf{f^W(x)},\sigma_2\right) \\
&amp;= \frac{1}{2\sigma_1^2}\mathcal{L}_1(\mathbf{W}) +\frac{1}{\sigma_2^2}\mathcal{L}_2(\mathbf{W}) + \mathrm{log}\sigma_1 + \mathrm{log}\frac{\sum_{c&#39;}\mathrm{exp}\left(\frac{1}{\sigma_2^2}f_{c&#39;}^{\mathbf{W}}(x)\right)}{\left(\sum_{c&#39;}\mathrm{exp}\left(f_{c&#39;}^{\mathbf{W}}(x) \right) \right)^{\frac{1}{\sigma_2^2}}} \\
&amp;\approx \frac{1}{2\sigma_1^2}\mathcal{L}_1(\mathbf{W}) +\frac{1}{\sigma_2^2}\mathcal{L}_2(\mathbf{W}) + \mathrm{log}\sigma_1 + \mathrm{log}\sigma_2 \tag{6}
\end{align}\]</span></p>
<p>由此得到两个权重项，任务噪声 \(\sigma\) 越大，则该任务的误差权重越小。实际应用中，为了数值稳定，令 \(s:=\mathrm{log}\sigma^2\): <span class="math display">\[\mathcal{L}(\mathbf{W}, s_1, s_2) = \frac{1}{2}\mathrm{exp}(-s_1)\mathcal{L}_1(\mathbf{W}) + \mathrm{exp}(-s_2)\mathcal{L}_2(\mathbf{W}) + \mathrm{exp}(\frac{1}{2}s_1) + \mathrm{exp}(\frac{1}{2}s_2) \tag{7}\]</span> 对于更多任务的模型，根据任务类型也很容易扩展，网络自动学习权重项 \((s_1,s_2,...,s_n)\)。</p>
<h2 id="实验结果">4. 实验结果</h2>
<p><img src="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/mt.png" width="90%" height="90%" title="图 2. Multi-task"> <img src="/paperreading-MT-Learning-Using-Uncertainty-to-Weight-Losses/ablation.png" width="90%" height="90%" title="图 3. 实验结果"> 　　如图 2. 所示，作者设计了同时作语义分割、实例分割、深度估计的网络，由图 3. 可知，用任务的不确定性来加权任务的 \(Loss\)，效果显著。</p>
<h2 id="参考文献">5. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Kendall, Alex, Yarin Gal, and Roberto Cipolla. &quot;Multi-task learning using uncertainty to weigh losses for scene geometry and semantics.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="2" href="#2ref">[2]</a> Kendall, Alex, and Yarin Gal. &quot;What uncertainties do we need in bayesian deep learning for computer vision?.&quot; Advances in neural information processing systems. 2017.</p>
]]></content>
      <categories>
        <category>Uncertainty</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>paper reading</tag>
        <tag>Uncertainty</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-PointPillars</title>
    <url>/paperreading-PointPillars/</url>
    <content><![CDATA[<h2 id="voxelnet-second-pointpillars">1. VoxelNet-&gt;SECOND-&gt;PointPillars</h2>
<p>　　相比于图像，激光点云数据是 3D 的，且有稀疏性，所以对点云的前期编码预处理尤其重要，目前大多数算法都是在鸟瞰图下进行点云物体检测，由此对点云的编码预处理主要有两大类方法：</p>
<ol type="1">
<li>以一定的分辨率将点云体素化，每个垂直列中的体素集合被编码成一个固定长度，手工制作的特征，最终形成一个三维的伪图像，以此为代表的方法有 MV3D，AVOD，PIXOR，Complex YOLO；</li>
<li>PointNet 无序点云处理方式，以此为代表的方法 Frustum PointNet<a href="#1" id="1ref"><sup>[1]</sup></a>, VoxelNet<a href="#2" id="2ref"><sup>[2]</sup></a>，SECOND<a href="#3" id="3ref"><sup>[3]</sup></a>，后两者是在鸟瞰图下进行编码的，需要 3D 卷积运算；</li>
</ol>
<p>　　本文提出的 PointPillar<a href="#4" id="4ref"><sup>[4]</sup></a> 是延续 VoxelNet，SECOND 的工作，VoxelNet 将 PointNet(<a href="/PointNet-系列论文详读/" title="PointNet-系列论文详读">PointNet-系列论文详读</a>) 思想引入体素化后的体素特征编码中，然后采用 3D 卷积做特征提取，再用传统的 2D 卷积进行目标检测；SECOND 则考虑到点云特征的稀疏性，用 2D 稀疏卷积代替传统卷积，速度得到了很大的提示。而 PointPillar 则在体素的垂直列上不做分割，从而移除了 3D 卷积的操作，其优点有：</p>
<ul>
<li>无手工编码的过程，利用了点云的所有信息，且无需要调节的参数；</li>
<li>运算均为 2D 卷积，高效；</li>
<li>可迁移至其它点云数据；</li>
</ul>
<p>　　这三篇工作框架结构基本一致，由三部分组成：</p>
<ol type="1">
<li>特征编码网络(Encoder，作特征编码)，在鸟瞰图下，将点云编码为稀疏的伪图像；</li>
<li>卷积中间网络(Middle，作特征提取)，将伪图像用 backbone 网络进行特征提取；</li>
<li>区域生成网络(RPN)，也可以是 SSD FPN 等检测头的改进，用于分类和回归 3D 框，与图像检测不一样的地方是，点云鸟瞰图下的最后一层特征层不能很小；</li>
</ol>
<p><img src="/paperreading-PointPillars/PointPillar.png" width="100%" height="100%" title="图 3. PointPillar 网络框架"> 　　如图 1. 所示，本文 Pointpillar 主要的工作集中在特征编码网络，所以以下主要介绍其特征编码网络方式，以及实现细节。</p>
<h2 id="特征编码">2. 特征编码</h2>
<p>　　Pointpillar 只对 \(x-y\) 平面作 \(H\times W\) 栅格化，栅格化后形成 \(H\times W=P\) 个柱子(Pillar)，每个柱子采样出 \(N\) 个点，每个点编码为 \(D=9\) 维的向量：\(\{x,y,z,r,x_c,y_c,z_c,x_p,y_p \}\)，其中 \(\{x_c,y_c,z_c\}\) 为该点与柱子内所有点的均值点的距离，\(x_p,y_p \) 为该点与柱子中心的距离。综上最后形成\((D,P,N )\) 维的张量，然后用 PointNet 网络输出 \((C,P,N )\) 维的张量，最后用 \(MAX\) 操作输出 \((C,P) = (C,H,W)\) 的伪图像。</p>
<h2 id="实现细节">3. 实现细节</h2>
<ol type="1">
<li><p>特征编码</p>
<ul>
<li>只取有点的柱子，所以 \(P &lt; H\times W\)</li>
<li>计算量较大，需要并行加速，我复现的时候是将柱子信息离线存下来的</li>
<li>pointpillar 方式可能只比高度体素采样方式效果高一点</li>
</ul></li>
<li><p>训练</p>
<ul>
<li>针对不同的类别设定唯一尺寸的 anchor，角度上旋转 90 度，所以每个点上每个类别是有两个 anchor</li>
<li>正负样本严重不均衡，所以需要 OHEM 或者 focalloss 技术</li>
</ul></li>
</ol>
<p><a id="1" href="#1ref">[1]</a> Qi, Charles R., et al. &quot;Frustum pointnets for 3d object detection from rgb-d data.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="2" href="#2ref">[2]</a> Zhou, Yin, and Oncel Tuzel. &quot;Voxelnet: End-to-end learning for point cloud based 3d object detection.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="3" href="#3ref">[3]</a> Yan, Yan, Yuxing Mao, and Bo Li. &quot;Second: Sparsely embedded convolutional detection.&quot; Sensors 18.10 (2018): 3337.<br>
<a id="4" href="#4ref">[4]</a> Lang, Alex H., et al. &quot;PointPillars: Fast encoders for object detection from point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>Study Topic List</title>
    <url>/study-topic-list/</url>
    <content><![CDATA[<p>　　本文罗列了相关领域知识的学习资料。</p>
<h2 id="detection">1. Detection</h2>
<h3 id="d-detection">1.1. 2D Detection</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34142321" target="_blank" rel="noopener">入门</a></li>
<li><a href="https://github.com/amusi/awesome-object-detection" target="_blank" rel="noopener">amusi</a></li>
<li><span class="citation" data-cites="handong">[Object Detection @handong]</span>(https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html#yolov3)</li>
<li><a href="http://www.telesens.co/2018/03/11/object-detection-and-classification-using-r-cnns/" target="_blank" rel="noopener">Object Detection and Classification using R-CNNs</a></li>
<li><a href="https://paperswithcode.com/task/object-detection" target="_blank" rel="noopener">Paper with Code</a></li>
</ul>
<h3 id="d-detection-1">1.2. 3D Detection</h3>
<ul>
<li><a href="https://paperswithcode.com/task/3d-object-detection" target="_blank" rel="noopener">Paper with Code</a></li>
<li><a href="http://www.cvlibs.net/datasets/kitti/eval_object.php?obj_benchmark=3d" target="_blank" rel="noopener">KITTI Leaderboard</a></li>
</ul>
<hr>
<h2 id="tracking">2. Tracking</h2>
<h3 id="single-object-tracking">2.1. Single Object Tracking</h3>
<ul>
<li><a href="https://paperswithcode.com/task/visual-object-tracking" target="_blank" rel="noopener">Paper with Code</a></li>
</ul>
<h3 id="multi-object-tracking">2.2. Multi Object Tracking</h3>
<ul>
<li><a href="https://paperswithcode.com/task/multiple-object-tracking" target="_blank" rel="noopener">Paper with Code</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65177442" target="_blank" rel="noopener">Paper List</a></li>
<li><a href="https://motchallenge.net/results/MOT17/" target="_blank" rel="noopener">MOT Challenge</a></li>
<li><a href="https://arxiv.org/abs/1409.7618" target="_blank" rel="noopener">综述：Multiple Object Tracking: A Literature Review</a></li>
<li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2013/html/Wu_Online_Object_Tracking_2013_CVPR_paper.html" target="_blank" rel="noopener">综述：Online object tracking: A benchmark</a></li>
<li><a href="https://arxiv.org/abs/1504.01942" target="_blank" rel="noopener">综述：MOTChallenge 2015: Towards a benchmark for multi-target tracking</a></li>
</ul>
<hr>
<h2 id="computational-photography">3. Computational Photography</h2>
<ul>
<li><a href="http://graphics.cs.cmu.edu/courses/15-463/2017_fall/" target="_blank" rel="noopener">2017年秋季的计算摄影学课程15-463</a></li>
</ul>
<hr>
<h2 id="cnn-acc">4. CNN ACC</h2>
<hr>
<h2 id="slam">5. SLAM</h2>
<h3 id="理论知识">5.1. 理论知识</h3>
<ul>
<li><a href="http://cvrs.whu.edu.cn/downloads/ebooks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95.pdf" target="_blank" rel="noopener">计算机视觉中的数学方法</a></li>
<li><a href="http://cvrs.whu.edu.cn/downloads/ebooks/Multiple%20View%20Geometry%20in%20Computer%20Vision%20%28Second%20Edition%29.pdf" target="_blank" rel="noopener">Multiple View Geometry in Computer Vision</a></li>
<li><a href="https://docs.ufpr.br/~danielsantos/ProbabilisticRobotics.pdf" target="_blank" rel="noopener">Probabilistic Robotics</a>(有中文版)</li>
<li><a href="http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf" target="_blank" rel="noopener">State Estimation for Robotics</a>(有中文版)</li>
<li><a href="https://github.com/gaoxiang12/slambook" target="_blank" rel="noopener">视觉SLAM十四讲</a></li>
</ul>
<h3 id="综述">5.2. 综述</h3>
<ul>
<li>[Visual Odometry Part I: Fundamentals]</li>
<li>[Visual Odometry Part II: Matching, Robustness, Optimization, Applications]</li>
<li><a href="https://link.springer.com/content/pdf/10.1186%2Fs40064-016-3573-7.pdf" target="_blank" rel="noopener">Review of Visual Odometry: Types, Approaches, Challenges, and Applications</a></li>
<li><a href="https://ipsjcva.springeropen.com/track/pdf/10.1186/s41074-017-0027-2" target="_blank" rel="noopener">Visual SLAM algorithms: a Survey from 2010 to 2016</a></li>
<li><a href="http://www.cvc.uab.es/~asappa/publications/C__IEEE_IV_2012_W3.pdf" target="_blank" rel="noopener">Visual SLAM for Driverless Cars: a Brief Survey</a></li>
<li><a href="https://link.springer.com/article/10.1007/s10462-012-9365-8" target="_blank" rel="noopener">Visual Simultaneous Locations and Mapping: a Survey</a></li>
</ul>
<h3 id="工具">5.3. 工具</h3>
<ul>
<li><a href="http://www.guyuehome.com/column/ros-explore" target="_blank" rel="noopener">ROS</a></li>
<li><a href="https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html" target="_blank" rel="noopener">Opencv Camera Calibration</a></li>
<li><a href="http://www.vision.caltech.edu/bouguetj/calib_doc/" target="_blank" rel="noopener">Matlab Camera Calibration Toolbox</a></li>
<li><a href="http://wiki.ros.org/camera_calibration" target="_blank" rel="noopener">ROS Wiki Camera Calibration</a></li>
</ul>
<h3 id="算法">5.4. 算法</h3>
<ul>
<li><a href="https://openslam-org.github.io/" target="_blank" rel="noopener">OpenSLAM</a></li>
</ul>
<h3 id="其它资料">5.5. 其它资料</h3>
<ul>
<li><a href="https://www.zhihu.com/people/cheng-xu-yuan-10/posts" target="_blank" rel="noopener">计算机视觉life</a></li>
<li><a href="https://paperswithcode.com/task/visual-odometry" target="_blank" rel="noopener">Paper with Code</a></li>
</ul>
]]></content>
      <categories>
        <category>Trash</category>
      </categories>
  </entry>
  <entry>
    <title>Traveling-in-Serbia-Montenegro-Bosnia</title>
    <url>/traveling-in-Serbia-Montenegro-Bosnia/</url>
    <content><![CDATA[<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://leijie.oss-cn-shenzhen.aliyuncs.com/travel/Serbia-Montenegro-Bosnia.mp4","pic":"https://leijie.oss-cn-shenzhen.aliyuncs.com/travel/Serbia-Montenegro-Bosnia.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Anchor-Free Detection</title>
    <url>/Anchor-Free-Detection/</url>
    <content><![CDATA[<p>　　3D 目标检测的技术思路大多数源自 2D 目标检测，所以图像 2D 检测的技术更迭极有可能在将来影响 3D 检测的发展。目前 3D 检测基本还是 Anchor-Based 方法(也称为 Top-Down 方法)，而今年以来，Anchor-Free(也称为 bottom-Up 法) 的 2D 检测已经达到了 SOTA，所以本文来探讨下 Anchor-Free 的目标检测方法发展历程。<br>
<img src="/Anchor-Free-Detection/history.jpg" width="90%" height="90%" title="图 1. 目标检测发展历程"> 　　如图 1. 所示(图片出自<a href="https://zhuanlan.zhihu.com/p/82491218" class="uri" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82491218</a>)，每种技术思路的发展都是为了解决目标检测中的一些痛点，这些技术思路又交相互用，才推动目标检测往更简单、更高性能方向发展。列举一些主要的痛点：</p>
<ul>
<li><strong>正负样本不均衡及无法区分困难样本导致网络学习困难</strong>，two-stage;</li>
<li><strong>网络及后处理复杂</strong>，one-stage，包含 Anchor-Free 方法；</li>
<li><strong>尺度问题很难同时检测大小目标</strong>，pyramid-scale；</li>
<li><strong>框与特征的对齐问题导致提取出的目标特征有偏差</strong>，deformable；</li>
</ul>
<p>　　本文包含两大块，一块是 Anchor-Free 方法的概括总结，另一块是代表算法的详细分析。</p>
<h2 id="归纳总结">1. 归纳总结</h2>
<p>　　首先推荐下乃爷写的文章——<a href="https://zhuanlan.zhihu.com/p/68291859" target="_blank" rel="noopener">聊聊 Anchor 的“前世今生”</a>，高屋建瓴。本节也是打算聊聊 Anchor-Free 方法的来龙去脉，以及归纳总结下各算法的思路。<br>
　　由之前讨论的，其中一个比较大的问题是，目标检测中正负样本严重不平衡。这会导致网络学习时很难针对性的学习困难样本，而 two-stage 相比 one-stage 多了一级正样本的删选，所以在没有额外困难样本选择策略的情况下，two-stage 普遍比 one-stage 效果好。可以想象的是，更多 stage 这种级联结构效果会更好，但是网络会变得相当复杂。这个痛点极大地阻碍了 one-stage 以及 Anchor-Free(负样本更多) 方法的发展，OHEM 困难样本学习当然是种有效的方法，但是还不够，直到 RetinaNet 中 Focal Loss 的提出，有效解决了正负样本严重不均衡所导致的学习困难问题。由此不仅 Anchor-based one-stage 方法性能达到了 two-stage 高度，甚至 Anchor-Free 方法性能也达到了 SOTA。<br>
　　回顾 Anchor-Free 检测，最早的应该是 YOLO-v1<a href="#1" id="1ref"><sup>[1]</sup></a>，DenseBox<a href="#2" id="2ref"><sup>[2]</sup></a>，而 RetinaNet<a href="#3" id="3ref"><sup>[3]</sup></a> 中 Focal Loss 的提出，使得 Anchor-Free 方法引来爆发式发展。大体上可分为两种：</p>
<ol type="1">
<li><strong>回归目标角点，后处理需要匹配角点以生成目标框</strong>，以 CornerNet<a href="#4" id="4ref"><sup>[4]</sup></a> 为代表的一系列改进方法 CornerNet-Lite<a href="#5" id="5ref"><sup>[5]</sup></a>，CenterNet(KeyPoint Triplets)<a href="#6" id="6ref"><sup>[6]</sup></a>，ExtremeNet<a href="#7" id="7ref"><sup>[7]</sup></a>等；</li>
<li><strong>像素级别预测目标框的不同编码量</strong>，后处理很容易生成目标框，有 CenterNet(Objects as Points)<a href="#8" id="8ref"><sup>[8]</sup></a>，FCOS<a href="#9" id="9ref"><sup>[9]</sup></a>，FoveaBox<a href="#10" id="10ref"><sup>[10]</sup></a>，FSAF<a href="#11" id="11ref"><sup>[11]</sup></a>等；</li>
</ol>
<p>回归角点的方法继承了人体姿态估计的很多策略，backbone 都使用 Hourglass<a href="#14" id="14ref"><sup>[14]</sup></a> 网络，在单尺度上能提取有效的特征；而像素级别预测目标框的不同编码量，引入了 FPN<a href="#15" id="15ref"><sup>[15]</sup></a> 网络进行多尺度检测，解决大小框在同一中心点或有相同角点的情况(CenterNet 还是使用了 Hourglass 网络，因为单尺度能很容易融合 3D 检测，人体姿态估计等任务)。此外，RepPoints<a href="#12" id="12ref"><sup>[12]</sup></a> 延续了 Deformable Conv 的工作，去掉了角点的框约束，使得角点一定贴合目标的边缘，本质上基本解决了以上所列的问题，其思想很值得借鉴。</p>
<h2 id="cornernet4-cornernet-lite5">2. CornerNet<a href="#4" id="4ref"><sup>[4]</sup></a>, CornerNet-Lite<a href="#5" id="5ref"><sup>[5]</sup></a></h2>
<h3 id="网络结构">2.1. 网络结构</h3>
<p><img src="/Anchor-Free-Detection/CornerNet-arch.png" width="80%" height="80%" title="图 2.1. CornerNet 框架"> <img src="/Anchor-Free-Detection/CornerNet-arch2.png" width="80%" height="80%" title="图 2.2. CornerNet 网络结构"> 　　如图 2.1 与 2.2 所示，CornerNet 的 backbone 采用了人体关键点检测中常用的 Hourglass 网络，这种沙漏网络类似多层 FPN，能有效提取细节信息；网络最终输出的是 Top-Left Corners Heatmaps，Bottom-Right Corners Heatmaps，以及对应的 Embeddings，Offsets。这里以 Top-Left Corners 分支为例，说明其网络计算过程。 <img src="/Anchor-Free-Detection/CornerNet-block.png" width="80%" height="80%" title="图 2.3. CornerNet"> 　　如图 2.3. 所示，这里引入 Corner Pooling Module，该模块能提取角点的上下文信息，其计算过程是行最大值与列最大值的叠加。网络输出的:</p>
<ul>
<li>Score Heatmaps \(\in\mathbb{R}^{C\times H\times W}\)，每个 Channel 的监督项是个二值图，代表了是否是该类别下的角点；</li>
<li>Embeddings \(\in\mathbb{R}^{C\times H\times W}\)，每个角点都会预测一个 Embedding 值(度量空间下的值)，用来对 top-left 与 bottom-right 角点的配对；</li>
<li>Offsets \(\in\mathbb{R}^{2\times H\times W}\)，由于 \(H\times W\) 可能是原图的下采样，所以变换到原图的角点坐标会有离散偏差，需要预测 Offsets 修正，类别无关或者类别有关都可以；</li>
</ul>
<p>Inference 阶段，得到这三个输出后，还需要进行后处理才能得到目标检测框。后处理过程为：</p>
<ol type="1">
<li>对 Heatmaps 采用点 NMS 处理(可通过 \(3\times 3\) max-pooling 实现)得到分数最高的前 100 个 top-left 角点以及前 100 个 bottom-right 角点；</li>
<li>类内计算 top-left 角点与 bottom-right 角点的 Embedding L1 距离，删除大于 0.5 的配对；</li>
<li>通过 Offsets 调整配对的角点值；</li>
<li>计算配对的角点值的平均分数，作为该目标框的分数；</li>
</ol>
<p>相比 Anchor-based 方法，整个后处理还是相对较为简单，没有框之间的 IoU 计算。</p>
<h3 id="loss">2.2. Loss</h3>
<p>　　网络训练的 Loss 表示为： <span class="math display">\[ L= L_{det} + \alpha L_{pull} + \beta L_{push} + \gamma L_{off} \tag{2.1}\]</span> 其中 \(L_{det}\) 是角点检测的 Loss 项，\(L_{pull}, L_{push}\)是 Embedding 距离监督项，\(L_{off}\)是 Offsets 的 Loss 项；\(\alpha,\beta,\gamma\)是权重。</p>
<ul>
<li>\(L_{det}\)<br>
角点检测是 pixel-level 的检测，每个角点虽然只有一个真值，但是靠近角点的像素点作为角点而构成的目标框与真值框重合度也会较高，所以在真值角点处设计高斯函数 \(e^ {-\frac{x^ 2+y^ 2}{2(r/3) ^ 2}}\) 作为标签衰减函数，\(r\) 值等于真值角点周围定义的圆的半径。圆半径由以下准则确定：四个角点为中心构成四个圆，在这区域内构成的目标框与真值框的 IoU 要小于 \(t\)(文中设为 0.3)。所以这里引入超参数 \(t\)。由此得到检测的 Loss 项： <span class="math display">\[ L_{det} = -\frac{1}{N}\sum_{c=1}^C\sum_{i=1}^H\sum_{j=1}^W
\left\{\begin{array}{l}
(1-p_{cij})^{\alpha} \mathrm{log}(p_{cij}) &amp; \mathrm{if} \; y_{cij}=1\\
(1-y_{cij})^{\beta} (p_{cij})^{\alpha} \mathrm{log}(1-p_{cij}) &amp; \mathrm{otherwise}
\end{array}\tag{2.2}\right.\]</span> 其中 \(p_{cij}\) 代表 Heatmaps 中 \(c\) 类别的 \((i,j)\) 位置预测的角点分数，\(y_{cij}\) 表示经过高斯衰减后的真值标签值。可以看出这是 Focal Loss 的变种，对平衡正负样本及学习困难样本有重要作用。</li>
<li>\(L_{off}\)<br>
原图点 \((x,y)\) 经过网络下采样后变换到 \((\lfloor\frac{x}{n}\rfloor,\lfloor\frac{y}{n}\rfloor)\)，与真值的 Offset 可表示为 \(\mathbf{o}_k=(\frac{x_k}{n}-\lfloor\frac{x_k}{n}\rfloor\, \frac{y_k}{n}-\lfloor\frac{y_k}{n}\rfloor)\)，由此可得 Offsets 的 Loss 项： <span class="math display">\[ L_{off}=\frac{1}{N}\sum_{k=1}^N\mathrm{SmoothL1Loss}(\mathbf{o}_k,\mathbf{\hat{o}}_k) \tag{2.3}\]</span></li>
<li>\(L_{pull}, L_{push}\)<br>
每个角点都会预测一个 Embedding 值，期望的是，同一个目标框的 top-left 角点与 bottom-right 角点的 Embedding 值要相近，不同框的角点的 Embedding 值差异要大，由此设计： <span class="math display">\[\left\{\begin{array}{l}
L_{pull} = \frac{1}{N}\sum_{k=1}^N\left[(e_{t_k}-e_k)^2+(e_{b_k}-e_k)^2\right] \\
L_{push} = \frac{1}{N(N-1)}\sum_{k=1}^N\sum_{j=1, j\not=k}^N\mathrm{max}(0,\Delta-|e_k-e_j|)
\end{array}\tag{2.4}\right.\]</span> 其中 \(e_{t_k}, e_{b_k}\) 分别表示 top-left 角点与 bottom-right 角点的 Embedding 值，\(e_k\) 是二者的平均值，\(\Delta\) 设定为 1。与 Offsets 一样，该 Loss 项也只作用于真值角点。</li>
</ul>
<h2 id="centernet-keypoint-triplets6">3. CenterNet: KeyPoint Triplets<a href="#6" id="6ref"><sup>[6]</sup></a></h2>
<h3 id="网络结构-1">3.1. 网络结构</h3>
<p><img src="/Anchor-Free-Detection/CenterNetKey-arch.png" width="80%" height="80%" title="图 3.1. CenterNet 框架"> 　　CenterNet 的 Motivation是：<strong>CornerNet 的 corner pooling 对目标框内的特征提取能力有限，以及角点匹配得到的目标框在没有其它约束下有时候检测结果会出错。</strong>由此，如图 3.1 所示，CenterNet 在 CornerNet 基础上增加了 Center 的预测分支，并引入 center pooling 以及 cascade corner pooling 模块。<br>
　　Inference 处理时，预测的 Center 点用于删除不合理的框。具体的，取 top-left 角点与 bottom-right 角点匹配后得到的目标框中心点，在中心点附近检测是否有 Center 点，如没有，则删除该匹配；否则，保留该目标框，并用这三个点的平均分数代表该目标框的分数。 <img src="/Anchor-Free-Detection/CenterNetKey-pool2.png" width="60%" height="60%" title="图 3.2. CenterNet pooling Module"> 　　如图 3.2 所示，CenterNet 引入 center pooling 并升级了 cascade corner pooling，这两个模块极大的提升了目标框内的特征提取融合能力，类似 ROI-pooling 的作用。具体的：</p>
<ul>
<li><strong>Center Pooling</strong>，叠加了水平和垂直方向上的最大值；</li>
<li><strong>Cascade Corner Pooling</strong>，不同于 Corner Pooling 只在角点所在的目标框边缘处取最大值，它还在目标框的内部取得最大值；</li>
</ul>
<p><img src="/Anchor-Free-Detection/CenterNetKey-pool.png" width="60%" height="60%" title="图 3.3. CenterNet pooling Module"> 　　如图 3.3 所示，这两个模块可通过不同方向的 corner pooling 组合而成，实现也较为简单。</p>
<h3 id="loss-1">3.2. Loss</h3>
<p>　　相比 CornerNet，增加了 center Heatmaps 的 Loss 项，其它都一样： <span class="math display">\[ L= L_{det}^{co} + L_{det}^{ce} + \alpha L_{pull}^{co} + \beta L_{push}^{co} + \gamma \left(L_{off}^{co}+L_{off}^{ce}\right) \tag{3.1}\]</span></p>
<h2 id="extremenet7">4. ExtremeNet<a href="#7" id="7ref"><sup>[7]</sup></a></h2>
<p><img src="/Anchor-Free-Detection/ExtremeNet-arch.png" width="80%" height="80%" title="图 4.1. ExtremeNet 框架"> 　　如图 4.1 所示，ExtremeNet 继承了 CornerNet(CenterNet) 主干，所不同的是，ExtremeNet 预测了目标的上下左右四个点，这四个点都是在目标上的，而传统的目标框上的左上及右下点则离目标有一定距离。所以输出上，角点的 Heatmaps \(\in\mathbb{I}^{4\times C\times H\times W}\)，Center 点 Heatmaps \(\in\mathbb{I}^{C\times H\times W}\)，只对角点预测 Offsets \(\in\mathbb{R}^{4\times 2\times H\times W}\)，去掉了 Embedding 的预测。</p>
<p><img src="/Anchor-Free-Detection/ExtremeNet-post.png" width="40%" height="40%" title="图 4.2. ExtremeNet 后处理"> 　　CornerNet 与 CenterNet 因为预测的角点是目标框的左上及右下点，所以 Embedding 能较好的用于角点配对，而 ExtremeNet 预测的角点可能在目标框的任意位置，所以作者采用暴力穷举匹配的方法，实验表面效果也更好。如图 4.2 所示，最后判断是否是一个匹配到的角点，与 CenterNet 类似，也是判断待匹配角点的中心角点上是否有较强的 Center 响应。</p>
<h2 id="centernet-objects-as-points8">5. CenterNet: Objects as Points<a href="#8" id="8ref"><sup>[8]</sup></a></h2>
<p><img src="/Anchor-Free-Detection/CenterNetObj-arch.png" width="80%" height="80%" title="图 5.1. CenterNet 网络结构"> 　　如图 5.1 所示，CenterNet 网络大体上还是继承了 CornerNet，在 2D 检测上，CenterNet 预测目标框的中心点 Center \(\in\mathbb{I}^{C\times H\times W}\)，中心点 Offsets \(\in\mathbb{R}^{2\times H\times W}\)，以及目标框的尺寸 size \(\in\mathbb{R}^{2\times C\times H\times W}\)。其 Loss 为： <span class="math display">\[ L_{det}=L_k + \lambda_{size}L_{size}+\lambda_{off}L_{off} \tag{5.1} \]</span> 　　Inference 的后处理只需要对 Center Heatmaps 作 3x3 的 max-pooling，<strong>不需要对目标框作 NMS</strong>！</p>
<p><img src="/Anchor-Free-Detection/CenterNetObj-tasks.png" width="40%" height="40%" title="图 5.2. CenterNet 多任务输出"> 　　此外，这种 pixel-level 的预测容易将其它任务也包含进来，如图 5.2 所示，作者还融入了 3D 检测，人体姿态估计。<br>
　　3D 检测任务中，预测项为:</p>
<ul>
<li>目标距离编码量 \(\sigma(\hat{d}_k)\in\mathrm{(0,1)}^{3\times C\times H\times W}\)，由于直接回归距离比较困难，实际距离的回归量为 \(\frac{1}{\sigma(\hat{d}_k)}-1\);</li>
<li>三围尺寸 \(\hat{\gamma}_k\in\mathbb{R}^{3\times C\times H\times W}\)，包括长，宽，高；</li>
<li>角度 \(\hat{\theta}_k\in\mathrm{[-\pi/2,\pi/2]}^{C\times H\times W}\)，直接回归比较困难，借鉴目前用的比较多的分类+回归的思想，设计编码量 \(\hat{\alpha}_k\in\mathbb{R}^{8\times C\times H\times W}\)，将角度划分为两个 bin，\(B_1=\left[-\frac{7\pi}{6},\frac{\pi}{6}\right]\)，\(B_2=\left[-\frac{\pi}{6},\frac{7\pi}{6}\right]\)，每个 bin 有四个预测量，其中两个预测量用来作 softmax 分类，另外两个预测量作相对于 bin 中心点 \(m_i\) 的 sin，cos 的 Offsets 量；</li>
</ul>
<p>综上，3D 检测的 Loss 为： <span class="math display">\[\left\{\begin{array}{l}
L_{dep} = \frac{1}{N}\sum_{k=1}^N\left\vert\frac{1}{\sigma(\hat{d}_k)}-1-d_k\right\vert \\
L_{dim} = \frac{1}{N}\sum_{k=1}^N\left\vert\hat{\gamma}_k-\gamma_k\right\vert \\
L_{ori} = \frac{1}{N}\sum_{k=1}^N\sum_{i=1}^2\left(softmax\left(\hat{b}_i,c_i\right)+c_i\left\vert \hat{a}_i-a_i\right\vert\right)
\end{array}\tag{5.2}\right.\]</span> 其中 \(c_i=\mathbb{1}(\theta\in B_i)\)，\(a_i=\left(\mathrm{sin}(\theta-m_i),\mathrm{cos}(\theta-m_i)\right)\)，预测的角度可解码为 \(\hat{\theta}=arctan2\left(\hat{a}_{i1},\hat{a}_{i2}\right)+m_i\)。</p>
<h2 id="fcos9">6. FCOS<a href="#9" id="9ref"><sup>[9]</sup></a></h2>
<h3 id="网络结构-2">6.1. 网络结构</h3>
<p><img src="/Anchor-Free-Detection/FCOS-res.png" width="40%" height="40%" title="图 6.1. FCOS 目标框定义方式"> 　　如图 6.1 所示，FCOS 提出了另一种目标框的表示方式，“参考点”+\((l,t,r,b)\)，当“参考点”是中心点时，就退化为中心点+尺寸的方式了。这种方式弱化了中心点的重要性，一定程度上“更有可能”回归出准确的目标框。 <img src="/Anchor-Free-Detection/FCOS-arch.png" width="80%" height="80%" title="图 6.2. FCOS 网络结构"> 　　如图 6.2 所示，FCOS 继承了 RetinaNet 主体网络，采用 FPN 形式，在不同尺度的特征层上进行目标检测。HourGlass 设计之初就是用于 pixel-level 的预测的，而 FPN 多尺度检测一定程度上更有利于框检测，<strong>不同尺度上检测不同大小的框能有效解决两个大小框中心点重合的情况</strong>，HourGlass 则无法解决，虽然这种情况很少。网络预测量有：</p>
<ul>
<li>Score Heatmaps \(\in\mathbb{R}^{C\times H\times W}\)，每个 Channel 的监督项是个二值图，代表了是否是该类别下的角点；</li>
<li>Regression \(\in\mathbb{R}^{4\times H\times W}\)，“参考点” 上的 \((l,t,r,b)\)；</li>
<li>Center-ness \(\in\mathbb{R}^{1\times H\times W}\)，监督“参考点”趋向于中心点，因为接近目标框边缘的“参考点”效果会比较差；</li>
</ul>
<h3 id="多尺度检测">6.2. 多尺度检测</h3>
<p>　　不同于 Hourglass 网络只在一个尺度上进行预测，FPN 在多尺度上对真值框的划分会比较复杂，基本准则是：<strong>不同尺度要检测不同尺寸的目标框，尺度越大(特征层越小)要检测的目标框尺寸越大</strong>。所以在真值框监督的划分上，具体的，如图 6.2 所示，多尺度特征表示为 \(\{P_i|i=3,4,5,6,7\}\)，对应每个特征层能回归的最大像素距离设定为 \(\{m_i|i=2,3,4,5,6,7\} = \{0,64,128,256,512,\infty\}\)。监督第 \(i\) 特征层学习的正样本真值框需满足： <span class="math display">\[ m_{i-1}&lt;\mathrm{max}(l^{gt},t^{gt},r^{gt},b^{gt})\le m_i \tag{6.1}\]</span></p>
<h3 id="loss-2">6.3. Loss</h3>
<p>　　Loss 由三部分组成：</p>
<ul>
<li><p>类别分类<br>
目标框内的所有点都作为正样本，所以直接采用 Focal Loss 中的 Loss 定义方式： <span class="math display">\[ L_{det} = -\alpha(1-p_k)^\gamma\mathrm{log}(p_k) \tag{6.2}\]</span></p></li>
<li><p>目标框回归<br>
传统的 L2 Loss 用于目标框的直接回归有两个问题：</p>
<ol type="1">
<li>目标框参数只是作独立的优化；</li>
<li>较大的目标框有较大的 Loss；</li>
</ol></li>
</ul>
<p>这里采用 UnitBox 中提出的 IoU Loss<a href="#13" id="13ref"><sup>[13]</sup></a>： <span class="math display">\[ L_{box} = -\mathrm{ln}(IoU_k) \tag{6.3} \]</span></p>
<ul>
<li>参考点中心化监督<br>
不像 CornerNet 之流，这里的参考点全作为正样本，并没有向负样本方向的权重衰减，所以为了参考点趋向于中心点，作者提出了 Center-ness，其真值监督项为： <span class="math display">\[ centerness^{gt} = \sqrt{\frac{\mathrm{min}(l^{gt},r^{gt})}{\mathrm{max}(l^{gt},r^{gt})} \times \frac{\mathrm{min}(t^{gt},b^{gt})}{\mathrm{max}(t^{gt},b^{gt})}} \tag{6.4} \]</span> 从而可用 L1 Loss 来计算该项的 Loss。</li>
</ul>
<h2 id="foveabox10">7. FoveaBox<a href="#10" id="10ref"><sup>[10]</sup></a></h2>
<p><img src="/Anchor-Free-Detection/Fovea-arch.png" width="60%" height="60%" title="图 7.1. FoveaBox 框架"> 　　如图所示，FoveaBox 完全继承了 RetinaNet 的主体网络，采用 FPN 形式。多尺度检测中的真值分配方式基本与 FCOS 一致，这里不做展开。 <img src="/Anchor-Free-Detection/Fovea-assign.png" width="60%" height="60%" title="图 7.2. FoveaBox 正负样本区域"> 　　正负样本的分配上，作者提出了 Fovea 区域，如图 7.2 所示，目标框收缩一定比例后的区域定义为正样本，收缩一定比例后的区域外定义为负样本。<br>
　　目标框的回归上，作者提出了另一种回归量，在 \((x,y)\) 像素点上，回归量定义为： <span class="math display">\[\left\{\begin{array}{l}
t_{x_1^{gt}} = \mathrm{log}\frac{2^l(x+0.5)-x_1^{gt}}{\sqrt{S_l}} \\
t_{y_1^{gt}} = \mathrm{log}\frac{2^l(y+0.5)-y_1^{gt}}{\sqrt{S_l}} \\
t_{x_2^{gt}} = \mathrm{log}\frac{x_2^{gt}-2^l(x+0.5)}{\sqrt{S_l}} \\
t_{y_2^{gt}} = \mathrm{log}\frac{y_1^{gt}-2^l(y+0.5)}{\sqrt{S_l}} \\
\end{array}\tag{7.1}\right.\]</span> 其中 \(S_l\) 为第 \(l\) 特征层设计的最大检测像素长度的平方。</p>
<h2 id="fsaf11">8. FSAF<a href="#11" id="11ref"><sup>[11]</sup></a></h2>
<p>　　网络结构及多尺度检测设置上与 FCOS，FoveaBox 并无新意。FSAF 新的东西是提出了多尺度特征层自动选择对应大小的真值目标框，用作本特征层的训练，具体选择的过程就是看每层特征层对该目标框输出的 Loss 大小，思想与 OHEM 或是 Focal Loss 差不多。该模块可与 Anchor-Based 方法一起嵌入到网络中。</p>
<h2 id="参考文献">9.参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Redmon, Joseph, et al. &quot;You only look once: Unified, real-time object detection.&quot; Proceedings of the IEEE conference on computer vision and pattern recognition. 2016.<br>
<a id="2" href="#2ref">[2]</a> Huang, Lichao, et al. &quot;Densebox: Unifying landmark localization with end to end object detection.&quot; arXiv preprint arXiv:1509.04874 (2015).<br>
<a id="3" href="#3ref">[3]</a> Lin, Tsung-Yi, et al. &quot;Focal loss for dense object detection.&quot; Proceedings of the IEEE international conference on computer vision. 2017.<br>
<a id="4" href="#4ref">[4]</a> Law, Hei, and Jia Deng. &quot;Cornernet: Detecting objects as paired keypoints.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018.<br>
<a id="5" href="#5ref">[5]</a> Law, Hei, et al. &quot;CornerNet-Lite: Efficient Keypoint Based Object Detection.&quot; arXiv preprint arXiv:1904.08900 (2019).<br>
<a id="6" href="#6ref">[6]</a> Duan, Kaiwen, et al. &quot;Centernet: Keypoint triplets for object detection.&quot; Proceedings of the IEEE International Conference on Computer Vision. 2019.<br>
<a id="7" href="#7ref">[7]</a> Zhou, Xingyi, Jiacheng Zhuo, and Philipp Krahenbuhl. &quot;Bottom-up object detection by grouping extreme and center points.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="8" href="#8ref">[8]</a> Zhou, X., Wang, D., &amp; Krähenbühl, P. (2019). Objects as Points arXiv preprint arXiv:1904.07850<br>
<a id="9" href="#9ref">[9]</a> Tian, Zhi, et al. &quot;FCOS: Fully Convolutional One-Stage Object Detection.&quot; arXiv preprint arXiv:1904.01355 (2019).<br>
<a id="10" href="#10ref">[10]</a> Kong, Tao, et al. &quot;FoveaBox: Beyond Anchor-based Object Detector.&quot; arXiv preprint arXiv:1904.03797 (2019).<br>
<a id="11" href="#11ref">[11]</a> Zhu, Chenchen, Yihui He, and Marios Savvides. &quot;Feature selective anchor-free module for single-shot object detection.&quot; arXiv preprint arXiv:1903.00621 (2019).<br>
<a id="12" href="#12ref">[12]</a> Yang, Ze, et al. &quot;RepPoints: Point Set Representation for Object Detection.&quot; arXiv preprint arXiv:1904.11490 (2019).<br>
<a id="13" href="#13ref">[13]</a> Yu, Jiahui, et al. &quot;Unitbox: An advanced object detection network.&quot; Proceedings of the 24th ACM international conference on Multimedia. ACM, 2016.<br>
<a id="14" href="#14ref">[14]</a> Newell, Alejandro, Kaiyu Yang, and Jia Deng. &quot;Stacked hourglass networks for human pose estimation.&quot; European conference on computer vision. Springer, Cham, 2016.<br>
<a id="15" href="#15ref">[15]</a> Lin, Tsung-Yi, et al. &quot;Feature pyramid networks for object detection.&quot; Proceedings of the IEEE conference on computer vision and pattern recognition. 2017.</p>
]]></content>
      <categories>
        <category>2D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>paper reading</tag>
        <tag>2D Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个 ADAS 产品</title>
    <url>/How-to-Build-An-ADAS/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="本文介绍了基于视觉的 ADAS 产品构建方法，全文 6K 字 12 图，请输入密码查看：" />
    <label for="pass">本文介绍了基于视觉的 ADAS 产品构建方法，全文 6K 字 12 图，请输入密码查看：</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Autonomous Driving System</category>
        <category>ADAS</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
        <tag>ADAS</tag>
      </tags>
  </entry>
  <entry>
    <title>LOAM(Lidar Odometry and Mapping)</title>
    <url>/LOAM/</url>
    <content><![CDATA[<p>　　SLAM 是机器人领域非常重要的一个功能模块，而基于激光雷达的 SLAM 算法，LOAM(Lidar Odometry and Mapping)，则应用也相当广泛。本文从经典的 LOAM 出发，详细描述下激光 SLAM<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a> 中的一些模块细节。</p>
<h2 id="问题描述">1. 问题描述</h2>
<h3 id="scan-定义">1.1. Scan 定义</h3>
<p>　　针对旋转式机械雷达，Scan 为单个激光头旋转一周获得的点云，类似 VLP-16 旋转一周则是“几乎”同时获得了 16 个 Scan。针对棱镜旋转而激光头不旋转的雷达(Solid State LiDARs)，如大疆 Livox 系列，Scan 则可定义为一定时间下累积获得的点云。</p>
<h3 id="sweep-定义">1.2. Sweep 定义</h3>
<p>　　Sweep 定义为静止的机器人平台上激光雷达能覆盖到所有空间的点云。<br>
　　针对旋转式机械雷达，Sweep 即为旋转一周获得的由一个或多个 Scan 组成的点云。针对棱镜旋转而激光头不旋转的雷达，由于其属于非重复性扫描(Non-repetitive Scanning)结构，所以 Sweep 理论上为时间趋于无穷大时获得的点云，但是狭义上，可以认为一段较长时间下(相对于 Scan 时间)，获得的点云。<br>
<img src="/LOAM/motor_lidar.png" width="60%" height="60%" title="图 1. 3D Lidar Updated from 2D Lidar with a Motor"> 　　那么，如果给激光雷达加上一个马达呢？如图 1. 所示，<a href="#1" id="1ref">[1]</a> 中设计了一种 3D Lidar 装置，由一个只有一个激光头的 2D Lidar 和一个马达组成，激光扫描频率为 40Hz，马达转速为 180°/s。这种装置下，Scan 意义不变，Sweep 则为 1s 内该装置获得的点云(因为 1s 的时间内，该装置获得的点云可覆盖所有能覆盖的空间)。</p>
<h3 id="非重复性扫描激光雷达">1.2. 非重复性扫描激光雷达</h3>
<p><img src="/LOAM/livox.png" width="60%" height="60%" title="图 2. Livox Scanning Pattern"> 　　其实，大疆的 Livox 非重复性扫描雷达相当于把这马达移到了内部的棱镜中，而且加上非对称，所以随着时间的累积，可获得相当稠密的点云。<br>
　　Livox 这种非重复式扫描的激光雷达价格低廉，相对于传统的多线激光雷达有很多优点，但是有个致命的缺点：<strong>只能准确捕捉静态物体，无法准确捕捉动态物体；对应的，只能作 Mapping，很难作动态障碍物的估计。</strong>因为在一帧点云的扫描周期 \(T\) 内，如果目标速度为 \(v\)，那么 Livox 式雷达在扫描周期内都会扫到目标，目标的尺寸会被放大 \(Tv\)，而传统旋转的线束雷达真正扫到目标的时间为 \(t\ll T\)。当 \(T=0.1s\)，\(v=20m/s\) 时，尺寸放大为 2m，而一般小汽车车长也就几米。<strong>所以尺寸是估不准的，但是其它属性，如位置，速度，在目标加速度不是很大的情况下，可能还是有技巧可以估准的，具体就得看实验效果。另一种思路：直接对其进行物理建模，先假设已知目标速度，那么所有点即可恢复出目标的真实尺寸，然后可进一步估计速度，由此迭代至最优值</strong>。<br>
　　由于本车的状态可以通过其它方式(如 IMU)获得，所以本车运动所引起的点云畸变(即 Motion Blur，基本所有雷达都会有这个问题，详见 2.3，4.1 章节)可以很容易得到补偿，所以对于静态目标，点云是能准确捕捉到其物理属性的。</p>
<h3 id="符号定义">1.3. 符号定义</h3>
<p>　　本文首先基于图 1. 的装置进行 LOAM 算法的描述，一般的多线激光雷达或是 Livox 雷达则可以认为是图 1. 的特殊形式，算法过程很容易由此导出。<br>
　　设第 \(k\) 次 Sweep 的点云为 \(\mathcal{P} _ k\)，Lidar 坐标系定义为此次 Sweep 初始扫描(也可定义为结束扫描)时刻 \(t_k\) 时， Lidar 位置下的坐标系 \(L\)，Sweep 由 \(S\) 个 Scan 组成，或由 \(I\) 个点组成，归纳为： <span class="math display">\[\mathcal{P} _ k = \{\mathcal{P}_{(k,s)}\}_{s=1}^S = \{\mathit{X}_{(k,i)}^L\}_{i=1}^I  \tag{1}\]</span> 定义 \(\mathit{T} _ k^L(t)\) 为 Lidar 从时间 \(t_k\to t\) 的位姿变换；定义 \(\mathit{T} _ {k}^L(t_{(k,i)})\)(简写为 \(\mathit{T} _ {(k,i)}^L\)) 为 \(t_{(k,i)}\) 时刻接收到的点 \(\mathit{X} _ {(k,i)}\) 变换到坐标系 \(L\)，即 Sweep 初始时刻 Lidar 位置，的变换矩阵。<br>
　　<strong>运动补偿问题</strong>： <span class="math display">\[\{\mathit{T} _ {(k,i)}^L\} _ {i=1}^I \tag{2}\]</span> 　　<strong>里程计问题</strong>： <span class="math display">\[\mathit{T} _ K^L(t) \prod _ {k=1}^K\mathit{T} _ {k-1}^L(t _ {k}) \tag{3}\]</span></p>
<h2 id="loam-for-2d-lidar-with-motor12">2. LOAM for 2D Lidar with Motor<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a></h2>
<p><img src="/LOAM/loam.png" width="70%" height="70%" title="图 3. LOAM Software System"> 　　硬件装置如图 1. 所示，这里不再赘述，软件算法流程如图 3. 所示，\(\mathcal{\hat{P}} _ k=\{\mathcal{P} _ {(k,s)}\}\) 为累积的 Scan 点云，其都会注册到 \(L\) 坐标系，得到 \(\mathcal{P} _ k\)。Lidar Odometry 由 \(\mathcal{\hat{P}} _ k\) 注册到 \(\mathcal{P} _ {k-1}\) 生成高频低精度的位姿，并且生成运动补偿后的 Sweep 点云(这里也可以用其它的里程计实现，如 IMU 等)；Lidar Mapping 则由 \(\mathcal{P}_k\) 注册到世界坐标系 \(W\) 下的地图 \(\mathcal{P}_m\) 中，生成低频高精度的位姿和地图；Transform Integration 则插值出高精度高频的位姿。</p>
<h3 id="feature-extraction">2.1. Feature Extraction</h3>
<p>　　这里提取的特征并没有描述子，更确切的说是找出有代表性的点。定义一种描述局部平面曲率的的变量： <span class="math display">\[c = \frac{1}{\vert \mathcal{S}\vert\cdot \Vert\mathit{X} _ {(k,i)}^L\Vert} \left\Vert\sum _ {j\in\mathcal{S},j\ne i}\left(\mathit{X} _ {(k,i)}^L-\mathit{X} _ {(k,j)}^L\right)\right\Vert \tag{3}\]</span> 其中 \(\mathcal{S}\) 为点 \(\mathit{X} _ {(k,i)}^L\) 相邻的同一 Scan 的点，其前后时序上各一半。根据 \(c\) 的值，由大到小选出 Edge Points 集，由小到大选出 Planar Points 集。最终选出的点需满足以下条件：</p>
<ol type="1">
<li>为了特征点的均匀分布，将空间进行栅格化，每个栅格最多容纳特定的点数；</li>
<li>被选择的点的周围点不会被选择；</li>
<li>对于 Planar Points 集中的点，如果其平面与雷达射线接近平行，那么则不予采用；</li>
<li>对于 Edge Points 集中的点，如果其处于被遮挡的区域边缘，那么也不予采用；</li>
</ol>
<h3 id="feature-registration">2.2. Feature Registration</h3>
<p><img src="/LOAM/icp.png" width="50%" height="50%" title="图 4. Registration"> 　　如图 4. 所示，Lidar Odometry 模块的作用是将累积的 Scan 注册到上一时刻的 Sweep 中。设 \(\mathcal{\bar{P}} _ {k-1}\) 为点云 \(\mathcal{P} _ {k-1}\) 投影到 \(t _ {k}\) 的 Lidar 坐标系 \(L _ k\) 后的表示。\(\mathcal{\tilde{E}} _ k, \mathcal{\tilde{H}} _ k\) 为 \(\mathcal{\hat{P}} _ k\) 中提取的 Edge Points 与 Planar Points 集，并转换到了 \(L _ k\) 坐标系。 <img src="/LOAM/loss.png" width="50%" height="50%" title="图 4. Edge & Planar Points Correspondence"></p>
<ol type="1">
<li><strong>Point to Edge</strong><br>
对于点 \(i\in\mathcal{\tilde{E}} _ k\)，如图 4. 所示，找到其最近的点 \(j\in\mathcal{\bar{P}} _ {k-1}\)，并在点 \(j\) 前后相邻的两个 Scan 中找到与点 \(i\) 最近的点，记为 \(l\)（同一 Scan 不会打到同一 Edge 处）。通过式 (3) 进一步确认 \(j,l\) 是否满足 Edge Points 的条件，如果满足，那么直线 \((j,l)\) 则就是点 \(i\) 的对应直线，误差函数为： <span class="math display">\[d _ {\mathcal{E}} = \frac{\left\vert \left(\mathit{\tilde{X}} _ {(k,i)}^L-\mathit{\bar{X}} _ {(k-1,j)}^L\right)\times\left(\mathit{\tilde{X}} _ {(k,i)}^L-\mathit{\bar{X}} _ {(k-1,l)}^L\right) \right\vert}{\left\vert\left(\mathit{\bar{X}} _ {(k-1,j)}^L-\mathit{\bar{X}} _ {(k-1,l)}^L\right)\right\vert} \tag{4}\]</span></li>
<li><strong>Point to Plane</strong><br>
对于点 \(i\in\mathcal{\tilde{H}} _ k\)，如图 4. 所示，找到其最近的点 \(j\in\mathcal{\bar{P}} _ {k-1}\)，并在点 \(j\) 同一 Scan 中找到与点 \(i\) 第二近的点 \(l\)，在其前后相邻的两个 Scan 中找到与点 \(i\) 最近的点，记为 \(m\)。通过式 (3) 进一步确认 \(j,l,m\) 是否满足 Planar Points 的条件，如果满足，那么平面 \((j,l,m)\) 则就是点 \(i\) 的对应面，误差函数为： <span class="math display">\[d _ {\mathcal{H}} = \frac{\left\vert \left(\mathit{\tilde{X}} _ {(k,i)}^L-\mathit{\bar{X}} _ {(k-1,j)}^L\right)^T\cdot\left(\left(\mathit{\bar{X}} _ {(k-1,j)}^L-\mathit{\bar{X}} _ {(k-1,l)}^L\right)\times\left(\mathit{\bar{X}} _ {(k-1,j)}^L-\mathit{\bar{X}} _ {(k-1,m)}^L\right)\right) \right\vert}{\left\vert\left(\mathit{\bar{X}} _ {(k-1,j)}^L-\mathit{\bar{X}} _ {(k-1,l)}^L\right)\times\left(\mathit{\bar{X}} _ {(k-1,j)}^L-\mathit{\bar{X}} _ {(k-1,m)}^L\right)\right\vert} \tag{5}\]</span></li>
</ol>
<h3 id="motion-estimation">2.3. Motion Estimation</h3>
<p>　　首先进行运动补偿，即求式(2)。记 \(\mathit{T} _ k^L(t) = [\mathit{R} _ k^L(t)\; \mathit{\tau} _ k^L(t)]\)。假设 \(t_k\to t\) 雷达为匀速运动，那么根据每个点的时间戳进行运动插值: <span class="math display">\[\mathit{T} _ {(k,i)}^L = 
\begin{bmatrix}
\mathit{R} _ {(k,i)}^L &amp; \mathit{\tau} _ {(k,i)}^L
\end{bmatrix} = 
\begin{bmatrix}
e^{\hat{\omega}\theta s} &amp; s\mathit{\tau} _ k^L(t)
\end{bmatrix} = 
\begin{bmatrix}
e^{\hat{\omega}\theta \frac{t _ {(k,i)}-t _ k}{t-t _ k}} &amp; \frac{t _ {(k,i)}-t _ k}{t-t _ k}\mathit{\tau} _ k^L(t)
\end{bmatrix} =
\begin{bmatrix}
\mathbf{I} + \hat{\omega} \mathrm{sin}\left(s\theta\right) + \hat{\omega}^2\left(1-\mathrm{cos}\left(s\theta\right)\right) &amp; s\mathit{\tau} _ k^L(t)
\end{bmatrix}
\tag{6}\]</span> 其中 \(\theta, \omega\) 分别是 \(\mathit{R} _ k^L(t)\) 的幅度与旋转角，\(\hat{\omega}\) 是 \(\omega\) 的 Skew Symmetric Matrix。<br>
　　由此，对于特征点集，有如下关系： <span class="math display">\[\begin{align}
\mathit{\tilde{X}} _ {(k,i)}^L &amp;= \mathit{T} _ {(k,i)}^L\mathit{X} _ {(k,i)} \\
\tag{7}
\end{align}\]</span> 带入式(4)(5)，可简化为以下非线性最小二乘优化函数： <span class="math display">\[f(\mathit{T} _ {k}^L(t)) = \mathbf{d} \tag{8}\]</span> 其中每一行表示一个特征点及对应的误差，用非线性优化使 \(\mathbf{d}\to \mathbf{0}\)： <span class="math display">\[\mathit{T} _ {k}^L(t)\gets \mathit{T} _ {k}^L(t) - (\mathbf{J}^T\mathbf{J}+\lambda\mathrm{diag(\mathbf{J}^T\mathbf{J})})^{-1}\mathbf{J}^T\mathbf{d} \tag{9}\]</span> 其中雅克比矩阵 \(\mathbf{J}=\frac{\partial f}{\partial \mathit{T} _ {k}^L(t)}\)；\(\lambda\) 由优化方法决定，如 LM，Gaussian-Newton 等。</p>
<h3 id="lidar-odometry">2.4. Lidar Odometry</h3>
<p><img src="/LOAM/loam_alg.png" width="40%" height="40%" title="图 5. Lidar Odometry Algorithm"> 　　Lidar Odometry 模块生成 10Hz 的高频低精度雷达位姿(雷达 Scan 频率为 40Hz)，1Hz 的去畸变的点云帧，算法过程如图 5. 所示，优化时对每个特征点根据匹配距离作了权重处理。这里求取雷达位姿 \(\mathit{T} _ k^L(t)\) 是通过点云注册实现的，<strong>也完全可以采用其它里程计，如 IMU 等</strong>。</p>
<h3 id="lidar-mapping">2.5. Lidar Mapping</h3>
<p>　　Lidar Mapping 模块生成 1Hz 的低频高精度雷达位姿以及地图。式(3)后半部分表示的就是本模块要求的第 \(t_k\) 时刻在世界坐标系下的低频高精度位姿 \(\mathit{T} _ {k-1}^W(t _ k)\)。设累积到第 \(k-1\) 个 Sweep 的地图为 \(\mathcal{Q} _ {k-1}\)，第 \(k\) 次 Sweep 点云 \(\mathcal{\bar{P}} _ k\) 在世界坐标系下的表示为 \(\mathcal{\bar{Q}} _ k \)，将 \(\mathcal{\bar{Q}} _ k \) 注册到世界地图 \(\mathcal{Q} _ {k-1}\) 中，就求解出了位姿 \(\mathit{T} _ {k}^W(t _ {k+1})\)。<br>
　　算法过程与 Lidar Odometry 类似，不同的是：</p>
<ol type="1">
<li>为了提升精度，特征点数量增加了好几倍(点云量也增多了，Sweep VS. Map)；</li>
<li>由于 Map 中无法区分相邻的 Scan，所以找 Map 中对应的 Edge 或 Planar 时，采用以下方法：找到该特征点在对应 Map 中最近的点集 \(\mathcal{S'}\)，计算该点集的协方差矩阵 \(\mathbf{M}\)，其特征值与特征向量为 \(\mathbf{V,E}\)。如果该点集分布属于 Edge Line，那么有一个显著较大的特征值，对应的特征向量代表该直线的方向；如果该点集分布属于 Planar Patch，那么有两个显著较大的特征值，最小特征值对应的特征向量表示了该平面的方向。由此找到 Point-to-Edge，Point-to-Plane 匹配。</li>
</ol>
<p>　　建图时需要对 Map 进行采样，通过 Voxel-Grid Filter 保持栅格内点的密度，由此减少内存及运算量，Edge Points 的栅格应该要比 Planar Points 的小。<br>
　　得到低频高精度雷达位姿后，结合 Lidar Odometry(式(3))，即可输出高频高精度(精度相对世界坐标系而言)的雷达位姿。</p>
<h2 id="loam-for-livox3">3. LOAM for Livox<a href="#3" id="3ref"><sup>[3]</sup></a></h2>
<p>　　1.2 小节中已经阐述了 Livox 雷达的特性，这里整理如下：</p>
<ol type="a">
<li><strong>Small FoV</strong><br>
包括 MEMS 这种 Solid State LiDARs，一般都有较小的视场角，不像旋转式机械雷达可达 360°；</li>
<li><strong>Irregular Scanning Pattern</strong><br>
如图 2. 所示，雷达扫描出的 Pattern 是无规则的，这就导致有效特征提取的难度提升；</li>
<li><strong>Non-repetitive Scanning</strong><br>
非重复性扫描，有利有弊；</li>
<li><strong>Motion Blur</strong><br>
包括自身运动及目标运动所产生的点云畸变。自身运动所导致的点云畸变可以通过估计自身运动后，对点云进行运动补偿来矫正；而由于帧内周期均会扫描到目标，所以目标运动所产生的点云畸变影响较大，且基本无法消除。</li>
</ol>
<h3 id="workflow">3.1. Workflow</h3>
<p><img src="/LOAM/livox_loam.png" width="90%" height="90%" title="图 6. Livox Loam"> 　　Livox LOAM 可以认为是 LOAM 的简化版，直接从每帧的点云中提取出 Edge Points 和 Planar Points，经过线性插值的运动补偿后，在 Map 中找到对应的 Edge Line 与 Planar Patch，由此建立优化函数。相比于 LOAM，本文干掉了高频低精度的 Lidar Odometry(因为 Livox 没有前后 Scan 概念，很难做 Scan-to-Sweep 的点云注册)，直接出 20Hz 高频高精度的 Odometry 与 Map(计算平台强+软件多线程)。<br>
　　此外本文针对雷达特性还作了更细致的工程改进，包括：</p>
<ol type="1">
<li>更严格的特征点选取<br>
去除视场边缘处的特征点；去除较大或较小反射强度的点；</li>
<li>改进的特征提取<br>
为了增多提取的特征点，将周围反射率变化较大的点也列入 Edge Points；</li>
<li>Outlier Rejection<br>
在优化迭代时，先迭代两步，然后去除掉有较大误差的点，最后作进一步迭代；</li>
<li>Dynamic Objects Filtering<br>
扣除掉动态障碍物的点云，这需要动态障碍物检测模块的支持；</li>
</ol>
<h2 id="loam-for-vlp-164">4. LOAM for VLP-16<a href="#4" id="4ref"><sup>[4]</sup></a></h2>
<h3 id="motion-blur">4.1. Motion Blur</h3>
<p>　　运动导致的点云畸变主要有两种：自身运动与目标运动。对于旋转式线束雷达来说，目标运动所导致的畸变基本可考虑不计(只有目标正好处于初始扫描与结束扫描的交界处时会有影响；Mapping 时则已扣掉动态障碍物，所以不影响)，这里主要讨论自身运动所导致的点云畸变影响。<br>
　　每帧激光雷达数据(即一次 Sweep)都会标记到同一时间戳，假设标记到初始扫描的时刻。假设激光雷达旋转一周的扫描周期为 \(T\)，考虑一次 Sweep：\(t\in [0,T]\)。假设在扫描周期内自身为匀速运动，速度为 \(v\)，那么场景中点云的最大偏移畸变为 \(vT\)。考虑两次 Sweep: \(t _ 1,t _ 2\)，对应的速度为 \(v _ 1, v _ 2\)，那么两个时刻对同一物体的点云偏差量为 \(v _ 1T,v _ 2T\)。在世界坐标系下，该物体观测的点云最坏的不一致量可达到 \(|v _ 1T+v _ 2T|\)(自身运动有旋转的时候)，当然大多数情况可能是 \(|v _ 1T-v _ 2T|\)。</p>
<ol type="a">
<li><strong>单帧情况</strong><br>
当 \(T=0.1s,v=20m/s\) 时，畸变量为 2m，对于目标检测算法，虽然目标整体漂移了约 2m，不影响检测(尺寸未变)，但是直接导致观测的目标位置漂了约 2m！如果目标正好处于初始扫描和结束扫描的位置，那么目标的尺寸也会失真。</li>
<li><strong>多帧情况</strong><br>
这种情况指 Mapping 的过程。如果 \(t _ 1, t _ 2\) 时间跨度大，那么世界坐标系下同一物体的不一致性会相当高。如果是相邻 \(n\) 帧，假设自身加速度为 \(a = 5m/s^2\)，那么不一致量为 \(|v _ 1T-v _ 2T|=nTaT=0.05n\)，相邻帧可达 5cm ！</li>
</ol>
<p>由此可见，不管是单帧任务还是多帧任务，点云的运动补偿不可不做。</p>
<h3 id="other">4.2. Other</h3>
<p>　　<a href="#4" id="4ref">[4]</a> 根据代码详细描述了 LOAM 应用到旋转式多线激光雷达的诸多细节，代码中采用了 IMU 里程计作为高频低精度的位姿估计。其它内容在以上章节中都有描述，这里就不再展开了。</p>
<h2 id="reference">5. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Zhang, Ji, and Sanjiv Singh. &quot;LOAM: Lidar Odometry and Mapping in Real-time.&quot; Robotics: Science and Systems. Vol. 2. No. 9. 2014.<br>
<a id="2" href="#2ref">[2]</a> Zhang, Ji, and Sanjiv Singh. &quot;Low-drift and real-time lidar odometry and mapping.&quot; Autonomous Robots 41.2 (2017): 401-416.<br>
<a id="3" href="#3ref">[3]</a> Lin, Jiarong, and Fu Zhang. &quot;Loam_livox: A fast, robust, high-precision LiDAR odometry and mapping package for LiDARs of small FoV.&quot; arXiv preprint arXiv:1909.06700 (2019).<br>
<a id="4" href="#4ref">[4]</a> https://zhuanlan.zhihu.com/p/57351961</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性最小二乘</title>
    <url>/Non-linear-Least-Squares/</url>
    <content><![CDATA[<p>　　非线性最小二乘(Non-linear Least Squares)问题应用非常广泛，尤其是在 SLAM 领域。<a href="/LOAM/" title="LOAM">LOAM</a>，，<a href="/[paper_reading]-Stereo-RCNN-based-3D-Object-Detection-for-Autonomous-Driving/" title="Stereo-RCNN">Stereo-RCNN</a>，<a href="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/" title="Stereo Vision-based Semantic and Ego-motion Tracking for Autonomous Driving">Stereo Vision-based Semantic and Ego-motion Tracking for Autonomous Driving</a> 等均需要求解非线性最小二乘问题。其中 <a href="/LOAM/" title="LOAM">LOAM</a> 作为非常流行的激光 SLAM 框架，其后端是一个典型的非线性最优化问题，本文会作为实践进行代码级讲解。</p>
<h2 id="问题描述">1. 问题描述</h2>
<p>　　在前端观测-后端优化框架下，设观测数据对集合为：\(\{y _ i,z _ i\} _ {i=1}^m\)，待求解的变量参数 \(x\in\mathbb{R}^n\) 定义了观测数据对的映射关系，即 \(z _ i=h(y _ i;x)\)，由此得到有 \(m\) 个参数方程 \(F(x)=[f _ 1(x),...,f _ m(x)]^T\)，其中 \(f _ i(x) = z _ i-h(y _ i;x)\)。我们要找到最优的参数 \(x\) 来描述观测数据对之间的关系，即求解的最优化问题为： <span class="math display">\[\begin{align}
\mathop{\arg\min}\limits _ x \frac{1}{2}\Vert F(x)\Vert ^2 \iff \mathop{\arg\min}\limits _ x\frac{1}{2}\sum _ i \rho _ i\left(\Vert f _ i(x)\Vert ^ 2\right)\\
L\leq x \leq U
\end{align}\tag{1}\]</span> 其中 \(f _ i(\cdot)\) 为 Cost Function，\(\rho _ i(\cdot)\) 为 Loss Function，即核函数，用来减少离群点对非线性最小二乘优化的影响；\(L,U\) 分别为参数 \(x\) 的上下界。当核函数 \(\rho _ i(x)=x\) 时，就是常见的非线性最小二乘问题。<br>
　　《视觉 SLAM 十四讲》<a href="#1" id="1ref"><sup>[1]</sup></a>在 SLAM 的状态估计问题中，从概率学角度导出了最大似然估计求解状态的方法，并进一步引出了最小二乘问题。回过头来看，本文很多内容在《视觉 SLAM 十四讲》中已经有非常清晰的描述，可作进一步参考。</p>
<h2 id="问题求解">2. 问题求解</h2>
<p>　　根据 \(F(x)\) 求得雅克比矩阵(Jacobian)：\(J(x) \in\mathbb{R}^{m\times n}\)，即 \(J _ {ij}(x)=\frac{\partial f _ i(x)}{\partial x _ j}\)。目标函数的梯度向量为 \(g(x) = \nabla\frac{1}{2}\Vert F(x)\Vert ^ 2=J(x)^TF(x)\)。在 \(x\) 处将目标函数线性化：\(F(x+\Delta x)\approx F(x)+J(x)\Delta x\)。由此非线性最小二乘问题可转换为线性最小二乘求解残差量 \(\Delta x\) 来近似求解： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x}\frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^ 2\tag{2}\]</span> 根据如何控制 \(\Delta x\) 的大小，非线性优化算法可分为两大类：</p>
<ul>
<li>Line Search
<ul>
<li>Gradient Descent</li>
<li>Gaussian-Newton</li>
</ul></li>
<li>Trust Region
<ul>
<li>Levenberg-Marquardt</li>
<li>Dogleg</li>
<li>Inner Iterations</li>
<li>Non-monotonic Steps</li>
</ul></li>
</ul>
<p>Line Search 首先确定迭代方向，然后最小化 \(\Vert f(x+\alpha \Delta x)\Vert ^2\) 确定迭代步长；Trust Region 则划分一个局部区域，在该区域内求解最优值，然后根据近似程度，扩大或缩减该局部区域范围。Trust Region 相比 Linear Search，数值迭代会更加稳定。这里介绍几种有代表性的方法：属于 Line Search 的梯度下降法，高斯牛顿法，以及属于 Trust Region 的 LM 法。</p>
<h3 id="梯度下降法">2.1. 梯度下降法</h3>
<p>　　将目标函数式(1)在 \(x\) 附近泰勒展开： <span class="math display">\[ \Vert F(x+\Delta x)\Vert ^2 \approx \Vert F(x)\Vert ^2 + J(x)\Delta x+\frac{1}{2}\Delta x^TH\Delta x \tag{3}\]</span> 其中 \(H\) 是二阶导数(Hessian 矩阵)。<br>
　　如果保留一阶导数，那么增量的解就为： <span class="math display">\[\Delta x = -\lambda J^T(x) \tag{4}\]</span> 其中 \(\lambda\) 为步长，可预先由相关策略设定。<br>
　　如果保留二阶导数，那么增量方程为： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x} \Vert F(x)\Vert ^2+J(x)\Delta x+\frac{1}{2}\Delta x^TH\Delta x\tag{5}\]</span> 对 \(\Delta x\) 求导即可求解增量的解为： <span class="math display">\[\Delta x = -H^{-1}J^T \tag{6}\]</span> 　　一阶梯度法又称为最速下降法，二阶梯度法又称为牛顿法。一阶和二阶法都是将函数在当前值下泰勒展开，然后线性得求解增量值。最速下降法过于贪心，容易走出锯齿路线，反而增加迭代步骤。牛顿法需要计算 \(H\) 矩阵，计算量较大且困难。</p>
<h3 id="高斯牛顿法">2.2. 高斯牛顿法</h3>
<p>　　 将式(2)对 \(\Delta x\) 求导并令其为零，可得： <span class="math display">\[\begin{align}
&amp;J(x)^TJ(x)\Delta x=-J(x)^TF(x)\\
\iff &amp; H\Delta x=g
\end{align}\tag{7}\]</span> 相比牛顿法，高斯牛顿法不用计算 \(H\) 矩阵，直接用 \(J^TJ\) 来近似，所以节省了计算量。但是高斯牛顿法要求 \(H\) 矩阵是可逆且正定的，而实际计算的 \(J^TJ\) 是半正定的，所以 \(J^TJ\) 会出现奇异或病态的情况，此时增量的稳定性就会变差，导致迭代发散。另一方面，增量较大时，目标近似函数式(2)就会产生较大的误差，也会导致迭代发散。这是高斯牛顿法的缺陷。高斯牛顿法的步骤为：</p>
<ol type="1">
<li>根据式 (7) 求解迭代步长 \(\Delta x\)；</li>
<li>变量迭代：\(x ^ * \leftarrow x+\Delta x\)；</li>
<li>如果 \(\Vert F(x ^ * )-F(x)\Vert &lt; \epsilon\)，则收敛，退出迭代，否则重复步骤 1.；</li>
</ol>
<p>高斯牛顿法简单的将 \(\alpha\) 置为 1，而其它 Line Search 方法会最小化 \(\Vert f(x+\alpha \Delta x)\Vert ^2\) 来确定 \(\alpha\) 值。</p>
<h3 id="lm-法">2.3. LM 法</h3>
<p>　　Line Search 依赖线性化近似有较高的拟合度，但是有时候线性近似效果较差，导致迭代不稳定；Region Trust 就是解决了这种问题。高斯牛顿法中采用的近似二阶泰勒展开只在该点附近有较好的近似结果，对 \(\Delta x\) 添加一个信赖域区域，就变为 Trust Region 方法。其最优化问题转换为： <span class="math display">\[\begin{align}
\mathop{\arg\min}\limits _ x \frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^2 \\
\Vert D(x)\Delta x\Vert ^2 \leq \mu\\
L\leq x \leq U\\
\end{align}\tag{8}\]</span> 用 Lagrange 乘子将其转换为无约束优化问题： <span class="math display">\[\mathop{\arg\min}\limits _ {\Delta x}\frac{1}{2}\Vert J(x)\Delta x+F(x)\Vert ^ 2+\frac{1}{\mu}\Vert D(x)\Delta x\Vert ^2 \tag{9}\]</span> 其中 Levenberg 提出的方法中 \(D=I\)，相当于把 \(\Delta x\) 约束在球中；Marquart 提出的方法中将 \(D\) 取为非负数对角阵，通常为 \(J(x)^TJ(x)\) 的对角元素平方根。<br>
　　对于信赖域区域 \(\mu\) 的定义，一个比较好的方式是根据近似模型与实际函数之间的差异来确定这个范围：如果差异小，那么增大信赖域；反之减小信赖域。因此，考虑： <span class="math display">\[\rho = \frac{\Vert F(x+\Delta x)\Vert ^2-\Vert F(x)\Vert ^2}{\Vert J(x)\Delta x+F(x)\Vert ^2-\Vert F(x)\Vert ^2} \tag{10}\]</span> 　　 将式(9)对 \(\Delta x\) 求导并令其为零，可得： <span class="math display">\[\begin{align}
&amp;\left(J(x)^TJ(x)+\frac{2}{\mu}D^T(x)D(x)\right)\Delta x=-J(x)^TF(x)\\
\iff &amp; (H+\lambda D^TD)\Delta x=g
\end{align}\tag{11}\]</span> 当 \(\lambda\) 较小时，接近于高斯牛顿法；当 \(\lambda\) 较大时，接近于最速下降法。LM 法的步骤为：</p>
<ol type="1">
<li>根据式(11)求解迭代步长 \(\Delta x\);</li>
<li>根据式(10)求解 \(\rho\);</li>
<li>若 \(\rho &gt; \eta _ 1\)，则 \(\mu = 2\mu\);</li>
<li>若 \(\rho &lt; \eta _ 2\)，则 \(\mu = 0.5\mu\);</li>
<li>若 \(\rho &gt; \epsilon\)，则 \(x ^ * \leftarrow x+\Delta x\)；</li>
<li>如果满足收敛条件，则结束，否则继续步骤1.；</li>
</ol>
<h2 id="ceres-实践">3. Ceres 实践</h2>
<p>　　Ceres 是谷歌开发的一个用于非线性优化的库，使用 Ceres 库有以下几个步骤：</p>
<ul>
<li>构建 Cost Function，式(1)中的 \(\rho _ i\left(\Vert f _ i(x)\Vert ^ 2\right)\) 即为代码中需要增加的 ResidualBlock；</li>
<li>累加的 Cost Function 构成最终的 Loss Function 目标函数；</li>
<li>配置求解器参数并求解问题；</li>
</ul>
<h3 id="例子-曲线拟合">3.1. 例子-曲线拟合</h3>
<p>　　以下代码为拟合曲线参数的简单例子：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy from http://zhaoxuhui.top/blog/2018/04/04/ceres&amp;ls.html</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ceres;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector,用于存放x、y的观测数据</span></span><br><span class="line"><span class="comment">//待估计函数为y=3.5x^3+1.6x^2+0.3x+7.8</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; xs;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义CostFunctor结构体用于描述代价函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CostFunctor</span>&#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">double</span> x_guan,y_guan;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//构造函数，用已知的x、y数据对其赋值</span></span><br><span class="line">  CostFunctor(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span><br><span class="line">  &#123;</span><br><span class="line">    x_guan = x;</span><br><span class="line">    y_guan = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载括号运算符，两个参数分别是估计的参数和由该参数计算得到的残差</span></span><br><span class="line">  <span class="comment">//注意这里的const，一个都不能省略，否则就会报错</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> params,T* residual)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    residual[<span class="number">0</span>]=y_guan-(params[<span class="number">0</span>]*x_guan*x_guan*x_guan+params[<span class="number">1</span>]*x_guan*x_guan+params[<span class="number">2</span>]*x_guan+params[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成实验数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  RNG rng;</span><br><span class="line">  <span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> x = i;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">3.5</span>*x*x*x+<span class="number">1.6</span>*x*x+<span class="number">0.3</span>*x+<span class="number">7.8</span>;</span><br><span class="line">    xs.push_back(x);</span><br><span class="line">    ys.push_back(y+rng.gaussian(w_sigma));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xs.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;xs[i]&lt;&lt;<span class="string">" y:"</span>&lt;&lt;ys[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单描述我们优化的目的就是为了使我们估计参数算出的y'和实际观测的y的差值之和最小</span></span><br><span class="line"><span class="comment">//所以代价函数(CostFunction)就是y'-y，其对应每一组观测值与估计值的残差。</span></span><br><span class="line"><span class="comment">//由于我们优化的是残差之和，因此需要把代价函数全部加起来，使这个函数最小，而不是单独的使某一个残差最小</span></span><br><span class="line"><span class="comment">//默认情况下，我们认为各组的残差是等权的，也就是核函数系数为1。</span></span><br><span class="line"><span class="comment">//但有时可能会出现粗差等情况，有可能不等权，但这里不考虑。</span></span><br><span class="line"><span class="comment">//这个求和以后的函数便是我们优化的目标函数</span></span><br><span class="line"><span class="comment">//通过不断调整我们的参数值，使这个目标函数最终达到最小，即认为优化完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  generateData();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建一个长度为4的double数组用于存放参数</span></span><br><span class="line">  <span class="keyword">double</span> params[<span class="number">4</span>]=&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一步，创建Problem对象，并对每一组观测数据添加ResidualBlock</span></span><br><span class="line">  <span class="comment">//由于每一组观测点都会得到一个残差，而我们的目的是最小化所有残差的和</span></span><br><span class="line">  <span class="comment">//所以采用for循环依次把每个残差都添加进来</span></span><br><span class="line">  Problem problem;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xs.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//利用我们之前写的结构体、仿函数，创建代价函数对象，注意初始化的方式</span></span><br><span class="line">    <span class="comment">//尖括号中的参数分别为误差类型，输出维度(因变量个数)，输入维度(待估计参数的个数)</span></span><br><span class="line">    CostFunction* cost_function = <span class="keyword">new</span> AutoDiffCostFunction&lt;CostFunctor,<span class="number">1</span>,<span class="number">4</span>&gt;(<span class="keyword">new</span> CostFunctor(xs[i],ys[i]));</span><br><span class="line">    <span class="comment">//三个参数分别为代价函数、核函数和待估参数</span></span><br><span class="line">    problem.AddResidualBlock(cost_function,<span class="literal">NULL</span>,params);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第二步，配置Solver</span></span><br><span class="line">  Solver::Options options;</span><br><span class="line">  <span class="comment">//配置增量方程的解法</span></span><br><span class="line">  options.linear_solver_type=ceres::DENSE_QR;</span><br><span class="line">  <span class="comment">//是否输出到cout</span></span><br><span class="line">  options.minimizer_progress_to_stdout=<span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第三步，创建Summary对象用于输出迭代结果</span></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第四步，执行求解</span></span><br><span class="line">  Solve(options,&amp;problem,&amp;summary);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第五步，输出求解结果</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;summary.BriefReport()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p0:"</span>&lt;&lt;params[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1:"</span>&lt;&lt;params[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2:"</span>&lt;&lt;params[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p3:"</span>&lt;&lt;params[<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="例子-loam">3.2. 例子-LOAM</h3>
<p>　　<a href="/LOAM/" title="LOAM">LOAM</a> 前端提取线和面特征，后端最小化线和面的匹配误差。其源码实现了整个最优化过程，ALOAM<a href="#2" id="2ref"><sup>[2]</sup></a> 将后端代码用 Ceres 实现，这里对其作理解与分析。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LidarEdgeFactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LidarEdgeFactor(Eigen::Vector3d curr_point_, Eigen::Vector3d last_point_a_,</span><br><span class="line">					Eigen::Vector3d last_point_b_, <span class="keyword">double</span> s_)</span><br><span class="line">		: curr_point(curr_point_), last_point_a(last_point_a_), last_point_b(last_point_b_), s(s_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *q, <span class="keyword">const</span> T *t, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; cp&#123;T(curr_point.x()), T(curr_point.y()), T(curr_point.z())&#125;;</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpa&#123;T(last_point_a.x()), T(last_point_a.y()), T(last_point_a.z())&#125;;</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpb&#123;T(last_point_b.x()), T(last_point_b.y()), T(last_point_b.z())&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[3], T(s) * q[0], T(s) * q[1], T(s) * q[2]&#125;;</span></span><br><span class="line">		Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[<span class="number">3</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], q[<span class="number">2</span>]&#125;;</span><br><span class="line">		Eigen::Quaternion&lt;T&gt; q_identity&#123;T(<span class="number">1</span>), T(<span class="number">0</span>), T(<span class="number">0</span>), T(<span class="number">0</span>)&#125;;</span><br><span class="line">		q_last_curr = q_identity.slerp(T(s), q_last_curr);</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; t_last_curr&#123;T(s) * t[<span class="number">0</span>], T(s) * t[<span class="number">1</span>], T(s) * t[<span class="number">2</span>]&#125;;</span><br><span class="line"></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lp;</span><br><span class="line">		lp = q_last_curr * cp + t_last_curr;</span><br><span class="line"></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; nu = (lp - lpa).cross(lp - lpb);</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; de = lpa - lpb;</span><br><span class="line"></span><br><span class="line">		residual[<span class="number">0</span>] = nu.x() / de.norm();</span><br><span class="line">		residual[<span class="number">1</span>] = nu.y() / de.norm();</span><br><span class="line">		residual[<span class="number">2</span>] = nu.z() / de.norm();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> ceres::<span class="function">CostFunction *<span class="title">Create</span><span class="params">(<span class="keyword">const</span> Eigen::Vector3d curr_point_, <span class="keyword">const</span> Eigen::Vector3d last_point_a_,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">const</span> Eigen::Vector3d last_point_b_, <span class="keyword">const</span> <span class="keyword">double</span> s_)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;</span><br><span class="line">				LidarEdgeFactor, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>&gt;(</span><br><span class="line">			<span class="keyword">new</span> LidarEdgeFactor(curr_point_, last_point_a_, last_point_b_, s_)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Eigen::Vector3d curr_point, last_point_a, last_point_b;</span><br><span class="line">	<span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　对于 Point2Line 误差，为了衡量该线特征上的点是否在地图对应的线特征上，在地图线特征上采样两个点，加上该点，组成两个向量，向量叉乘即可描述匹配误差。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LidarPlaneFactor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LidarPlaneFactor(Eigen::Vector3d curr_point_, Eigen::Vector3d last_point_j_,</span><br><span class="line">					 Eigen::Vector3d last_point_l_, Eigen::Vector3d last_point_m_, <span class="keyword">double</span> s_)</span><br><span class="line">		: curr_point(curr_point_), last_point_j(last_point_j_), last_point_l(last_point_l_),</span><br><span class="line">		  last_point_m(last_point_m_), s(s_)</span><br><span class="line">	&#123;</span><br><span class="line">		ljm_norm = (last_point_j - last_point_l).cross(last_point_j - last_point_m);</span><br><span class="line">		ljm_norm.normalize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *q, <span class="keyword">const</span> T *t, T *residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; cp&#123;T(curr_point.x()), T(curr_point.y()), T(curr_point.z())&#125;;</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lpj&#123;T(last_point_j.x()), T(last_point_j.y()), T(last_point_j.z())&#125;;</span><br><span class="line">		<span class="comment">//Eigen::Matrix&lt;T, 3, 1&gt; lpl&#123;T(last_point_l.x()), T(last_point_l.y()), T(last_point_l.z())&#125;;</span></span><br><span class="line">		<span class="comment">//Eigen::Matrix&lt;T, 3, 1&gt; lpm&#123;T(last_point_m.x()), T(last_point_m.y()), T(last_point_m.z())&#125;;</span></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; ljm&#123;T(ljm_norm.x()), T(ljm_norm.y()), T(ljm_norm.z())&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[3], T(s) * q[0], T(s) * q[1], T(s) * q[2]&#125;;</span></span><br><span class="line">		Eigen::Quaternion&lt;T&gt; q_last_curr&#123;q[<span class="number">3</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], q[<span class="number">2</span>]&#125;;</span><br><span class="line">		Eigen::Quaternion&lt;T&gt; q_identity&#123;T(<span class="number">1</span>), T(<span class="number">0</span>), T(<span class="number">0</span>), T(<span class="number">0</span>)&#125;;</span><br><span class="line">		q_last_curr = q_identity.slerp(T(s), q_last_curr);</span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; t_last_curr&#123;T(s) * t[<span class="number">0</span>], T(s) * t[<span class="number">1</span>], T(s) * t[<span class="number">2</span>]&#125;;</span><br><span class="line"></span><br><span class="line">		Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; lp;</span><br><span class="line">		lp = q_last_curr * cp + t_last_curr;</span><br><span class="line"></span><br><span class="line">		residual[<span class="number">0</span>] = (lp - lpj).dot(ljm);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> ceres::<span class="function">CostFunction *<span class="title">Create</span><span class="params">(<span class="keyword">const</span> Eigen::Vector3d curr_point_, <span class="keyword">const</span> Eigen::Vector3d last_point_j_,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">const</span> Eigen::Vector3d last_point_l_, <span class="keyword">const</span> Eigen::Vector3d last_point_m_,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">const</span> <span class="keyword">double</span> s_)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;</span><br><span class="line">				LidarPlaneFactor, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&gt;(</span><br><span class="line">			<span class="keyword">new</span> LidarPlaneFactor(curr_point_, last_point_j_, last_point_l_, last_point_m_, s_)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Eigen::Vector3d curr_point, last_point_j, last_point_l, last_point_m;</span><br><span class="line">	Eigen::Vector3d ljm_norm;</span><br><span class="line">	<span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　对于 Point2Plane 误差，为了衡量该面特征上的点是否在地图对应的面特征上，在地图面特征上采样一个点，加上该点，组成向量，然后点乘面的法向量即可衡量匹配误差。</p>
<h3 id="例子-ba">3.3. 例子-BA</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy from https://www.jianshu.com/p/3df0c2e02b4c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/ceres.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ceres/rotation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read a Bundle Adjustment in the Large dataset.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BALProblem</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~BALProblem() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] point_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] camera_index_;</span><br><span class="line">    <span class="keyword">delete</span>[] observations_;</span><br><span class="line">    <span class="keyword">delete</span>[] parameters_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">num_observations</span><span class="params">()</span>       <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_observations_;               &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">double</span>* <span class="title">observations</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> observations_;                   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_cameras</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> parameters_;                     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_points</span><span class="params">()</span>           </span>&#123; <span class="keyword">return</span> parameters_  + <span class="number">9</span> * num_cameras_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_camera_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_cameras() + camera_index_[i] * <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span>* <span class="title">mutable_point_for_observation</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mutable_points() + point_index_[i] * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    FILE* fptr = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_cameras_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_points_);</span><br><span class="line">    FscanfOrDie(fptr, <span class="string">"%d"</span>, &amp;num_observations_);</span><br><span class="line"></span><br><span class="line">    point_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    camera_index_ = <span class="keyword">new</span> <span class="keyword">int</span>[num_observations_];</span><br><span class="line">    observations_ = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">2</span> * num_observations_];</span><br><span class="line"></span><br><span class="line">    num_parameters_ = <span class="number">9</span> * num_cameras_ + <span class="number">3</span> * num_points_;</span><br><span class="line">    parameters_ = <span class="keyword">new</span> <span class="keyword">double</span>[num_parameters_];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_observations_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, camera_index_ + i);</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%d"</span>, point_index_ + i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        FscanfOrDie(fptr, <span class="string">"%lf"</span>, observations_ + <span class="number">2</span>*i + j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_parameters_; ++i) &#123;</span><br><span class="line">      FscanfOrDie(fptr, <span class="string">"%lf"</span>, parameters_ + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FscanfOrDie</span><span class="params">(FILE *fptr, <span class="keyword">const</span> <span class="keyword">char</span> *format, T *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_scanned = <span class="built_in">fscanf</span>(fptr, format, value);</span><br><span class="line">    <span class="keyword">if</span> (num_scanned != <span class="number">1</span>) &#123;</span><br><span class="line">      LOG(FATAL) &lt;&lt; <span class="string">"Invalid UW data file."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num_cameras_;</span><br><span class="line">  <span class="keyword">int</span> num_points_;</span><br><span class="line">  <span class="keyword">int</span> num_observations_;</span><br><span class="line">  <span class="keyword">int</span> num_parameters_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* point_index_;</span><br><span class="line">  <span class="keyword">int</span>* camera_index_;</span><br><span class="line">  <span class="keyword">double</span>* observations_;</span><br><span class="line">  <span class="keyword">double</span>* parameters_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Templated pinhole camera model for used with Ceres.  The camera is</span></span><br><span class="line"><span class="comment">// parameterized using 9 parameters: 3 for rotation, 3 for translation, 1 for</span></span><br><span class="line"><span class="comment">// focal length and 2 for radial distortion. The principal point is not modeled</span></span><br><span class="line"><span class="comment">// (i.e. it is assumed be located at the image center).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnavelyReprojectionError</span> &#123;</span></span><br><span class="line">  SnavelyReprojectionError(<span class="keyword">double</span> observed_x, <span class="keyword">double</span> observed_y)</span><br><span class="line">      : observed_x(observed_x), observed_y(observed_y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> T* <span class="keyword">const</span> point,</span></span></span><br><span class="line"><span class="function"><span class="params">                  T* residuals)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// camera[0,1,2] are the angle-axis rotation.</span></span><br><span class="line">    T p[<span class="number">3</span>];</span><br><span class="line">    ceres::AngleAxisRotatePoint(camera, point, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera[3,4,5] are the translation.</span></span><br><span class="line">    p[<span class="number">0</span>] += camera[<span class="number">3</span>];</span><br><span class="line">    p[<span class="number">1</span>] += camera[<span class="number">4</span>];</span><br><span class="line">    p[<span class="number">2</span>] += camera[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the center of distortion. The sign change comes from</span></span><br><span class="line">    <span class="comment">// the camera model that Noah Snavely's Bundler assumes, whereby</span></span><br><span class="line">    <span class="comment">// the camera coordinate system has a negative z axis.</span></span><br><span class="line">    T xp = - p[<span class="number">0</span>] / p[<span class="number">2</span>];</span><br><span class="line">    T yp = - p[<span class="number">1</span>] / p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply second and fourth order radial distortion.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; l1 = camera[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">const</span> T&amp; l2 = camera[<span class="number">8</span>];</span><br><span class="line">    T r2 = xp*xp + yp*yp;</span><br><span class="line">    T distortion = <span class="number">1.0</span> + r2  * (l1 + l2  * r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute final projected point position.</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; focal = camera[<span class="number">6</span>];</span><br><span class="line">    T predicted_x = focal * distortion * xp;</span><br><span class="line">    T predicted_y = focal * distortion * yp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The error is the difference between the predicted and observed position.</span></span><br><span class="line">    residuals[<span class="number">0</span>] = predicted_x - observed_x;</span><br><span class="line">    residuals[<span class="number">1</span>] = predicted_y - observed_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factory to hide the construction of the CostFunction object from</span></span><br><span class="line">  <span class="comment">// the client code.</span></span><br><span class="line">  <span class="keyword">static</span> ceres::<span class="function">CostFunction* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> observed_x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> <span class="keyword">double</span> observed_y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;SnavelyReprojectionError, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>&gt;(</span><br><span class="line">                <span class="keyword">new</span> SnavelyReprojectionError(observed_x, observed_y)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> observed_x;</span><br><span class="line">  <span class="keyword">double</span> observed_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  google::InitGoogleLogging(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"usage: simple_bundle_adjuster &lt;bal_problem&gt;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BALProblem bal_problem;</span><br><span class="line">  <span class="keyword">if</span> (!bal_problem.LoadFile(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: unable to open file "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span>* observations = bal_problem.observations();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create residuals for each observation in the bundle adjustment problem. The</span></span><br><span class="line">  <span class="comment">// parameters for cameras and points are added automatically.</span></span><br><span class="line">  ceres::Problem problem;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bal_problem.num_observations(); ++i) &#123;</span><br><span class="line">    <span class="comment">// Each Residual block takes a point and a camera as input and outputs a 2</span></span><br><span class="line">    <span class="comment">// dimensional residual. Internally, the cost function stores the observed</span></span><br><span class="line">    <span class="comment">// image location and compares the reprojection against the observation.</span></span><br><span class="line"></span><br><span class="line">    ceres::CostFunction* cost_function =</span><br><span class="line">        SnavelyReprojectionError::Create(observations[<span class="number">2</span> * i + <span class="number">0</span>],</span><br><span class="line">                                         observations[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    problem.AddResidualBlock(cost_function,</span><br><span class="line">                             <span class="literal">NULL</span> <span class="comment">/* squared loss */</span>,</span><br><span class="line">                             bal_problem.mutable_camera_for_observation(i),</span><br><span class="line">                             bal_problem.mutable_point_for_observation(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make Ceres automatically detect the bundle structure. Note that the</span></span><br><span class="line">  <span class="comment">// standard solver, SPARSE_NORMAL_CHOLESKY, also works fine but it is slower</span></span><br><span class="line">  <span class="comment">// for standard bundle adjustment problems.</span></span><br><span class="line">  ceres::Solver::Options options;</span><br><span class="line">  options.linear_solver_type = ceres::DENSE_SCHUR;</span><br><span class="line">  options.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  ceres::Solver::Summary summary;</span><br><span class="line">  ceres::Solve(options, &amp;problem, &amp;summary);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summary.FullReport() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里使用了 Bundle Adjustment in the Large<a href="#3" id="3ref"><sup>[3]</sup></a> 数据集，观测量为图像坐标系下路标(特征)的像素坐标系，待优化的参数为各路标的 3D 坐标以及相机内外参，这里相机内外参有 9 个，其中位置及姿态 6 个，畸变系数 2 个，焦距 1 个。</p>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> 高翔. 视觉 SLAM 十四讲: 从理论到实践. 电子工业出版社, 2017.<br>
<a id="2" href="#2ref">[2]</a> https://github.com/HKUST-Aerial-Robotics/A-LOAM<br>
<a id="3" href="#3ref">[3]</a> http://grail.cs.washington.edu/projects/bal/</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>Model Compression - &#39;Quantization&#39;</title>
    <url>/Quantization/</url>
    <content><![CDATA[<p>　　量化(Quantization)是模型压缩主要技术之一。因为模型训练后的权重及特征图基本符合高斯分布(特征图可能是混合高斯分布)，所以将 32-bit 的张量量化到低比特后也能保持模型输出的准确度。如果只量化模型的权重，那么只是减少了模型的存储及传输大小；只有同时量化权重及特征图(Weight &amp; Activation)，才能同时减少计算量。本文来详细描述下模型量化的细节。</p>
<h2 id="quantization-scheme">1. Quantization Scheme</h2>
<h3 id="fixed-point-approximation">1.1. Fixed Point Approximation</h3>
<p>　　设 Fixed Point 近似法中表示整数与小数的比特数分别为 \(\mathrm{IL,FL}\)，那么其可表达的浮点数范围为<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a>：\([-2^{\mathrm{IL-1}}, 2 ^ {\mathrm{IL-1}}-2 ^ {-\mathrm{FL}}]\)。这种方法很明显，精度较差且表达的浮点数范围有限。更进一步，可以针对不同的张量，用不同的 \(\mathrm{IL,FL}\)，即 Dynamic Fixed Point 近似法<a href="#1" id="1ref"><sup>[1]</sup></a>。综上，Fixed Point 近似法将一个浮点数表示为： <span class="math display">\[(-1)^s\cdot 2^{-\mathrm{FL}}\sum _ {i=0}^{\mathrm{IL+FL-2}}2^i\cdot x _ i \tag{1}\]</span> 其中 \(x_i\) 为第 \(i\) 比特位的值。<br>
　　对于 Dynamic Fixed Point，首先保证整数部分不溢出，所以量化张量 \(X\) 时设计： <span class="math display">\[\mathrm{IL}=\lceil\mathrm{lg} _ 2(\mathop{\max}\limits _ {S} X + 1)\rceil \tag{2}\]</span> 剩下的比特位即为符号位与小数位。<br>
　　用这种定点方式量化后，由式(1)可知，两数相乘可以转换为 bits shifts &amp; add 操作，极大提升计算效率。<br>
　　Fixed Point 近似法精度有限，尤其是当所要表示的值较大时，小数位 \(\mathrm{FL}\) 只能分到很小，所以精度必然有较大损失。</p>
<h3 id="range-based-linear-approximation">1.2. Range-Based Linear Approximation</h3>
<p>　　不同于 Fixed Point 近似中小数位有一定限制(导致精度较差)，Range-Based Linear 近似法直接将浮点数通过一个高精度的 Scale 值映射到对应量化位数中，所以能保持非常高的精度。</p>
<h4 id="asymmetric-mode">1.2.1. Asymmetric Mode</h4>
<p><img src="/Quantization/asymmetric.png" width="40%" height="40%" title="图 1. Asymmetric Quantization"> 　　如图 1. 所示，设浮点数为 \(r\)，那么 Asymmetric Linear Approximation 过程为<a href="#3" id="3ref"><sup>[3]</sup></a>： <span class="math display">\[q = round\left((r-r _ {min})\cdot\frac{2^n-1}{r _ {max}-r _ {min}}\right) = round(\frac{r}{S}-\frac{r _ {min}}{S}) \tag{3}\]</span> 等价于<a href="#4" id="4ref"><sup>[4]</sup></a>： <span class="math display">\[r = S(q-Z) \tag{4}\]</span> 其中 \(S\) 为映射的 Scale 参数，\(Z\) 表示零值被量化的值。 <img src="/Quantization/conv.png" width="40%" height="40%" title="图 2. Convolution Operator"> 　　如图 2. 所示，卷积操作可转化为矩阵相乘运算，接下来我们来推导量化后的矩阵相乘运算。假设两个 \(N\times N\) 矩阵相乘：\(r _ 3=r _ 1\cdot r _ 2\)。令 \(r _ \alpha ^{(i,j)}\) 表示矩阵 \(r _ \alpha\) 第 \((i,j)\) 个元素，\(1\leq i,j\leq N\)。矩阵张量对应的量化参数为 \(S _ \alpha,Z _ \alpha\)，对应的量化后的元素表示为 \(q _ \alpha ^{(i,j)}\)： <span class="math display">\[r _ \alpha ^{(i,j)} = S _ \alpha\left(q _ \alpha ^{(i,j)}-Z _ \alpha\right) \tag{5}\]</span> bias 量化参数设为 \(S _ b=S _ 1S _ 2,Z _ b=0\)，那么卷积运算(矩阵相乘)可表示为： <span class="math display">\[S _ 3\left(q _ 3 ^{(i,k)}-Z _ 3\right) = \sum _ {j=1} ^N S _ 1\left(q _ 1 ^{(i,j)}-Z _ 1\right)S _ 2\left(q _ 2 ^{(j,k)}-Z _ 2\right) + S _ b(q _ b^{(i)} - Z _ b)\tag{6}\]</span> 等价于： <span class="math display">\[\begin{align}
q _ 3 ^{(i,k)} &amp;= Z _ 3+M\left(\sum _ {j=1} ^N \left(q _ 1 ^{(i,j)}-Z _ 1\right)\left(q _ 2 ^{(j,k)}-Z _ 2\right)+ \frac{S _ b}{S _ 1S _ 2}q _ b^{(i)}\right) \\
&amp;= Z _ 3+M\left(NZ _ 1Z _ 2- Z _ 1\sum _ {j=1}^Nq _ 2^{(j,k)}-Z _ 2\sum _ {j=1}^Nq _ 1^{(i,j)}+\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ \frac{S _ b}{S _ 1S _ 2}q _ b^{(i)}\right)  \\
&amp;= Z _ 3+M\left(NZ _ 1Z _ 2- Z _ 1\sum _ {j=1}^Nq _ 2^{(j,k)}-Z _ 2\sum _ {j=1}^Nq _ 1^{(i,j)}+\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ q _ b^{(i)}\right)
\tag{7}
\end{align}\]</span> 其中 \(M=\frac{S _ 1S _ 2}{S _ 3}\) 可以离线计算，为上式唯一的浮点数。经验上可知 \(M\in(0,1)\)，进一步可将其表示为： <span class="math display">\[M\approx 2^{-n}M _ 0 \tag{8}\]</span> 假设 \(m\) 是能表示 \(M _ 0\) 的位数( int32 硬件下，\(m\) 可为 32)，那么有 \(2 ^ {n} M \leq 2 ^m -1\)，故： <span class="math display">\[\left\{\begin{array}{l}
n = \left\lfloor\mathrm{log} _ 2\frac{2 ^ m-1}{M}\right\rfloor \\
M _ 0 = \left\lfloor 2 ^ nM\right\rfloor
\end{array}\tag{9}\right.\]</span> 由此，乘以 \(M _ 0\) 可以用定点乘法实现，乘以 \(2 ^{-n}\) 可以用高效的位运算实现。式(7)中核心的计算为两个量化向量的乘加运算：\(\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}\)，其可通过传统的特定位数的 BLAS 库完成。<br>
　　具体的，令矩阵张量(卷积滤波器权重及特征图)量化为 8-bit，那么 8-bit 乘法需要用 32-bit 的累加器，即： <span class="math display">\[\mathrm{int32 += uint8 * uint8} \tag{10}\]</span> 所以式(7)中每一项累加时都是 32-bit 的，bias 也是量化为 32-bit 或是 rescale 到 32-bit，即 \(S _ b=S _ 1S _ 2,Z _ b=0\)。</p>
<h4 id="symmetric-mode">1.2.2. Symmetric Mode</h4>
<p><img src="/Quantization/symmetric.png" width="40%" height="40%" title="图 3. Symmetric Quantization"> 　　这种模式下最大最小值绝对值取相同值 \(R\) (该值可为任意值)，那么量化表示为： <span class="math display">\[r = Sq \tag{11}\]</span> Full Range 下 \(S = \frac{R}{(2^n-1)/2}\)(8-bit 则量化范围为 [-128,127]，Range 范围为 255)，Restricted Range 则 \(S = \frac{R}{2^{n-1}-1}\)(8-bit 量化范围为[-127,127]，Range 范围为 254)。Full Range 精度更高，PyTorch，ONNX 采用这种方式；TensorFlow，TensorRT，MKL-DNN 则采用 Restricted Range 量化方式。<br>
　　由此式(7)简化为： <span class="math display">\[q _ 3 ^{(i,k)} = M\left(\sum _ {j=1}^N q _ 1^{(i,j)}q _ 2^{(j,k)}+ q _ b^{(i)}\right) \tag{12}\]</span> 实现更加简单。</p>
<h2 id="quantization-alogorithm">2. Quantization Alogorithm</h2>
<h3 id="post-training-quantization">2.1. Post-Training Quantization</h3>
<p>　　训练好的模型，可以直接对其权重进行量化，而对于特征的量化，则需要一个 Calibration 数据集来统计特征数值的分布，然后对其进行量化。<br>
　　量化参数的搜索，可以根据量化后的模型好坏进行 Loss 构建：</p>
<ol type="1">
<li><strong>任务级别损失函数</strong>：直接根据特定任务的指标来搜索及评价量化参数；</li>
<li><strong>张量级别损失函数</strong>：设计量化后的张量与原始张量的分布相似度，或者说信息损失度，如 KL-divergence 等度量方法；</li>
</ol>
<h3 id="quantization-aware-training">2.2. Quantization-Aware Training</h3>
<p>　　将训练好的模型直接进行量化，可能会导致对应的任务准确度下降，尤其对表达能力有限的小模型而言，以下情况会导致量化后模型准确度下降：</p>
<ol type="1">
<li>权重张量中数值差异 100 倍以上，导致小数值的量化误差较大；</li>
<li>权重张量中有 outlier 值，导致其它值的量化误差较大；</li>
</ol>
<p>而直接在训练的时候进行量化，可以保证完成模型训练也就得到了对应的高准确率的量化模型。 <img src="/Quantization/quantization-aware.png" width="80%" height="80%" title="图 4. Quantization-Aware Training Framework"> 　　如图 4. 所示，<a href="#4" id="3ref">[4]</a> 提出了一种 Quantization-Aware Training 的框架，权重和特征图均维护 float32 及 int8 数值，前向传播采用 int8 伪量化运算，反向传播更新权重的 float32 值，并作量化。 <img src="/Quantization/quantized_alg.png" width="60%" height="60%" title="图 5. Quantization-Aware Training Pipline"> 　　如图 5. 所示，<a href="#4" id="3ref">[4]</a> 基于 TensorFlow 实现了一种 Quantization-Aware Training 的算法，其步骤为：</p>
<ol type="1">
<li>建立一个浮点模型的 graph；</li>
<li>在 graph 中加入伪量化操作；</li>
<li>用伪量化的方式训练得到精度与浮点模型差不多的量化模型；</li>
<li>建立并优化量化的 Inference 模型 graph；</li>
<li>在量化引擎上作模型的 Inference；</li>
</ol>
<h4 id="simulated-quantization">2.2.1. Simulated Quantization</h4>
<p>　　这里采用 Asymmetric Linear Approximation 量化策略。对于权重，卷积运算时，先做伪量化操作，并且如果有 batch-normalization，则将其合并入卷积核权重中；对于特征图(Activations)，前向传播时都先做伪量化操作。伪量化操作如下<a href="#4" id="4ref"><sup>[4]</sup></a><a href="#5" id="5ref"><sup>[5]</sup></a>： <span class="math display">\[\begin{align}
\mathrm{clamp}(r\;;a,b) &amp;:= \mathrm{min}(\mathrm{max}(r,a),b) \\
s(a,b,n) &amp;:= \frac{b-a}{2 ^n-1} \\
q(r\;;a,b,n) &amp;:= \left\lfloor\frac{\mathrm{clamp}(r\;;a,b)-a}{s(a,b,n)}\right\rceil s(a,b,n)+a\\
\tag{13}
\end{align}\]</span> 其中 \([a,b]\) 是 被量化的浮点范围(可以是 \([r _ {min}, r _ {max}]\))，\(q(r\;;a,b,n)\) 即为浮点数 \(r\) 的伪量化表示，也是浮点数。</p>
<h4 id="learning-quantization-ranges">2.2.2. Learning Quantization Ranges</h4>
<p>　　训练时，每次迭代，权重与特征图都要作伪量化处理，所以每次要确定量化参数。对于权重，因为其服从均值为零的高斯分布，所以 \([a,b]\) 直接设为其最大值与最小值即可；对于特征图，其数值与输入相关，所以策略为：刚开始训练的时候不对其作量化处理，之后用 EMA(Exponential Moving Averages) 对量化参数进行平滑，去除特征图输出突变的影响。</p>
<h4 id="batch-normalization-folding">2.2.3. Batch Normalization Folding</h4>
<p>　　作 Inference 或者说前向传播时，BN 可以合并入卷积核权重中，所以在量化前，先要将其合并，然后权重就仅限于卷积操作中。对于每个卷积 filter，其生成特征图以及 BN 过程如下： <span class="math display">\[\begin{align}
\hat{x} _ i &amp;\gets wx _ i+b\\
\mu _ B &amp;\gets \frac{1}{m}\sum _ {i=1}^m \hat{x} _ i\\
\sigma^2 _ B &amp;\gets \frac{1}{m}\sum _ {i=1}^m(\hat{x} _ i-\mu _ B)^2\\
y _ i &amp;\gets \gamma\frac{\hat{x} _ i-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\
\tag{14}
\end{align}\]</span> 由此可得： <span class="math display">\[\begin{align}
y _ i &amp;\gets \gamma\frac{\hat{x} _ i-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\
&amp;\gets \gamma\frac{wx _ i+b-\mu _ B}{\sqrt{\sigma^2 _ B+\epsilon}} + \beta\\
&amp;\gets \frac{\gamma wx _ i}{\sqrt{\sigma^2 _ B+\epsilon}} +\frac{\gamma(b-\mu _ B)}{\sqrt{\sigma^2 _ B+\epsilon}}+ \beta\\
\tag{15}
\end{align}\]</span> 由此可知作 Inference 时，BN 参数 \(\mu _ B,\sigma^2 _ B,\gamma, \beta\) 可合并到卷积 Filter 参数中： <span class="math display">\[\left\{\begin{array}{l}
\hat{w} = \frac{\gamma w}{\sqrt{\sigma^2 _ B+\epsilon}}\\
\hat{b} = \frac{\gamma(b-\mu _ B)}{\sqrt{\sigma^2 _ B+\epsilon}}+ \beta\\
\end{array}\tag{16}\right.\]</span></p>
<h3 id="trained-quantization-thresholds">2.3. Trained Quantization Thresholds</h3>
<p>　　Post-Training Quantization 以及 Quantization-Aware Training 都是直接对张量的分析来搜索或近似求解量化参数的，Trained Quantization Thresholds 则在训练的时候同时训练得到量化参数。</p>
<h4 id="pact">2.3.1. PACT</h4>
<p>　　PACT<a href="#13" id="13ref"><sup>[13]</sup></a> 定义了激活函数输出的最大值，该最大值就是 Symmetric 量化中的激活层量化参数 Scale。具体的，改进 Relu： <span class="math display">\[ y = \mathrm{PACT}(x) = 0.5(|x|-|x-\alpha|+\alpha)=
\left\{\begin{array}{l}
0, \;\;x\in(-\infty,0)\\
x, \;\;x\in[0,\alpha]\\
\alpha, \;\;x\in[\alpha, +\infty)
\end{array}\tag{17}\right.\]</span> 对应的量化参数偏导为： <span class="math display">\[\frac{\partial y _ q(x;\,\alpha)}{\partial \alpha}=
\left\{\begin{array}{l}
0, \;\;x\in(-\infty, \alpha)\\
1, \;\;x\in[\alpha,+\infty)
\end{array}\tag{18}\right.\]</span></p>
<h4 id="tqt">2.3.2. TQT</h4>
<p>　　TQT(Trained Quantization Thresholds)<a href="#14" id="14ref"><sup>[14]</sup></a>则提出了一种同时学习权重和激活函数的量化参数的方法。为了简化，其采用 Linear Symmetric Approximation，且 Scale 参数限定为 \(s=2 ^ {-f}\)，由式(8,9)可知，消除了定点乘法运算。前向传播与式(13)并无差异，对每个权重即激活层作 scale，round，saturate，de-quant 操作。反向传播则需要对量化值 \(q(x;s)\) 求导，量化值表示为： <span class="math display">\[q(x;s)=
\left\{\begin{array}{l}
\left\lfloor\frac{x}{s}\right\rceil \cdot s, \;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\
n\cdot s, \;\;\;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\
p\cdot s, \;\;\;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\
\end{array}\tag{19}\right.\]</span> 其中 \(n,p\) 分别为量化值域的最小最大值。定义 \(\frac{\partial \lfloor x\rceil}{\partial x} = 1\)，那么对 Scale 的偏导为： <span class="math display">\[\nabla _ sq(x;s)=
\left\{\begin{array}{l}
\left\lfloor\frac{x}{s}\right\rceil - \frac{x}{s}, &amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\
n, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\
p, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\
\end{array}\tag{20}\right.\]</span> 为了稳定性，令 \(\nabla _ {(\mathrm{log} _ 2 t)} s = s\, \mathrm{In}(2)\)，则： <span class="math display">\[\nabla _ {(\mathrm{log} _ 2t)}q(x;s)= s\,\mathrm{In}(2)\cdot
\left\{\begin{array}{l}
\left\lfloor\frac{x}{s}\right\rceil - \frac{x}{s}, &amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\
n, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &lt; n\\
p, &amp;\;\left\lfloor\frac{x}{s}\right\rceil &gt; p\\
\end{array}\tag{21}\right.\]</span> 对应的，对输入 \(x\) 的偏导数为： <span class="math display">\[\nabla _ xq(x;s)=
\left\{\begin{array}{l}
1,&amp;\; n\leq\left\lfloor\frac{x}{s}\right\rceil\leq p\\
0, &amp;\;otherwise\\
\end{array}\tag{22}\right.\]</span></p>
<p>　　由此可与网络权重一起训练得到量化参数。Graffitist<a href="#15" id="15ref"><sup>[15]</sup></a>基于 TensorFlow 实现了上述算法；NNCF<a href="#16" id="16ref"><sup>[16]</sup></a>基于 Pytorch 实现了类似算法。</p>
<h2 id="quantized-framework">3. Quantized Framework</h2>
<p>　　不管是 Post-Training Quantization 还是 Quantization-Aware Training，算法端都还是用伪量化操作实现的，部署时就必须用 INT8 引擎。据我所知目前 INT8 引擎有：</p>
<ol type="1">
<li>DSP/加速芯片平台<br>
目测没有开源的，大家自个玩自个的；</li>
<li>CPU 平台<br>
Google 的 TensorFlow Lite<a href="#6" id="6ref"><sup>[6]</sup></a>，Facebook 的 QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>，Tencent 的 NCNN<a href="#9" id="9ref"><sup>[9]</sup></a>。</li>
<li>GPU 平台<br>
NVIDIA 的 TensorRT<a href="#10" id="10ref"><sup>[10]</sup></a>，TVM<a href="#11" id="11ref"><sup>[11]</sup></a>。</li>
</ol>
<p>而伪量化框架则在深度学习框架(caffe，pytorch，tensorflow)中开源的较多，如基于 pytorch 的 distiller<a href="#3" id="3ref"><sup>[3]</sup></a>，NNCF<a href="#16" id="16ref"><sup>[16]</sup></a>。<br>
　　对于 ARM 平台，INT8 引擎会通过 NEON 指令集加速；对于 x86 平台，INT8 引擎会通过 SSE 加速；对于 NVIDIA GPU 平台，则通过 dp4a<a href="#12" id="12ref"><sup>[12]</sup></a> 矩阵运算库加速。dp4a 实现了基础的 INT8 矩阵相乘操作，目前 cuDNN，cuBLAS，TensorRT 均采用该指令集。下面对 INT8 引擎作简要阐述。</p>
<h3 id="ristretto1">3.1. Ristretto<a href="#1" id="1ref"><sup>[1]</sup></a></h3>
<p>　　Ristretto 是一种基于 (Dynamix) Fixed Point Approximation, Post-Training Quantization 的量化框架，其精度有限，量化的 Inference 引擎可用 bits shifts &amp; add 操作实现，比较适合应用于 DSP 等嵌入式平台。</p>
<h3 id="tensorflow-lite6qnnpack8ncnn9">3.2. TensorFlow Lite<a href="#6" id="6ref"><sup>[6]</sup></a>/QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>/NCNN<a href="#9" id="9ref"><sup>[9]</sup></a></h3>
<p>　　TensorFlow Lite 是 Google 基于 TensorFlow 开发的针对移动嵌入式 CPU 平台的模型(量化)加速框架，其实现在 2.2 小节中已有详细的描述，有较高精度，<a href="#4" id="4ref">[4]</a> 实现了 Quantization-Aware Training。其中 INT8 矩阵运算采用了 gemmlowp<a href="#7" id="7ref"><sup>[7]</sup></a>。<br>
　　移动端的 CPU 的量化计算引擎开源的也比较多，如 Facebook 的 QNNPACK<a href="#8" id="8ref"><sup>[8]</sup></a>，腾讯的 ncnn-int8<a href="#9" id="9ref"><sup>[9]</sup></a>。</p>
<h3 id="tensorrt10">3.3. TensorRT<a href="#10" id="10ref"><sup>[10]</sup></a></h3>
<p>　　TensorRT 是 NVIDIA 基于 GPU 平台的模型(量化)加速框架，其基于 Symmetric Linear Approximation 量化策略，并且只支持 Post-Training Quantization，其内部可能直接调用 dp4a，也可能调用 cuDNN 或 cuBLAS。TVM<a href="#11" id="11ref"><sup>[11]</sup></a> 调用 dp4a 实现了基于 python 的 INT8 引擎，对于部署来讲没有 TensorRT 高效。<br>
　　对于特征图的量化参数 \(S\) 的搜索，其使用张量级别的损失函数，最小化量化前后特征图值分布差异性的方式，KL-divergency，即两个分布的相对熵。假设连个分布 \(P,Q\)，那么两者的相对熵为： <span class="math display">\[E(P,Q) = \sum _ i P(i)\cdot\mathrm{log}\left(\frac{P(i)}{Q(i)}\right) \tag{23}\]</span> 熵越大，表示两个分布差异性越大，即量化后信息损失越大。这里也可以采用其它能描述两个分布差异性的方式，如 EMD。整个量化参数搜索过程为：</p>
<ol type="1">
<li>准备训练好的 FP32 模型，以及一个作校正(Calibration)的数据集；</li>
<li>用 FP32 模型跑数据集，统计每个特征图的值分布；</li>
<li>对不同的量化参数，根据式(17)计算量化前后的相对熵；选择最优的量化参数；</li>
<li>根据最优的量化参数量化特征图得到量化模型(权重值分布比较集中，所以可以直接用最大值作为量化参数，具体还得看 TensorRT 怎么做的)；</li>
<li>保存量化参数为 Calibration Table，载入该值即可启动 INT8 引擎作量化 Inference；</li>
</ol>
<h2 id="reference">4. Reference</h2>
<p><a id="1" href="#1ref">[1]</a> Gysel, Philipp. &quot;Ristretto: Hardware-oriented approximation of convolutional neural networks.&quot; arXiv preprint arXiv:1605.06402 (2016).<br>
<a id="2" href="#2ref">[2]</a> Gupta, Suyog, et al. &quot;Deep learning with limited numerical precision.&quot; International Conference on Machine Learning. 2015.<br>
<a id="3" href="#3ref">[3]</a> https://nervanasystems.github.io/distiller/index.html<br>
<a id="4" href="#4ref">[4]</a> Jacob, Benoit, et al. &quot;Quantization and training of neural networks for efficient integer-arithmetic-only inference.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="5" href="#5ref">[5]</a> Krishnamoorthi, Raghuraman. &quot;Quantizing deep convolutional networks for efficient inference: A whitepaper.&quot; arXiv preprint arXiv:1806.08342 (2018).<br>
<a id="6" href="#6ref">[6]</a> https://www.tensorflow.org/mobile/tflite<br>
<a id="7" href="#7ref">[7]</a> https://github.com/google/gemmlowp<br>
<a id="8" href="#8ref">[8]</a> https://github.com/pytorch/QNNPACK<br>
<a id="9" href="#9ref">[9]</a> https://github.com/Tencent/ncnn/pull/487<br>
<a id="10" href="#10ref">[10]</a> Migacz, Szymon. &quot;8-bit inference with tensorrt.&quot; GPU technology conference. Vol. 2. No. 4. 2017.<br>
<a id="11" href="#11ref">[11]</a> https://tvm.apache.org/2019/04/29/opt-cuda-quantized<br>
<a id="12" href="#12ref">[12]</a> https://devblogs.nvidia.com/mixed-precision-programming-cuda-8/<br>
<a id="13" href="#13ref">[13]</a> Choi, Jungwook, et al. &quot;Pact: Parameterized clipping activation for quantized neural networks.&quot; arXiv preprint arXiv:1805.06085 (2018).<br>
<a id="14" href="#14ref">[14]</a> Jain, Sambhav R., et al. &quot;Trained quantization thresholds for accurate and efficient neural network inference on fixed-point hardware.&quot; arXiv preprint arXiv:1903.08066 (2019).<br>
<a id="15" href="#15ref">[15]</a> https://github.com/Xilinx/graffitist<br>
<a id="16" href="#16ref">[16]</a> Kozlov, Alexander, et al. &quot;Neural Network Compression Framework for fast model inference.&quot; arXiv preprint arXiv:2002.08679 (2020).</p>
]]></content>
      <categories>
        <category>Model Compression</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Model Compression</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Visual Odometry Part I&amp;II&quot;</title>
    <url>/%5Bpaper_reading%5D-Visual_Odometry_Part_I_II/</url>
    <content><![CDATA[<h2 id="overview-of-vo">1. Overview of VO</h2>
<p>　　SFM(Structure from Motion) 是解决从一堆图片中将场景以及相机姿态进行 3-D 重建的问题，最后的场景以及相机姿态可以通过离线优化方法（bundle adjustment）来 refine。VO &amp; VSLAM 都属于 SFM 的特殊情况，SfM 处理的图像时间上可以是无序的，而 VO &amp; VSLAM 则要求图像时间上有序。VO 只关心轨迹的局部一致性，而 VSLAM 关心全局轨迹和地图的一致性。VO 可以作为 VSLAM 的一个模块，用于重建相机的增量运动，Bundle Adjustment 可以用来 refine 相机的轨迹。如果用户只对相机路径感兴趣，不需要环境地图，且需要较高的实时性，那么一般 VO 就能满足需求。<br>
　　视觉里程计（VO）最早应用于 NASA 火星地面探测器，相比于车轮里程计的优势：</p>
<ul>
<li>不受车轮打滑的影响；</li>
<li>不受拐弯影响，拐弯时左右轮速度不一样；</li>
<li>更加准确，相对位置误差大概在 0.1% 到 2%，可作为车轮里程计、GPS，IMU等其它测量装置的补充；</li>
<li>在某些领域是必须的，比如无法使用车轮里程计的无人机，GPS 失效的水下环境等；</li>
</ul>
<p>　　根据视觉传感器数量，VO 可分为 Stereo VO，与 Monocular VO。当场景距离远远大于双目基线时，Stereo VO 也需要退化成 Monocular VO 来处理。</p>
<h3 id="stereo-vo-monocular-vo">1.1. Stereo VO &amp; Monocular VO</h3>
<p>　　特征点匹配可以通过特征跟踪（Feature Tracking）或特征检测（Feature Detect）再匹配两种方式实现。特征跟踪计算量小，但是容易漂移；特征检测再匹配计算量大，需要用 RANSAC 去除无匹配点，但是特征点不容易漂移。<br>
　　Motion Estimation 可通过 3D-3D，3D-2D，2D-2D 三种方式实现。Stereo 系统可以获得每个点的深度信息，所以这三种方式都可以用来做相机的运动估计。实验表明，直接在原始的 2-D 点上进行相机运动的估计，更加准确（？存疑）。<br>
　　之所以研究单目 VO，是因为当场景距离相机很远的时候（相对于双目的基线），双目就退化为单目了。单目 VO 中绝对深度（尺度）是未知的，刚开始两帧相机移动的距离通常设定为 1，之后的相对位姿都基于此。相关方法可分为：</p>
<ul>
<li>Feature-based Methods，用每一帧的特征点来估计运动。</li>
<li>Appearance-based Methods，用图像中所有的像素点或是子区域中的像素点来估计运动。</li>
<li>Hybrid Methods，结合以上两种形式。</li>
</ul>
<p>第一种方法较好，运动估计用 five-point RANSAC 来求解。</p>
<h3 id="reducing-the-drift">1.2. Reducing the Drift</h3>
<p>　　由于 VO 是一步步计算相机的运动轨迹然后作累加的，那么误差就有累积性，使得估计的运动轨迹会漂移。这可以用 Sliding Window(Windowed) Bundle Adjustment 局部优化方法来解决。也可以用 GPS 或 laser 或 IMU 融合来解决。Windowed Bundle Adjustment，是通过 m 个窗口下的信息来优化求解这 m 个相机位姿。</p>
<h3 id="vo-versus-v-slam">1.3. VO Versus V-SLAM</h3>
<p>　　V-SLAM 两大方法：</p>
<ul>
<li><strong>Filtering Methods</strong> 概率法，以一定的概率分布融合所有图像信息；</li>
<li><strong>Keyframe Methods</strong> 关键帧法，使用全局 Bundle Adjustment 优化被选择的关键帧；</li>
</ul>
<p>　　VO 只关心相机轨迹的一致性，而 SLAM 关注轨迹与地图整体的一致性。SLAM 中两大问题是，检测 loop closure 的发生以及用这个约束来更好的优化当下的地图和轨迹。而 VO 只对历史中以往 n 个轨迹中的位姿进行优化（windowed bundle adjustment），这可以认为与 SLAM 中建立局部地图与轨迹是等价的。但是这两者的 philosophy 不同：</p>
<ul>
<li>VO 只关心局部轨迹的一致性，局部地图只是用来（在 bundle ajustment）更精确的估计局部轨迹；</li>
<li>SLAM 关心整个地图的一致性，当然也包括轨迹，轨迹的精确性能使地图更加精确；</li>
</ul>
<p>　　VO 可以是 SLAM 的一个模块（相机运动轨迹的重建），SLAM 还需要一个闭环检测，以及一个全局的地图优化策略。V-SLAM 重建相机运动轨迹理论上比 VO 更精确（加入了更多的约束），但是不一定更鲁棒，因为闭环检测中的奇异值对地图的一致性有较大影响。此外 SLAM 更加复杂以及耗计算资源。VO 牺牲了全局一致性，来达到实时运行的目的，因为不需要记录所有的地图信息。</p>
<h2 id="formulation-of-the-vo-problem">2. Formulation of the VO Problem</h2>
<p>　　在时间 \(k\) 下，相机拍摄的图像集记为：\(I_{0:n}=\{I_0,...,I_k\}\)。相机在时间 \(k-1\) 与 \(k\) 的位姿转换矩阵为 \(T_{k,k-1}\in \mathbb{R}^{4\times 4}\)。VO 所要求解的问题就是 \(T=T_{1,0}T_{2,1}...T_{k,k-1}\)。由此可知 VO 是计算相邻帧的相机位姿，然后对之前 m 个位姿做一个局部优化从而估计更准确的轨迹。 <img src="/[paper_reading]-Visual_Odometry_Part_I_II/VO流程.png" width="50%" height="50%" title="图 1. VO流程图"> 　　大多数 VO 算法是基于特征点来估计运动的，特征点法的流程如图 1. 所示：</p>
<ol type="1">
<li><strong>Feature Detection(Extraction) and Matching/Feature Tracking</strong><br>
特征提取并与上一帧的特征进行匹配，或者直接用上一帧的特征在这一帧进行跟踪；</li>
<li><strong>Motion Estimation</strong><br>
在 \(k,k-1\) 帧之间求解 \(T_{k,k-1}\) 的过程，根据匹配的特征点对是 2D 还是 3D，运动估计可分为 3D-3D，3D-2D，2D-2D 三种方式实现；</li>
<li><strong>Local Optimization</strong><br>
在 \(k,k-m\) 帧用 Bundle Adjustment 迭代优化求解最优的局部轨迹；</li>
</ol>
<p>本文会重点阐述 <strong><em>Camera Model</em></strong><a href="#1" id="1ref"><sup>[1]</sup></a>，<strong><em>Feature Detection and Matching</em></strong><a href="#2" id="2ref"><sup>[2]</sup></a>，<strong><em>Motion Estimation</em></strong><a href="#1" id="1ref"><sup>[1]</sup></a>，<strong><em>Robust Estimation</em></strong><a href="#2" id="2ref"><sup>[2]</sup></a>，<strong><em>Local Optimization</em></strong><a href="#2" id="2ref"><sup>[2]</sup></a>。</p>
<h2 id="camera-modeling-and-calibration">3. Camera Modeling and Calibration</h2>
<p>　　<a href>相机模型及标定</a>，另文详述。</p>
<h2 id="feature-detection-and-matchingfeature-tracking">4. Feature Detection and Matching/Feature Tracking</h2>
<p>　　生成前后帧特征点的匹配对，有两种方法：</p>
<ul>
<li>feature tracking<br>
用局部搜索的方法，较适用于相邻两帧视角变化不大的情况，会有漂移（drift）的现象；</li>
<li>feature detection and matching<br>
独立在每个图像上进行检测，然后用某种度量准则进行匹配。在视野变化较大的情况下，只能用这种方法；</li>
</ul>
<h3 id="feature-tracking">4.1. Feature Tracking</h3>
<p>　　主要采用 KLT（详见 <a href="/KLT/" title="KLT 算法详解">KLT 算法详解</a>）方法进行特征点跟踪。</p>
<h3 id="feature-detection-and-matching">4.2. Feature Detection and Matching</h3>
<p>　　特征点包含特征检测子与特征描述子。一个好的特征点应该有如下性质：</p>
<ul>
<li>可重复性(Repeatability)，不同图像下相同特征点可再次检测出；</li>
<li>可区别性(Distinctiveness)，不同特征点表达形式不一样，可以更好匹配；</li>
<li>高效率(Efficiency)，计算高效；</li>
<li>本地性(Locality)，特征仅与一小片图像区域有关；</li>
<li>定位准确(Localization Accuracy)，不同尺度下定位都要准确；</li>
<li>鲁棒性(Robustness)，对噪声，模糊，压缩有较好的鲁棒；</li>
<li>不变性(Invariance)，对光照(photometric)，旋转，尺度，投影畸变(geometric)有不变性；</li>
</ul>
<h4 id="feature-detector">4.2.1. Feature Detector</h4>
<p>　　特征检测子（feature detector）的计算过程包含两步，首先将图像进行一个特征响应函数的变换，比如 Harris 中的 角点响应函数，SIFT 中的 DoG 变换；然后应用非极大值抑制，提取最小或最大值。<br>
　　特征检测子可分为两类：</p>
<ul>
<li>角点(corners)<br>
角点检测子被定义为至少两个边缘相交的地方；角点计算快，定位精度高，但是区分度低，大尺度下定位精度低；</li>
<li>斑点(blobs)<br>
斑点检测子被定义为一种与周围区域在亮度、颜色、纹理下不同的模式；区分度较高，但是速度较慢；</li>
</ul>
<p><img src="/[paper_reading]-Visual_Odometry_Part_I_II/detectors.png" width="80%" height="80%" title="图 2. 检测子比较"> 　　如图2. 所示，常用的角点检测子有 ORB 特征中的 FAST 关键点，Harris 角点等；常用的斑点检测子有 SIFT，SURF，CENSURE 等。</p>
<h4 id="feature-descriptor">4.2.2. Feature Descriptor</h4>
<p>　　有了特征检测子后，为了特征点匹配，还需要描述这个检测子，描述量称为特征描述子。描述子可分为以下几类：</p>
<ol type="1">
<li>Appearance，检测子周围的像素信息
<ul>
<li>SSD 匹配，sum of squared difference，计算检测子周围像素亮度与其的误差和；</li>
<li>NCC 匹配，normalized cross correlation，相比 SSD，有一定的光照不变性；</li>
<li>Census Transform，将检测子周围的 patch 像素与其进行对比，合成 0,1 向量；</li>
</ul></li>
<li>Histogram of Local Gradient Orientations
<ul>
<li>SIFT，光照，旋转，尺度，均具有不变性；不适用于角点，适用于斑点；</li>
</ul></li>
<li>Much Faster
<ul>
<li>BRIEF，二进制描述子，用于 ORB；对于旋转和尺度有较强的区分性，并且提取以及比较速度都很快；</li>
</ul></li>
</ol>
<p>　　目前常用的 ORB 特征，采用的是 Oriented FAST 角点，以及 BRIEF 描述子。</p>
<h4 id="feature-matching">4.2.3. Feature Matching</h4>
<p>　　通过比较特征点中的描述子部分，来完成特征点的匹配。如果是 appearance 描述子，那么一般通过 SSD/NNC 来计算描述子之间的相似度，其它二进制描述子，可通过欧氏距离或汉明距离来度量。<br>
　　基于相似性度量的特征匹配，最简单的就是暴力匹配，两组特征点挨个计算相似度。暴力匹配时间复杂度较高，通常我们采用<strong>快速近似最近邻算法（FLANN）</strong>，也可以加入运动估计模型（通过 IMU 等装置获得的大致运动位姿）来缩小搜索范围。特殊的如果是双目系统，因为左右目图像都是矫正过的，所以左右目的特征点匹配可通过行矩阵搜索解决。<br>
　　匹配结束后，我们还得进一步验证匹配的正确性，去除误匹配的情况。比如相互一致性验证，每个特征点只能匹配一个特征点。<br>
　　实验表明特征点的分布也很影响匹配效果，特征应尽量均匀分布，可以将图像栅格化，然后对不同的栅格用不同的特征检测阈值即可，保证栅格之间特征数量相等。</p>
<h2 id="motion-estimation">5. Motion Estimation</h2>
<h3 id="d-2d">5.1. 2D-2D</h3>
<p>　　这种情况下特征点 \(f_{k-1},f_k\) 分别是在 2D 图像 \(I_{k-1},I_k\) 坐标系上。<br>
　　<a href>对极约束推倒过程可详见这里</a>。根据对极约束，可推导出同一 3D 点投影到两个相机视角图像下后，其坐标之间的关系： <span class="math display">\[p_2^TK^{-T}t^{\wedge} RK^{-1}p_1=0\]</span> 记<strong>本质矩阵(Essential Matrix)</strong>\(E=t^{\land} R\)，记<strong>基础矩阵(Fundamental Matrix)</strong>\(F=K^ {-T}EK^ {-1}\)。基础矩阵描述的是两幅图像对应点的像素坐标的关系；本质矩阵描述的是世界中的某点分别在两个相机坐标系下坐标的相对关系。<br>
　　一般相机内参是已知的，所以我们求解本质矩阵。可采用五点法或者八点法来求解，五点法只能处理已知相机标定参数的情况，所以我们一般采用八点法来求解本质矩阵 \(E\)，大于八点即可用最小二乘求解线性方程。然后对本质矩阵进行奇异值分解，即可求出相机的位姿 \(R,t\)。<br>
　　当选取的点共面时，基础矩阵的自由度下降，即出现退化的现象，这个时候需要同时求解单应矩阵\(H\)，选择重投影误差较小的那个作为最终的运动估计矩阵。<br>
　　此外，还需计算当前运动的相对尺度，可由 3D 点的位置信息求解相对尺度。绝对尺度的求解需要三角化求解。<br>
　　总结过程如下：</p>
<ol type="1">
<li>得到新的当前帧 \(I_K\);</li>
<li>提取当前帧的特征点，并与上一帧的特征进行匹配；</li>
<li>根据匹配的特征点对，计算本质矩阵\(E\)；</li>
<li>奇异值分解本质矩阵，得到相机运动 \(R_K,t_k\)；</li>
<li>该相邻帧的相机运动信息与之前相机运动信息进行累计；</li>
<li>重复 1.；</li>
</ol>
<h3 id="d-2d-1">5.2. 3D-2D</h3>
<p>　　这种情况下，特征点 \(f_{k-1}\) 是 3D 坐标点，\(f_k\) 是其投影到 2D 图像 \(I_K\) 上的匹配点。对于单目的情况，\(f_{k-1}\) 需要从相邻的前面帧中（比如 \(I_{k-2},I_{k-1}\)）三角化出 3D 坐标，然后与当前帧进行匹配，至少需要三帧的视角。3D-2D 比 3D-3D 更加精确，因为 3D-3D 直接优化相机运动，没有优化投影的过程。<br>
　　该问题也称为 <strong>PnP(Perspective from n Points)</strong>。PnP 问题有很多种求解方法：</p>
<ul>
<li>P3P 只是用 3 个点对进行求解，容易受误匹配的影响；</li>
<li>直接线性变换 需要 6 对匹配点才能求解，如果大于 6 对，则可用 SVD 等方法求线性方程的最小二乘解；</li>
<li>EPnP</li>
<li>UPnP</li>
<li>非线性优化(Bundle Adjustment)</li>
</ul>
<p>记 \(p_{k-1}^ i\) 为 \(k-1\) 时刻下第 \(i\) 个特征点在相机坐标系下的坐标，定义重投影的误差项： <span class="math display">\[\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert uv^i_k-K \, T_{k,k-1} \, p_{k-1}^i \right\Vert^2\]</span></p>
<p>　　总结过程如下：</p>
<ol type="1">
<li>初始化，在 \(I_{k-2},I_{k-1}\) 两张图里提取特征并匹配，三角花得到特征点的 3D 坐标；</li>
<li>在 \(I_k\) 图像中提取特征点，并与上一帧的特征进行匹配；</li>
<li>用 PnP 求解相机运动；</li>
<li>在 \(I_{k-1},I_{k}\) 中三角化所有特征点；</li>
<li>重复 2.；</li>
</ol>
<h3 id="d-3d">5.3. 3D-3D</h3>
<p>　　这种情况下特征点都是 3D 坐标点，都需要三角花得到，可以使用一个立体视觉系统。<br>
　　已知两组匹配好的 3D 点，可以用 <strong>ICP(Iterative Closest Point)</strong> 来求解位姿。ICP 有两种求解方式：</p>
<ul>
<li>线性求解</li>
<li>非线性优化(类似 Bundle Adjustment)</li>
</ul>
<p>定义重投影的误差项： <span class="math display">\[\xi=\mathop{\arg\min}\limits_{T_{k,k-1}} \sum_i \left\Vert p_{k}^i - T_{k,k-1} \, p_{k-1}^i \right\Vert^2\]</span></p>
<p>　　ICP 问题存在唯一解或无穷多解的情况，所以非线性优化时，只要找到极小值，那一定是全局最优解，这也意味着 ICP 非线性优化时可以任意选定初始值。<br>
　　在匹配已知的情况下，ICP 问题是有解析解的。不过如果有些特征点观察不到深度，那么可以混合着使用 PnP 和 ICP 优化：对于深度已知的特征点，建模 3D-3D 误差，对于深度未知的特征点，建模 3D-2D 的重投影误差。两个误差项，用非线性优化求解。</p>
<h3 id="triangulation-and-keyframe-selection">5.4. Triangulation and Keyframe Selection</h3>
<p>　　对于 stereo camera， 3D-2D 比 3D-3D 更准确；3D-2D 比 2D-2D 计算更快，前者是 P3P 问题，后者则至少需要 5 个点。当场景中物体相比基线很大时，那么立体视觉系统就失效了，这时候用单目视觉系统比较靠谱。<br>
　　对于 monocular camera，2D-2D 比 3D-2D 看样子更好，因为避免了三角测量；然后实际中，3D-2D 用得更多，因为数据关联更快。<br>
　　当两帧之间相隔很短时间时，可以认为基线非常小，这种情况，获得的深度信息不确定性很高，所以需要选择某些 keyframes 来计算。</p>
<h2 id="robust-estimationoutlier-rejection">6. Robust Estimation/Outlier Rejection</h2>
<p>　　匹配的特征点可能因为噪音、遮挡、模糊、视角变化、光照变化等原因成为外点（outliers），这时候该匹配对对运动估计来说就是个外点，估计的时候应该想办法去除掉。<br>
　　<strong>RANSAC</strong> 目前已是在含有噪声的数据中进行模型估计的标准方法。其思想是随机选取一些数据进行建模，涵盖数据最多的模型即被选择是最终模型。对于相机运动估计来说，模型就是相机的运动 \(R,t\)，数据就是特征匹配对。RANSAC 流程为：</p>
<ol type="1">
<li>初始化，记 A 为特征点对集；</li>
<li>从 A 中随机选取一些点对 s；</li>
<li>用 s 估计运动模型；</li>
<li>计算所有的点对与这个模型的距离误差，可使用 point-to-epipolar 距离或是 directional 误差(Sampson distance)；</li>
<li>统计距离误差小于一定阈值的点对的数量，并存储标记这些内点(inliers)；</li>
<li>重复 2.，直到达到最大迭代次数；</li>
<li>选取数量最多的内点点对集，用这些点估计最终模型；</li>
</ol>
<p><img src="/[paper_reading]-Visual_Odometry_Part_I_II/ransac.png" width="60%" height="60%" tit le="图 3. RANSAC 迭代次数比较"></p>
<p>　　为保证得到正确解，迭代次数要求： <span class="math display">\[N=\frac{log(1-p)}{log(1-(1-\epsilon)^s)}\]</span> 其中，\(p\) 表示得到正确解的概率，\(\epsilon\) 表示外点的百分比，\(s\) 表示每次模型估计取出的点数。如图 3. 所示，选出的点数越少，迭代次数就可以越少。这个角度来讲，五点法比八点法有优势，但是五点法的前提是相机都是标定过的。不过不考虑速度的话，还是选择更多的点，因为可以平滑噪声。</p>
<h2 id="local-optimization">7. Local Optimization</h2>
<p>　　每次估计的相机运动都有误差，随着运动的累计，误差也会累计。这就要求做局部最优化，消除轨迹的漂移。优化方式有 Pose-Graph Optimization（需要回环检测） 以及 Windowed Bundle Adjustment 两种，这里主要介绍 BA。定义误差函数： <span class="math display">\[\xi=\mathop{\arg\min}\limits_{X^i,C_k} \sum_{i,k} \left\Vert uv_{k}^i - g(X^i,C_k) \right\Vert^2\]</span> 其中 \(X^i\) 为世界坐标系下特征点的 3D 坐标，\(C_k = T_{1,0}...T_{k,k-1}\)，\(g(X^i,C_k)\)为特征点投影到图像的映射函数。该非线性问题可用 Newton-Gauss 或 LM 法解决。为了加速运算，如果 3D 特征点是准确的(如立体视觉获得的)，那么可以固定特征点的 3D 量，只优化相机的轨迹。</p>
<p><a id="1" href="#1ref">[1]</a> Scaramuzza, Davide, and Friedrich Fraundorfer. &quot;Visual odometry [tutorial].&quot; IEEE robotics &amp; automation magazine 18.4 (2011): 80-92.<br>
<a id="2" href="#2ref">[2]</a> Fraundorfer, Friedrich, and Davide Scaramuzza. &quot;Visual odometry: Part ii: Matching, robustness, optimization, and applications.&quot; IEEE Robotics &amp; Automation Magazine 19.2 (2012): 78-90.</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>SLAM</tag>
        <tag>VO</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;FlowNet3D&quot;</title>
    <url>/paperreading-FlowNet3D/</url>
    <content><![CDATA[<p>　　本来以为这篇文章是 FlowNet<a href="#1" id="1ref"><sup>[1]</sup></a>，FlowNet2.0<a href="#2" id="2ref"><sup>[2]</sup></a> 的续作，其实不是，大概只是借鉴了其网络框架。从网络细节上来说，应该算是 PointNet<a href="#3" id="3ref"><sup>[3]</sup></a>，PointNet++<a href="#4" id="4ref"><sup>[4]</sup></a> 系列的续作，本文<a href="#5" id="5ref"><sup>[5]</sup></a>二作也是 PointNet 系列的作者。<br>
　　光流(Optical Flow)是指图像坐标系下像素点的运动(详细可见 <a href="/KLT/" title="KLT">KLT</a>)，而 Scene Flow 是三维坐标下，物理点的运动。Scene Flow 是较底层的一种信息，可进一步提取高层的语义信息，如运动分割等。</p>
<h2 id="背景">1. 背景</h2>
<h3 id="flownet-系列">1.1. FlowNet 系列</h3>
<p><img src="/paperreading-FlowNet3D/flownet.png" width="90%" height="90%" title="图 1. FlowNet"> <img src="/paperreading-FlowNet3D/refine.png" width="80%" height="80%" title="图 2. FlowNet Refinement"> 　　如图 1. 与 2. 所示，FlowNet 在特征提取编码阶段提出了两种网络结构：FlowNetSimple 以及 FlowNetCorr。FlowNetSimple 是将前后帧图像按通道维拼接作为输入，FlowNetCorr 则设计了互相关层，描述前后帧特征的相关性，从而得到像素级偏置。refinement 解码阶段则采用 FPN 形式进行上采样，这样每一层反卷积层在细化时，不仅可以获得深层的抽象信息，同时还能获得浅层的具体信息。 <img src="/paperreading-FlowNet3D/flownet2.png" width="90%" height="90%" title="图 3. FlowNet2.0"> 　　FlowNet 虽然验证了用深度学习预测光流的可行性，但是性能比不上传统方法。FlowNet2.0 在此基础上进行了三大改进：</p>
<ul>
<li><strong>增加训练数据，改进训练策略</strong>；<br>
在数据足够的情况下，证明了 FlowNetCorr 比 FlowNetSimple 较好。</li>
<li><strong>利用堆叠结构使性能得到多级提升</strong>；<br>
如图 3. 所示，采用 FlowNet2-CSS 形式堆叠一个 FlowNetCorr 以及两个 FlowNetSimple 模块，FlowNetSimple 的输入为前一模块预测的光流，原图像经过光流变换后的图像，以及与另一图像的误差，这样可以使得该模块专注去学习前序模块未预测准确的误差项。训练时，由前往后单独训练每个模块。</li>
<li><strong>针对小位移的情况引入特定的子网络进行处理</strong>；<br>
如图 3. 所示，FlowNet2-SD 网络卷积核均改为 3x3 形式，以增加对小位移的分辨率。最后再利用一个小网络将 FlowNet2-CSS 与 FlowNet2-SD 的结果进行融合。</li>
</ul>
<h3 id="pointnet-系列">1.2. PointNet 系列</h3>
<p>　　这部分详见 <a href="/PointNet-系列论文详读/" title="PointNet-系列论文详读">PointNet-系列论文详读</a>。<br>
　　这里介绍下 PointNet++ 中点云采样的过程。点云采样有集中形式：</p>
<ul>
<li>格点采样<br>
空间栅格化，然后按照栅格进行点云采样；</li>
<li>随机采样<br>
</li>
<li>几何采样<br>
根据点云所在平面的曲率，将点云分成不同集合，在每一集合里面进行均匀采样，获得曲率大的地方采样点多的效果，即获得更多“细节”；</li>
<li>均匀采样</li>
</ul>
<p>PointNet++ 中采用的 Farthest Point Sample 属于均匀采样，其可以采样出特定个数的点，且比较均匀。大致过程为：</p>
<ol type="1">
<li>点云总集合为 \(\mathcal{C}\)，随机取一点，形成采样目标集合 \(\mathcal{S}\)；</li>
<li>在剩余点集 \(\mathcal{C}-\mathcal{S}\) 中取与集合 \(\mathcal{S}\) 距离最远的一点，加入目标集合 \(\mathcal{S}\)；</li>
<li>如果目标集合 \(\mathcal{S}\) 个数达到预定值，则终止，否则重复步骤 2.；</li>
</ol>
<h2 id="flownet3d-网络结构">2. FlowNet3D 网络结构</h2>
<p><img src="/paperreading-FlowNet3D/flownet3d.png" width="90%" height="90%" title="图 4. FlowNet3D"> 　　如图 4. 所示，FlowNet3D 整体思路与 FlowNetCorr 非常像，其 set conv，flow embedding，set upconv 三个层相当于 FlowNetCorr 中的 conv，correlation，upconv 层。网络结构的连接方式也比较相像，上采样的过程都有接入前面浅层的具体特征。下面重点分析下这三个层的细节。 <img src="/paperreading-FlowNet3D/flownet3d-layers.png" width="90%" height="90%" title="图 5. FlowNet3D Layers"> 　　假设两个连续帧的两堆点：\(\mathcal{P} = \{x_i\vert i = 1,...,n_1\}\) 以及 \(\mathcal{Q} = \{y_j\vert j = 1,...,n_2\}\)，其中 \(x_i, y_j \in \mathbb{R}^3\) 是每个点的物理空间坐标。Scene Flow 的目标是求解 \(\mathcal{D}=\{x_i'-x_i \vert i = 1,...,n_1\} = \{d_i\vert i=1,...,n_1\}\)，其中 \(x_i'\) 是 \(x_i\) 在下一帧的位置。图 5. 较清晰地阐述了这三个层对点云的作用：</p>
<h3 id="set-conv-layer">2.1. set conv layer</h3>
<p>　　set conv layer 就是 PointNet++ 中的 set abstraction layer，其作用相当于图像中的卷积操作，能提取环境上下文特征。假设输入 \(n\) 个点，每个点 \(p_i = \{x_i, f_i\}\)，其中 \(x_i\in \mathbb{R}^3\) 是物理坐标空间，\(f_i\in\mathbb{R}^c\) 是特征空间；输出 \(n'\) 个点，对应每个点为 \(p_j'=\{x_j',f_j'\}\)，其中 \(f_j'\in\mathbb{R}^{c'}\) 为特征空间。那么 set conv layer 可以描述为： <span class="math display">\[f_j&#39; = \max_{\left\{i\vert\Vert x_i-x_j&#39;\Vert \leq r\right\}}\left\{\mathbf{h}\left(\mathrm{concat}(f_i,x_i-x_j&#39;)\right)\right\}\]</span> 其中 \(x_j'\) 是输入的 \(n\) 个点经过 Farthest Point Sample 后的点集，感知机 \(\mathbf{h}\) 将空间 \(\mathbb{R}^{c+3}\) 映射到空间 \(\mathbb{R}^{c'}\)，然后进行 max 操作。</p>
<h3 id="flow-embedding-layer">2.2. flow embedding layer</h3>
<p>　　有了 PointNet 思想后，其实比较容易想到如何进行两个点云的特征融合提取(看论文之前，自己有想过，和论文一样⊙o⊙)。对于两个点集：\(\left\{p_i = \{x_i, f_i\}\right\}_{i=1}^{n_1}\) 以及 \(\left\{q_j = \{y_j, g_j\}\right\}_{j=1}^{n_2}\)，其中 \(x_i,y_j\in\mathbb{R}^3\)，特征量 \(f_i,g_j\in\mathbb{R}^c\)， 那么输出为：\(\left\{o_i=\{x_i,e_i\}\right\}_{i=1}^{n_1}\)，其中 \(e_i\in\mathbb{R}^{c'}\)。由此 flow embedding layer 可描述为： <span class="math display">\[e_i = \max_{\left\{j\vert\Vert y_j-x_i\Vert \leq r\right\}}\left\{\mathbf{h}\left(\mathrm{concat}(f_i,g_j,y_j-x_i)\right)\right\}\]</span> 可见，其数学形式与 set conv layer 基本一致，但是物理意义是完全不一样的， flow embedding layer 是以 \(x_i\) 为锚点，在另一堆点云中找到距离 \(r\) 范围内的点，从何提取特征，用来描述该点与另一堆点云的相关性。这里的感知机作用可以有其它形式，作者试验后发现这种方式最简单有效。</p>
<h3 id="set-upconv-layer">2.3. set upconv layer</h3>
<p>　　PointNet++ 中 refinement 过程是 3D 插值上采样与 unit pointnet 过程，这里作者参考图像中 conv2D 与 upconv2D 的关系，提出了 set upconv layer。图像中 upconv2D 可以认为是特征扩大+填0+conv的结合(插值上采样则等价于扩大+插值的过程)，那么类似的，set upconv layer 就是点云扩大后，再对每个目标点进行 set conv layer 的操作。<br>
　　作者称这种方法比纯插值上采样好(这当然了)，也有可能是称比插值上采样+unit pointnet 好？但是这种方法本质上还是插值上采样+pointnet。</p>
<h2 id="其它细节">3. 其它细节</h2>
<h3 id="training-loss">3.1. Training Loss</h3>
<p>　　输入两堆点云： \(\mathcal{P}=\{x_i\}_{i=1}^{n_1}\), \(\mathcal{Q}=\{y_j\}_{j=1}^{n_2}\)，网络预测的 Scene Flow 为 \(\mathcal{D}=F(\mathcal{P,Q;\theta})=\{d_i\}_{i=1}^{n_1}\)， 真值为 \(\mathcal{D}^*=\{d_i^*\}_{i=1}^{n_1}\)。经过 Scene Flow 变换后的点云为：\(\mathcal{P'}=\{x_i+d_i\}_{i=1}^{n_1}\)，那么经过网络预测的反向的 Scene Flow 为 \(\{d_i'\}_{i=1}^{n_1}=F(\mathcal{P',P;\theta})\)，由此定义 cycle-consistency 项 \(\Vert d_i'+d_i\Vert\)，最终的 Loss 函数为： <span class="math display">\[L(\mathcal{P,Q,D^*,\theta})=\frac{1}{n_1}\sum_{i=1}^{n_1}\left(\Vert d_i-d_i^*\vert+\lambda\Vert d_i&#39;+d_i\Vert\right)\]</span></p>
<h3 id="three-meta-architectures">3.2. Three Meta-architectures</h3>
<p><img src="/paperreading-FlowNet3D/mixture.png" width="60%" height="60%" title="图 6. 三种特征融合方式对比"> 　　如图 6. 所示，两个点云集合特征融合方式有三种，作者的 baseline 模型也是基于这三种，flow embedding layer 属于 Deep Mixture 类型。</p>
<h3 id="runtime">3.3.  Runtime</h3>
<p><img src="/paperreading-FlowNet3D/runtime.png" width="70%" height="70%" title="图 7. NIVIDA 1080 GPU with TensorFlow"> 　　速度嘛，还是比较慢的，要应用得做优化。</p>
<h3 id="applications-scan-registration-motion-segmentation">3.4.  Applications: Scan Registration &amp; Motion Segmentation</h3>
<p>　　待补充。</p>
<h2 id="实验结果">4. 实验结果</h2>
<p><img src="/paperreading-FlowNet3D/ablation.png" width="60%" height="60%" title="图 8. ablation study"> 　　如图 8. 所示，可得结论：</p>
<ul>
<li>PointNet 中 max 操作比 avg 操作效果好；</li>
<li>上采样中 upconv 比 interpolation 效果好；</li>
<li>cycle-consistency loss 项有助于提升性能；</li>
</ul>
<h2 id="参考文献">5. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Dosovitskiy, Alexey, et al. &quot;Flownet: Learning optical flow with convolutional networks.&quot; Proceedings of the IEEE international conference on computer vision. 2015.<br>
<a id="2" href="#2ref">[2]</a> Ilg, Eddy, et al. &quot;Flownet 2.0: Evolution of optical flow estimation with deep networks.&quot; Proceedings of the IEEE conference on computer vision and pattern recognition. 2017.<br>
<a id="3" href="#3ref">[3]</a> Qi, Charles R., et al. &quot;Pointnet: Deep learning on point sets for 3d classification and segmentation.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017.<br>
<a id="4" href="#4ref">[4]</a> Qi, Charles Ruizhongtai, et al. &quot;Pointnet++: Deep hierarchical feature learning on point sets in a metric space.&quot; Advances in neural information processing systems. 2017.<br>
<a id="5" href="#5ref">[5]</a> Liu, Xingyu, Charles R. Qi, and Leonidas J. Guibas. &quot;Flownet3d: Learning scene flow in 3d point clouds.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.</p>
]]></content>
      <categories>
        <category>Scene Flow</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Point Cloud</tag>
        <tag>paper reading</tag>
        <tag>Scene Flow</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>[paper_reading]-&quot;Multi-Task Multi-Sensor Fusion for 3D Object Detection&quot;&quot;</title>
    <url>/paperreading-MT-MS-Fusion-for-3D-Object-Detection/</url>
    <content><![CDATA[<p>　　本文<a href="#1" id="1ref"><sup>[1]</sup></a>提出了一种 3D 检测的多任务多传感器融合方法。输入数据为图像以及点云，输出为地面估计，2D/3D检测，稠密深度图。为了让其它任务来帮助提升 3D 检测效果，作者设计了很多方法，工作还是比较细致且系统。<br>
<img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/算法框架.png" width="90%" height="90%" title="图 1. 算法框架"> 　　整个算法框架如图 1. 所示。点云数据还是在俯视图(BEV)下进行栅格化处理，高度切割是在地面估计归一化后的基础上来做，因为要 3D 定位的目标都是在地面上的；另一方面，图像与投影到前视图的点云数据进行合并，作为网络的输入数据。 网络结构上作者提出了两种俯视图与前视图特征融合策略：1. Point-wise feature fusion; 2. ROI-wise feature fusion. 这也是文章比较重要的一个贡献点。<br>
　　文章所提的 3D 检测方法大多数细节技巧并无新意，这里主要讨论分析文章中与传统方法不太一样的两大贡献点： 1. 俯视图与前视图特征融合策略； 2. 其它两个任务对检测任务提升的作用。</p>
<h2 id="俯视图与前视图特征融合策略">1. 俯视图与前视图特征融合策略</h2>
<p>　　由于网络输入有俯视图与前视图两个数据流，所以如何将这两个数据流进行特征级别的融合就显得尤为重要，文章提出了两种方式，backbone 网络级别的 point-wise feature fusion 以及第二阶段 ROI-wise feature fusion。</p>
<h3 id="point-wise-feature-fusion">1.1. Point-wise Feature Fusion</h3>
<p>　　3D 检测主体还是在俯视图下来做的，相比前视图对 3D 检测的处理，俯视图 3D 检测有天然的优势。因此，如何有效地将前视图的特征融合到俯视图的特征中，就显得尤为重要（俯视图特征融合到前视图相对比较简单）。<br>
<img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/point-wise.png" width="55%" height="55%" title="图 2. Point-wise Feature Fusion"> 　　如图 2. 所示，像素点级别的特征融合方式有两个模块，Multi-scale Fusion 以及 Continuous Fusion。Multi-scale Fusion 我们比较熟悉，可以采用类似 FPN 的结构实现。这里主要讨论 Continuous Fusion 模块。<br>
<img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/算法框架2.png" width="90%" height="90%" title="图 3. Deep Continuous Fusion 检测框架"> 　　Continuous Fusion 源自作者的另一篇文章<a href="#2" id="2ref"><sup>[2]</sup></a>。如图 3. 所示，该文检测框架基本就是本文的主干，其中 Fusion Layers 就是 Continuous Fusion 模块。而 continuous fusion 前身是作者团队提出的 Deep Parametric Continuous Convolution<a href="#3" id="3ref"><sup>[3]</sup></a>。</p>
<ul>
<li><p><strong>Deep Parametric Continuous Convolution</strong><br>
传统的卷积只能作用于网格结构(gird-structured)的数据上，为了能处理点云这种非网格结构的数据，<a href="#3" id="3ref">[3]</a>提出了带参数的卷积(Parametric Continuous Convolution)。对于第 \(i\) 个需要计算的特征位置，其特征值 \(\mathrm{h}_i \in \mathbb{R}^N\) 数学形式为： <span class="math display">\[ \mathrm{h}_i=\sum_j \mathbf{MLP}(x_i-x_j)\cdot \mathrm{f}_j \]</span> 其中 \(j\) 表示第 \(i\) 个点周围的点，\(\mathrm{f}_j \in \mathbb{R}^N\) 为输入特征，\(x_j\in \mathbb{R}^3\) 是点的坐标值。多层感知机 \(\mathbf{MLP}\) 则起到了参数核函数的作用，将 \(\mathbb{R}^{J\times 3}\) 映射为 \(\mathbb{R}^{J\times N}\) 空间，用作特征计算的权重值。</p></li>
<li><p><strong>Continuous Fusion Layer</strong><br>
Continuous Fusion 则没有显示得计算卷积权重的过程，这样使得特征提取能力更强，而且计算效率更高，不用存储权重值。其数学描述为： <span class="math display">\[ \mathrm{h}_i=\sum_j \mathbf{MLP}(\mathrm{concat}[\mathrm{f}_j,x_i-x_j]) \]</span> 多层感知机 \(\mathbf{MLP}\) 直接将 \(\mathbb{R}^{J\times (N+3)}\) 映射到 \(\mathbb{R}^{J\times M}\) 空间，最后再做一个 element-wise 的相加即得空间为 \(\mathbb{R}^{M}\) 的特征输出(<strong>这个和 PointNet 几乎一模一样，本质就是将每个点的特征空间升维，然后用对称函数(pooling, sum)消除无序点的影响, 只是这里输入的点的特征空间 \(N\) 可能已经很大了</strong>)。 <img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/continuous_fusion.png" width="70%" height="70%" title="图 4. Continuous Fusion"> 具体步骤如图 4. 所示：</p>
<ol type="1">
<li>将点云投影到图像坐标系，在图像特征图上用双线性插值求取每个点对应的图像特征向量；</li>
<li>俯视图下对于每个需要求取特征的像素点，采样邻近的 \(K\) 个物理点，然后应用 Continuous Fusion，得到该像素点的特征向量；</li>
</ol></li>
</ul>
<h3 id="roi-wise-feature-fusion">1.2. ROI-wise Feature Fusion</h3>
<p>　　在俯视图上获得 3D 检测框后(见图 1.)，将其分别投影到图像特征图以及点云特征图上，图像特征图上用 ROIAlign 提取出目标框内的图像特征；点云特征图上用类似方法提取出带方向的目标框内的点云特征，两种特征合并到一起，再用网络进行 2D/3D 目标框的优化回归。 <img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/roi-wise.png" width="60%" height="60%" title="图 5. ROI-wise Fusion"> 　　如图 5. 所示，点云特征图上的目标框是带有一定方向的，准确提取特征时会有一些问题。由于旋转框有周期性，所以将目标框分成两种情况来考虑，这样提取的特征就没有奇异性了，如图 5.2 所示。此外 3D 优化回归是在目标框旋转后的坐标系下进行的。</p>
<h2 id="多任务对检测任务的提升作用">2. 多任务对检测任务的提升作用</h2>
<p><img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/ablation.png" width="100%" height="100%" title="图 6. Ablation on Kitti"> <img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/ablation2.png" width="50%" height="50%" title="图 7. Ablation on TOR4D"></p>
<h3 id="地面估计">2.1. 地面估计</h3>
<p>　　俯视图下点云进行栅格化手工提取特征之前，作者作了一个地面归一化的操作。地面估计是在栅格分辨率下进行的，所以自然能对点云的每个栅格进行地面归一化。作者认为自动驾驶 3D 检测的目标都是在地面上的，所以地面的先验知识应该有助于 3D 定位，与 HDNET<a href="#4" id="4ref"><sup>[4]</sup></a> 思想类似。而在线地面估计(地面估计是建图的其中一个任务)不依赖离线地图，能提高系统鲁棒性。<br>
<img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/ground_est.png" width="70%" height="70%" title="图 8. 目标定位误差"> 　　如图 6.,8 所示，地面估计的加入，确实使得 3D 检测性能有所提升。</p>
<h3 id="深度估计">2.2. 深度估计</h3>
<p>　　由于前视图输入的是图像以及点云的投影图，所以可进一步通过网络预测稠密的前视深度图。作者对点云的投影图作了精心的设计，这里不做展开，有可能直接投影的 \((x,y,z)\) 3 通道的投影图也够用。<br>
　　获得了前视稠密深度图后，可将其反投影到点云俯视图下，这样稀疏的点云会变得更加稠密，更有利于图像到点云的 Point-wise Feature Fusion。这里作者只在邻近取不到点云的时候用这反投影的伪雷达点(pseudo LiDARP)。如图 7. 所示，在该数据集上效果提升还是比较明显，而 Kitti 上不太明显，因为两者的相机与雷达配置不太一样。在 TOR4D 数据集上，远距离的车上点云数量更小，所以该技术效果较好。</p>
<h2 id="其它细节">3. 其它细节</h2>
<p>　　Loss 设计为： <span class="math display">\[ Loss = L_{cls} + \lambda(L_{box}+L_{r2d}+L_{r3d}) + \gamma L_{depth} \]</span> 其中 \(\lambda\) 与 \(\gamma\) 为权重项，\(L_{box}\) 为俯视图下预测的 3D 框，\(L_{r2d},L_{r3d}\) 为优化回归的 2D/3D 框。每一项的 Loss 计算方式与传统无异。 <img src="/paperreading-MT-MS-Fusion-for-3D-Object-Detection/eval.png" width="90%" height="90%" title="图 9. 算法对比"> 　　本文方法与其它方法对比如图 9. 所示。</p>
<h2 id="参考文献">4. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> Liang, Ming, et al. &quot;Multi-Task Multi-Sensor Fusion for 3D Object Detection.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019.<br>
<a id="2" href="#2ref">[2]</a> Liang, Ming, et al. &quot;Deep continuous fusion for multi-sensor 3d object detection.&quot; Proceedings of the European Conference on Computer Vision (ECCV). 2018.<br>
<a id="3" href="#3ref">[3]</a> Wang, Shenlong, et al. &quot;Deep parametric continuous convolutional neural networks.&quot; Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<br>
<a id="4" href="#4ref">[4]</a> Yang, Bin, Ming Liang, and Raquel Urtasun. &quot;Hdnet: Exploiting hd maps for 3d object detection.&quot; Conference on Robot Learning. 2018.</p>
]]></content>
      <categories>
        <category>3D Detection</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>3D Detection</tag>
        <tag>paper reading</tag>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>Model Compression - &#39;Pruning&#39;</title>
    <url>/pruning/</url>
    <content><![CDATA[<p>　　模型压缩技术主要有：Pruning，Regularization，Quantization，KnowLedge Distillation，Comditional Computation等。本文主要讨论剪枝技术(Pruning)。复杂模型存在存储空间大，计算量大等问题，对其进行剪枝使网络中的权重及特征层稀疏化(Regularization 也是稀疏化的过程)，能获得以下效益：</p>
<ul>
<li><strong>模型更小</strong><br>
稀疏化的模型含有大量的零值，称为稀疏表达(Sparse Representation)，通过稀疏矩阵压缩技术进行编码压缩后得到压缩表达(Compressed Representation)。片内内存(On-chip Mem)与片外内存(Off-chip Mem)数据的传输可用压缩表达，使实际传输中的模型内存更小，而计算时，可通过反编码算法得到稀疏表达，从而进行正常的矩阵运算；也可以直接用压缩表达进行矩阵运算，这需要特殊的硬件支持，并且稀疏化的过程一般是结构化剪枝(Structured Pruning)或是正则。</li>
<li><strong>速度更快</strong><br>
目前大部分矩阵运算芯片，性能瓶颈都在片内片外内存的带宽，稀疏化后能有效压缩矩阵单元，降低模型传输内存；另一方面，通过结构化的剪枝，在特定硬件下，能直接减少零值运算量。</li>
<li><strong>能效更高</strong><br>
片外内存访问所花费的能量大概比片内内存多两个数量级，所以降低模型的传输内存，甚至将模型及中间计算量(如特征层)直接塞到片内内存，减少与片外内存的交互，能有效提高能效。</li>
</ul>
<p>　　剪枝的过程主要是：根据剪枝类型选用对应的稀疏性定义方式；剪枝前模型的敏感度分析；应用剪枝算法及策略。以下根据 Distiller<a href="#1" id="1ref"><sup>[1]</sup></a> 库分别对这三部分进行详细阐述。</p>
<h2 id="稀疏性定义">1. 稀疏性定义</h2>
<p>　　剪枝大致可分为 element-wise 剪枝以及 Structured 剪枝，element-wise 剪枝只需要定义每个张量的稀疏性，即 Element-wise Sparsity，而 Structured 剪枝需要定义不同结构的稀疏性，有 Filter-wise Sparsity，Channel-wise Sparsity，Kernel-wise Sparsity，Block-wise Sparsity，Column-wise Sparsity，Row-wise Sparsity。<br>
　　设输入特征层 IFM(Input Feature Map)\(\in\mathbb{R}^{N\times C_1\times H_1\times W_1}\)，卷积核 Filter\(\in\mathbb{R}^{C_2\times C_1\times K\times K}\)，则输出特征层 OFM(Output Feature Map)\(\in\mathbb{R}^{N\times C_2\times H_2\times W_2}\)。</p>
<h3 id="element-wise-sparsity">1.1. Element-wise Sparsity</h3>
<p>　　张量元素的稀疏性，设 \(X\in\mathbb{R}^{N\times C\times H\times W}\)： <span class="math display">\[\Vert X\Vert_{element-wise} = \frac{l_0(X)}{N\times C\times H\times W} = \frac{\sum_{n=1}^{N}\sum_{c=1}^{C}\sum_{h=1}^{H}\sum_{w=1}^{W}\left\vert X_{n,c,h,w} \right\vert ^0}{N\times C\times H\times W} \tag{1}\]</span> 其中 \(l_0\) 正则根据元素是否为 0，确定输出 0/1。</p>
<h3 id="filter-wise-sparsity">1.2. Filter-wise Sparsity</h3>
<p>　　对于有 \(C_2\) 个卷积核的 Filter\(\in\mathbb{R}^{C_2\times C_1\times K\times K}\)，其 Filter-wise 的稀疏性可表示为： <span class="math display">\[\Vert X\Vert_{filter-wise} = \frac{\sum_{c_2=1}^{C_2}\left\vert\sum_{c_1=1}^{C_1}\sum_{k_1=1}^{K}\sum_{k_2=1}^{K}\vert X_{c_2,c_1,k_1,k_2}\vert \right\vert ^0}{C_2} \tag{2}\]</span></p>
<h3 id="kernel-wise-sparsity">1.3. Kernel-wise Sparsity</h3>
<p>　　卷积核 Filter\(\in\mathbb{R}^{C_2\times C_1\times K\times K}\) 拥有 \(C_2\times C_1\) 个 \(K\times K\) 大小的 Kernel，其 Kernel-wise 的稀疏性可表示为： <span class="math display">\[\Vert X\Vert_{kernel-wise} = \frac{\sum_{c_2=1}^{C_2}\sum_{c_1=1}^{C_1}\left\vert\sum_{k_1=1}^{K}\sum_{k_2=1}^{K}\vert X_{c_2,c_1,k_1,k_2}\vert \right\vert ^0}{C_2\times C_1} \tag{3}\]</span></p>
<h3 id="channel-wise-sparsity">1.4. Channel-wise Sparsity</h3>
<p>　　对于张量单元 \(X\in\mathbb{R}^{N\times C\times H\times W}\)： <span class="math display">\[\Vert X\Vert_{channel-wise} = \frac{\sum_{c=1}^{C}\left\vert\sum_{n=1}^{N}\sum_{h=1}^{H}\sum_{w=1}^{W}\vert X_{n,c,h,w}\vert \right\vert ^0}{C} \tag{4}\]</span></p>
<h3 id="column-wise-sparsity">1.5. Column-wise Sparsity</h3>
<p>　　对于张量单元 \(X\in\mathbb{R}^{H\times W}\)： <span class="math display">\[\Vert X\Vert_{column-wise} = \frac{\sum_{h=1}^{H}\left\vert\sum_{w=1}^{W}\vert X_{h,w}\vert \right\vert ^0}{H} \tag{5}\]</span></p>
<h3 id="row-wise-sparsity">1.6. Row-wise Sparsity。</h3>
<p>　　对于张量单元 \(X\in\mathbb{R}^{H\times W}\)： <span class="math display">\[\Vert X\Vert_{row-wise} = \frac{\sum_{w=1}^{W}\left\vert\sum_{h=1}^{H}\vert X_{h,w}\vert \right\vert ^0}{W} \tag{6}\]</span></p>
<h3 id="block-wise-sparsity">1.7. Block-wise Sparsity</h3>
<p>　　对于张量单元 \(X\in\mathbb{R}^{N\times C\times H\times W}\)，设定 block\(\in\mathbb{R}^{repetitions\times depth\times 1\times1}\)，由此将 \(X\) 划分为 \(\frac{N\times C}{repetitions\times depth}\times (repetitions\times depth)\times (H\times W)=N'\times B\times K\)。block-sparsity 定义为： <span class="math display">\[\Vert X\Vert_{block-wise} = \frac{\sum_{n=1}^{N&#39;}\sum_{k=1}^K\left\vert\sum_{b=1}^{B}\vert X_{n,b,k}\vert \right\vert ^0}{N&#39;\times K} \tag{7}\]</span></p>
<h2 id="模型敏感度分析sensitivity-analysis">2. 模型敏感度分析(Sensitivity Analysis)</h2>
<p>　　在剪枝前，我们首先要确定减哪几层，每层减多少(即剪枝阈值或剪枝程度)。这就涉及到模型中每层网络对模型输出的敏感度分析(Sensitivity Analysis)。<a href="#2" id="2ref">[2]</a> 提出了一种有效的方法来确定每层的敏感度。在一个已训练模型下，分别对每一层进行不同程度的剪枝，得到对应的网络输出精度，绘制敏感度曲线。<br>
<img src="/pruning/sensitivity.png" width="70%" height="70%" title="图 1. 敏感度分析"> 　　如图 1. 所示，AlexNet 网络各层对 element-wise 剪枝的敏感度曲线显示，越深的网络层对输出越不敏感，尤其是全连接层，所以剪枝程度可以更高。而对于非常敏感的浅层网络，则需要降低剪枝程度，甚至不剪枝。</p>
<h2 id="剪枝算法">3. 剪枝算法</h2>
<h3 id="magnitude-pruner">3.1. Magnitude Pruner</h3>
<p>　　这是最基本的剪枝方法，对于要剪枝的对象，判断其绝对值是否大于阈值 \(\lambda\)，如果小于阈值，则将该对象置为零。该对象可以是 element-wise，也可以是其它结构化的对象，如 filter，Kernel 等。<br>
　　该方法需要直接设定阈值，而阈值的设定是比较困难的。</p>
<h3 id="sensitivity-pruner">3.2. Sensitivity Pruner</h3>
<p>　　卷积网络每层的权重值为高斯分布，由高斯分布的性质可知，在标准差 \(\sigma\) 内，有 68% 的元素，所以阈值可设定为 \(\lambda=s\times \sigma\)，其表示了 \(s\times 68\%\) 的元素被剪枝掉。</p>
<h3 id="level-pruner">3.3. Level Pruner</h3>
<p>　　Level Pruner 直接设定需要剪枝的比例，即直接设定剪枝后的稀疏性，这比前两种方法更加稳定。具体做法就是对每个对象进行排序，然后以此裁剪，直到裁剪到设定的比例。</p>
<h3 id="automated-gradual-pruneragp">3.4. Automated Gradual Pruner(AGP)</h3>
<p>　　<a href="#3" id="3ref">[3]</a>提出了一种训练剪枝的方法，在 Level Pruner 基础上，随着训练的过程，设计剪枝的稀疏性从初始的 \(s_i\) 增加到目标 \(s_f\)，其数学表示为： <span class="math display">\[ s_t = s_f+(s_i-s_f)\left(1-\frac{t-t_0}{n\Delta t}\right)^3 \; \mathrm{for} \, t\in \{t_0, t_0+\Delta t,...,t_0+n\Delta t\} \tag{8}\]</span> 实现的效果是，初始阶段，剪枝比较厉害，越到最后，剪枝的量越少，直到达到目标剪枝值。</p>
<h3 id="structure-pruners">3.5. Structure Pruners</h3>
<p>　　这里讨论结构化剪枝中 Filter 以及 Channel 的剪枝<a href="#4" id="4ref"><sup>[4]</sup></a>，对应的需要用到前面提到的 Filter-wise 以及 Channel-wise 的稀疏性。不同于 element-wise 剪枝，结构化剪枝由于网络的连接性会更复杂，这里考虑三种链接情况。</p>
<h4 id="连接结构1">3.5.1. 连接结构1</h4>
<p><img src="/pruning/filter1.png" width="70%" height="70%" title="图 2. 连接结构1"> 　　如图 2. 所示，设第\(i\)层特征 \(X_i\in\mathbb{R}^{C_i\times H_i\times W_i}\)，经过卷积核 \(\mathcal{F}\in\mathbb{R}^{C_{i+1}\,\times\, C_i\,\times\,K\,\times\,K}\)后得到第 \(i+1\)层特征层 \(X_{i+1}\in\mathbb{R}^{C_{i+1}\,\times\, H_{i+1}\,\times\, W_{i+1}}\)。图中绿色及黄色代表剪枝掉的 Filter，对应的输出少了这两个卷积计算得到的 channel 维度的两个特征图，再往后就是去除 BN 里面对应 channel 层的 scale 以及 shift 信息(Distiller 中自动删除)，最后再次应用的卷积核需要去除对应的 channel，即类似做 channel-wise 剪枝。由此可见，结构化剪枝会影响后面的网络结构，需要根据网络信息流作网络调整。<br>
　　第 \(i\) 卷积层运算量 MAC 为 \(C_{i+1}C_iK^2H_{i+1}W_{i+1}\)，如果剪枝掉 \(m\) 个卷积核，那么第 i 层卷积减少的运算量为 \(mC_iK^2H_{i+1}W_{i+1}\)，下一层 \(i+1\) 卷积层减少的运算量为 \(C_{i+2}mK^2H_{i+2}W_{i+2}\)。所以在第 \(i\) 层剪枝掉 \(m\) 个卷积核，会使第 \(i,i+1\) 层的运算量各减少 \(m/C_{i+1}\)。</p>
<h4 id="连接结构2">3.5.2. 连接结构2</h4>
<p><img src="/pruning/filter2.png" width="60%" height="60%" title="图 3. 连接结构2"> 　　如图 3. 所示，与被剪枝的特征图直连的卷积核均需要作 channel 维度的裁剪，这一步在 Distiller 中自动进行。</p>
<h4 id="连接结构3">3.5.3. 连接结构3</h4>
<p><img src="/pruning/filter3.png" width="60%" height="60%" title="图 4. 连接结构3"> 　　如图 4. 所示，如果两个卷积层的输出要做 element-wise 相加操作，那么就要求两个卷积层的输出大小要一样。这就要求对这两个卷积层的卷积核裁剪过程要一样，包括裁剪的卷积数量以及卷积位置。这需要在 Distiller 中显示的指定。</p>
<h2 id="参考文献">4. 参考文献</h2>
<p><a id="1" href="#1ref">[1]</a> https://nervanasystems.github.io/distiller/index.html<br>
<a id="2" href="#2ref">[2]</a> Han, Song, et al. &quot;Learning both weights and connections for efficient neural network.&quot; Advances in neural information processing systems. 2015.<br>
<a id="3" href="#3ref">[3]</a> Zhu, Michael, and Suyog Gupta. &quot;To prune, or not to prune: exploring the efficacy of pruning for model compression.&quot; arXiv preprint arXiv:1710.01878 (2017).<br>
<a id="4" href="#4ref">[4]</a> Li, Hao, et al. &quot;Pruning filters for efficient convnets.&quot; arXiv preprint arXiv:1608.08710 (2016).</p>
]]></content>
      <categories>
        <category>Model Compression</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Model Compression</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波器在三维目标状态估计中的应用</title>
    <url>/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9C%A8%E4%B8%89%E7%BB%B4%E7%9B%AE%E6%A0%87%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>　　目前主流的三维目标的状态估计方法（也可称为 MOT 问题）主要包括三部分：<strong>1. 检测</strong>，出单帧三维目标信息；<strong>2. 跟踪</strong>，前后帧数据关联出 ID 信息；<strong>3. 滤波</strong>，平滑估计状态信息。这里的“跟踪”只是狭义地指出 ID 的过程，“滤波”也就是综述 <a href="/MOT-综述-Multiple-Object-Tracking-A-Literature-Review/" title="Multiple-Object-Tracking-A-Literature-Review">Multiple-Object-Tracking-A-Literature-Review</a> 中提到的 Inference 过程。Inference 过程还可以是基于优化的方法，本文我们主要讨论在自动驾驶中估计动态障碍物状态的扩展卡尔曼滤波方法。</p>
<h2 id="扩展卡尔曼滤波">1. 扩展卡尔曼滤波</h2>
<p>　　文章<a href="/卡尔曼滤波详解/" title="卡尔曼滤波详解">卡尔曼滤波详解</a>中已经详细推导了卡尔曼滤波相关原理，这里摘抄如下。非线性系统： <span class="math display">\[\left\{\begin{array}{l}
运动方程:\quad x_k=f(x_{k-1},u_k)+w_k \\
测量方程:\quad z_k=h(x_k)+v_k
\end{array}\tag{1}\right.\]</span> 滤波的两个步骤：</p>
<ol type="1">
<li><strong>预测（Predict）</strong><br>
计算先验： <span class="math display">\[\begin{align}
\bar{x} _k&amp;=f(\hat{x} _{k-1},u _k) \tag{2}\\
\bar{P} _k&amp;=F\hat{P} _kF^T+Q _k \tag{3}
\end{align}\]</span></li>
<li><strong>更新（Update）</strong><br>
先计算卡尔曼增益： <span class="math display">\[K_k=\bar{P}_kH_k^T(H_k\bar{P}_kH_k^T+R_k)^{-1} \tag{4}\]</span> 再计算后验概率分布： <span class="math display">\[\begin{align}
\hat{x}_k &amp;=\bar{x}_k+K(z_k-h(\bar{x})) \tag{5}\\
\hat{P}_k &amp;=(I-KH_k)\bar{P}_k \tag{6}
\end{align}\]</span></li>
</ol>
<h2 id="非线性系统构建">2. 非线性系统构建</h2>
<p>　　要构建三维目标状态估计系统，我们得分析状态量 \(x_k\)，测量量 \(z_k\)，输入量 \(u_k\)，状态转移函数（运动学方程）\(f(\cdot)\)，观测函数 \(h(\cdot)\)，以及雅克比矩阵 \(F\)，\(H\) 各是什么。 <img src="/卡尔曼滤波器在三维目标状态估计中的应用/状态量.png" width="25%" height="25%" title="图 1. 目标状态"> 　　如图1所示，<strong>我们严格限定要构建的非线性系统场景：动态目标的状态估计</strong>。对于自动驾驶中的动态目标状态估计，我们关心的状态量有水平面上目标物理位置，朝向，速度，转向速度，加速度，记为： <span class="math display">\[x_k=\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}\\
a\end{bmatrix}\tag{7}\]</span> 目前主流的 3D 检测方法，能出位置，尺寸，朝向。所以测量量： <span class="math display">\[z_k=\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix}\tag{8}\]</span> 以上针对的是目标三维状态估计，如果是本车的状态估计，那么测量量可能可以加上本车的速度等（故限定场景）。文章 <a href="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/" title="[paper_reading]-" stereo vision-based semantic 3d object and ego-motion tracking for autonomous driving"">[paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving"</a> 的 3.2.1 章节中提到过一种车辆运动学模型，<strong>该模型定义了输入量：方向盘比率以及加速度（实际使用中均设为0，类似下述质点模型中的 CTRV 模型）；并增加了状态量：方向盘转角</strong>。虽然那篇文章处理的场景与本篇讨论的一致，但是那篇文章采用的是优化方法，方向盘转角可作为优化参数进行求解；而本篇讨论的滤波迭代方法，则很难确定方向盘转角。所以该模型虽然能更好的描述目标，但是可能并不是更有效的（实际中可做实验对比），这里引出几种质点模型。<br>
　　<a href="#1" id="1ref">[1]</a>中介绍了几种非线性车辆质点模型：CHCV(Constant Heading and Constant Velocity)，CTRV(Constant Turn Rate and Velocity)，CTRA(Constant Turn Rate and Acceleration)，此外应该还有 CHA(Constant Heading and Acceleration)。这些模型均没有考虑输入量，即： <span class="math display">\[u_k=\mathbb{0}\tag{9}\]</span> 这里我们依次介绍各模型（为了完整性，重写文章 <a href="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/" title="[paper_reading]-" stereo vision-based semantic 3d object and ego-motion tracking for autonomous driving"">[paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving"</a> 中的前转向车运动学模型），并导出状态转移函数（运动学方程）\(f(\cdot)\)，观测函数 \(h(\cdot)\)，以及雅克比矩阵 \(F\)，\(H\)。</p>
<h3 id="chcvconstant-heading-and-constant-velocity">2.1. CHCV(Constant Heading and Constant Velocity)</h3>
<p>　　该模型下，目标车辆的朝向及速度不变，即 \(\dot{\psi}=0\)。则容易写出，在时间 \(\Delta T\) 内，运动方程\(f(\cdot)\)为： <span class="math display">\[\begin{align}
&amp; \begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}\end{bmatrix} _k=
\begin{bmatrix}
x+v\,cos(\psi)\Delta T\\
y+v\,sin(\psi)\Delta T\\
\psi\\
v\\
0\end{bmatrix} _{k-1} \\
\iff &amp;\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\end{bmatrix} _k=
\begin{bmatrix}
x+v\,cos(\psi)\Delta T\\
y+v\,sin(\psi)\Delta T\\
\psi\\
v\\
\end{bmatrix} _{k-1} \tag{10}
\end{align}\]</span> 观测方程\(h(\cdot)\)也可得到： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix} _k=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\end{bmatrix} _{k} \tag{11} \]</span> 由此得到雅克比矩阵： <span class="math display">\[\begin{align}F&amp;=
\begin{bmatrix}
1 &amp;0 &amp;-v\,sin(\psi)\Delta T &amp;cos(\psi)\Delta T\\
0 &amp;1 &amp;v\,cos(\psi)\Delta T &amp;sin(\psi)\Delta T\\
0 &amp;0 &amp;1 &amp;0\\
0 &amp;0 &amp;0 &amp;1
\end{bmatrix} \tag{12} \\
H&amp;=\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0\\
\end{bmatrix} \tag{13}
\end{align}\]</span></p>
<h3 id="ctrvconstant-turn-rate-and-velocity">2.2. CTRV(Constant Turn Rate and Velocity)</h3>
<p>　　该模型下，目标车辆的(朝向)转向速度及线速度不变，即 \(a=0\)。则分别在 \(x,y\) 方向上，位移积分为： <span class="math display">\[\left\{\begin{array}{l}
x=\int_0^{\Delta T} v\,cos(\dot{\psi}t+\psi)dt=\frac{v}{\dot{\psi}}sin(\dot{\psi}t+\psi)\vert_0^{\Delta T}&amp;= \frac{v}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) \\
y=\int_0^{\Delta T} v\,sin(\dot{\psi}t+\psi)dt=-\frac{v}{\dot{\psi}}cos(\dot{\psi}t+\psi)\vert_0^{\Delta T}&amp;=\frac{v}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\
\end{array}\tag{14}\right.\]</span> 由此得到运动方程\(f(\cdot)\)为： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}\end{bmatrix} _k=
\begin{bmatrix}
x+\frac{v}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi))\\
y+\frac{v}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\
\psi+\dot{\psi}\Delta T\\
v\\
\dot{\psi}\end{bmatrix} _{k-1}  \tag{15}
\]</span> 观测方程则还是线性方程： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix} _k=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}
\end{bmatrix} _{k} \tag{16} \]</span> 由此得到雅克比矩阵： <span class="math display">\[\begin{align}F&amp;=
\begin{bmatrix}
1 &amp;0 &amp;\frac{v}{\dot{\psi}}(cos(\dot{\psi}+\psi)-cos(\psi)) &amp;\frac{1}{\dot{\psi}}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) &amp;\frac{v\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{v}{\dot{\psi}^2}(sin(\dot{\psi}\Delta T+\psi)-sin(\psi)) \\
0 &amp;1 &amp;\frac{v}{\dot{\psi}}(sin(\dot{\psi}+\psi)-sin(\psi)) &amp;\frac{1}{\dot{\psi}}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) &amp;\frac{v\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{v}{\dot{\psi}^2}(cos(\psi)-cos(\dot{\psi}\Delta T+\psi)) \\
0 &amp;0 &amp;1 &amp;0 &amp;\Delta T\\
0 &amp;0 &amp;0 &amp;1 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;1\\
\end{bmatrix} \tag{17} \\
H&amp;=\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix} \tag{18}
\end{align}\]</span></p>
<h3 id="ctraconstant-turn-rate-and-acceleration">2.3. CTRA(Constant Turn Rate and Acceleration)</h3>
<p>　　该模型下，目标车辆的(朝向)转向速度及线加速度不变。\(x,y\) 方向上的位移积分为： <span class="math display">\[\left\{\begin{array}{l}
x&amp;=&amp;\int_0^{\Delta T} (v+at)\,cos(\dot{\psi}t+\psi)dt= \frac{a}{\dot{\psi}^2}cos(\dot{\psi}t+\psi)+\frac{v+at}{\dot{\psi}}sin(\dot{\psi}t+\psi)\vert_0^{\Delta T}\\
 &amp;=&amp; \frac{a}{\dot{\psi}^2}cos(\dot{\psi}\Delta T+\psi)+\frac{v+a\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}cos(\psi)-\frac{v}{\dot{\psi}}sin(\psi)\\
y&amp;=&amp;\int_0^{\Delta T} (v+at)\,sin(\dot{\psi}t+\psi)dt= \frac{a}{\dot{\psi}^2}sin(\dot{\psi}t+\psi)-\frac{v+at}{\dot{\psi}}cos(\dot{\psi}t+\psi)\vert_0^{\Delta T}\\
 &amp;=&amp; \frac{a}{\dot{\psi}^2}sin(\dot{\psi}\Delta T+\psi)-\frac{v+a\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}sin(\psi)+\frac{v}{\dot{\psi}}cos(\psi)\\
\end{array}\tag{19}\right.\]</span> 由此得到运动方程\(f(\cdot)\)为： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}\\
a\end{bmatrix} _k=
\begin{bmatrix}
x+\frac{a}{\dot{\psi}^2}cos(\dot{\psi}\Delta T+\psi)+\frac{v+a\Delta T}{\dot{\psi}}sin(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}cos(\psi)-\frac{v}{\dot{\psi}}sin(\psi)\\
y+\frac{a}{\dot{\psi}^2}sin(\dot{\psi}\Delta T+\psi)-\frac{v+a\Delta T}{\dot{\psi}}cos(\dot{\psi}\Delta T+\psi)-\frac{a}{\dot{\psi}^2}sin(\psi)+\frac{v}{\dot{\psi}}cos(\psi) \\
\psi+\dot{\psi}\Delta T\\
v+a\Delta T\\
\dot{\psi}\\
a\end{bmatrix} _{k-1}  \tag{20}
\]</span> 观测方程则还是线性方程： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix} _k=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\dot{\psi}\\
a\end{bmatrix} _{k} \tag{21} \]</span> 同理可得到雅克比矩阵，由于页面限制，这里不再写出。</p>
<h3 id="chaconstant-heading-and-acceleration">2.4. CHA(Constant Heading and Acceleration)</h3>
<p>　　该模型下，此时目标车辆的朝向及线加速度不变，即 \(\dot{\psi}=0\)。\(x,y\) 方向上的位移积分为： <span class="math display">\[\left\{\begin{array}{l}
x=\int_0^{\Delta T} (v+at)\,cos(\psi)dt= \left(vt+\frac{1}{2}at^2\right)cos(\psi)\vert_0^{\Delta T}&amp;= \left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi) \\
y=\int_0^{\Delta T} (v+at)\,sin(\psi)dt= \left(vt+\frac{1}{2}at^2\right)sin(\psi)\vert_0^{\Delta T}&amp;= \left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi)  \\
\end{array}\tag{22}\right.\]</span> 由此得到运动方程\(f(\cdot)\)为： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
v\\
a\end{bmatrix} _k=
\begin{bmatrix}
x+\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi)\\
y+\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi) \\
\psi\\
v+a\Delta T\\
a\end{bmatrix} _{k-1}  \tag{23}
\]</span> 观测方程则还是线性方程： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix} _k=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\psi\\
v\\
a\end{bmatrix} _{k} \tag{24} \]</span> 由此得到雅克比矩阵： <span class="math display">\[\begin{align}F&amp;=
\begin{bmatrix}
1 &amp;0 &amp;-\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)sin(\psi) &amp;\Delta Tcos(\psi) &amp;\frac{1}{2}\Delta T^2cos(\psi) \\
0 &amp;1 &amp;\left(v\Delta T+\frac{1}{2}a\Delta T^2 \right)cos(\psi) &amp;\Delta Tsin(\psi) &amp;\frac{1}{2}\Delta T^2sin(\psi)\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
0 &amp;0 &amp;0 &amp;1 &amp;\Delta T \\
0 &amp;0 &amp;0 &amp;0 &amp;1
\end{bmatrix} \tag{25} \\
H&amp;=\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix} \tag{26}
\end{align}\]</span></p>
<h3 id="前转向车模型">2.5. 前转向车模型</h3>
<p>　　这里给出文章 <a href="/[paper_reading]-Stereo-Vision-based-Semantic-3D-Object-and-Ego-motion-Tracking-for-Autonomous-Driving/" title="[paper_reading]-" stereo vision-based semantic 3d object and ego-motion tracking for autonomous driving"">[paper_reading]-"Stereo Vision-based Semantic 3D Object and Ego-motion Tracking for Autonomous Driving"</a> 中的前转向车运动学模型，推导过程可见文章。这里令方向盘角度比率 \(\gamma\) 以及加速度 \(a\) 为 0，所以本质上也是个 CTRV 模型。<br>
　　引入状态变量方向盘/车轮角度 \(\delta\)（与朝向转速 \(\psi\) 类似），运动方程\(f(\cdot)\)为： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\delta\end{bmatrix} _k=
\begin{bmatrix}
x+cos(\psi)v\Delta T\\
y+sin(\psi)v\Delta T \\
\psi+\frac{tan(\delta)}{L}v\Delta T\\
v\\
\delta\end{bmatrix} _{k-1}  \tag{27}
\]</span> 观测方程则还是线性方程： <span class="math display">\[\begin{bmatrix}
x\\
y\\
\psi\\
\end{bmatrix} _k=
\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
\psi\\
v\\
\delta\end{bmatrix} _{k} \tag{28} \]</span> 由此得到雅克比矩阵： <span class="math display">\[\begin{align}F&amp;=
\begin{bmatrix}
1 &amp;0 &amp;-sin(\psi)v\Delta T &amp;cos(\psi)\Delta T &amp;0 \\
0 &amp;1 &amp;cos(\psi)v\Delta T  &amp;sin(\psi)\Delta T &amp;0  \\
0 &amp;0 &amp;1 &amp;\frac{tan(\delta)}{L}\Delta T &amp;\frac{v}{Lcos^2(\delta)}\Delta T\\
0 &amp;0 &amp;0 &amp;1 &amp;0\\
0 &amp;0 &amp;0 &amp;0 &amp;1\\
\end{bmatrix} \tag{29} \\
H&amp;=\begin{bmatrix}
1 &amp;0 &amp;0 &amp;0 &amp;0\\
0 &amp;1 &amp;0 &amp;0 &amp;0\\
0 &amp;0 &amp;1 &amp;0 &amp;0\\
\end{bmatrix} \tag{30}
\end{align}\]</span></p>
<h2 id="状态及参数初始化">3. 状态及参数初始化</h2>
<p>　　以上介绍了四个质点模型以及一个前转向模型，当然还有更复杂的模型，但是对于目标车辆的状态估计，由于观测量有限，而且也不能知道输入量（如果 V2X 能够实现，那就知道目标车辆的更多状态信息了），所以这些模型也基本够用。<br>
　　模型构建好之后，为了迭代，还需初始化各个状态量及协方差参数矩阵。初始化值不对，会导致迭代发散，这里初始化就会有几个问题：</p>
<ul>
<li>无法观测的状态量较难初始化，如转向速度，线加速度等；</li>
<li>观测不稳定的状态量较难初始化，如目标有截断的情况下；</li>
<li>协方差矩阵较难初始化，如状态量的协方差矩阵；</li>
</ul>
<p>　　前两个问题需要在工程实践中优化；最后一个问题（<strong>非常重要</strong>）可以让检测网络同时出预测值的不确定性(Uncertainty)，这也是深度学习中一个较为系统性的工作，后面文章再做介绍。</p>
<p><a id="1" href="#1ref">[1]</a> https://github.com/balzer82/Kalman</p>
]]></content>
      <categories>
        <category>MOT</category>
      </categories>
      <tags>
        <tag>3D Detection</tag>
        <tag>autonomous driving</tag>
        <tag>MOT</tag>
        <tag>tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波详解</title>
    <url>/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>　　状态估计问题是指，基于初始状态信息，一系列观测量，一系列输入量，以及系统的运动模型和观测模型，来计算系统在某时刻的真实状态的估计值。卡尔曼滤波及其相关卡尔曼滤波算法是状态估计的重要方法。本文介绍卡尔曼滤波(Kalman Filter)，扩展卡尔曼滤波(Extended Kalman Filter)。</p>
<h2 id="卡尔曼滤波">1. 卡尔曼滤波</h2>
<h3 id="线性高斯系统">1.1. 线性高斯系统</h3>
<p>　　卡尔曼滤波是线性高斯系统的最优无偏估计，定义离散线性高斯系统： <span class="math display">\[\left\{\begin{array}{l}
运动方程:\quad x_k=A_kx_{k-1}+B_ku_k+w_k\\
测量方程:\quad z_k=C_kx_k+v_k
\end{array}\tag{1}\right.\]</span> 其中矩阵 \(A_k\) 为转移矩阵（transition matrix），设矩阵 \(B_k=I\) 为控制矩阵，矩阵 \(C_k\) 为观测矩阵(observation matrix)。并且所有状态和噪声均满足高斯分布： <span class="math display">\[\begin{align}
过程噪声: \quad &amp; w_k \sim N(0,Q_k)\\
测量噪声: \quad &amp; v_k \sim N(0,R_k)
\end{align}\]</span> 卡尔曼滤波估计线性高斯系统的状态分为两个步骤：</p>
<ol type="1">
<li><strong>预测（Predict）</strong><br>
计算先验： <span class="math display">\[\begin{align}
\bar{x}_ k &amp;=A_ k\hat{x}_ {k-1}+u_ k \tag{2}\\
\bar{P}_ k &amp;=A_ k\hat{P}_ {k-1}A_ k^T+Q_ k \tag{3}
\end{align}\]</span></li>
<li><strong>更新（Update）</strong><br>
先计算卡尔曼增益： <span class="math display">\[K_k=\bar{P}_kC_k^T(C_k\bar{P}_kC_k^T+R_k)^{-1} \tag{4}\]</span> 再计算后验概率分布： <span class="math display">\[\begin{align}
\hat{x}_k &amp;=\bar{x}_k+K(z_k-C_k\bar{x}) \tag{5}\\
\hat{P}_k &amp;=(I-KC_k)\bar{P}_k \tag{6}
\end{align}\]</span></li>
</ol>
<p>以下通过三种方式来推导出卡尔曼滤波器。</p>
<h3 id="通过-map贝叶斯推断推导123">1.2. 通过 MAP/贝叶斯推断推导<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a><a href="#3" id="3ref"><sup>[3]</sup></a></h3>
<p>　　状态估计问题的概率解释就是用 \(0\) 到 \(k\) 的数据（包括初始状态，观测量，输入量）来估计当前时刻的状态分布：\(P(x_k\vert x_0,u_{1:k},z_{1:k})\)。根据贝叶斯法则： <span class="math display">\[P(x_k\vert x_0,u_{1:k},z_{1:k}) \propto P(z_k\vert x_k)P(x_k\vert x_0,u_{1:k},z_{1:k-1})\tag{7}\]</span> 这三项分别为后验概率，似然，先验概率。所以状态估计可转换为该后验概率最大化（Maximize a Posterior，MAP）问题。MAP 相当于最大化似然与先验的乘积。似然由测量方程给出，先验有运动方程给出。先验部分如果考虑历史所有信息，那么可以用非线性优化框架来解；如果只考虑一阶马尔科夫性，那么就是卡尔曼滤波方法，前述线性高斯系统就满足一阶马尔科夫性。<br>
　　该系统下，假设已知 \(k-1\) 时刻的后验状态估计 \(\hat{x}_ {k-1}\) 及其协方差 \(\hat{P}_ {k-1}\)，现在要根据 \(k\) 时刻的输入和观测数据，确定 \(x_k\) 的后验分布。这里以 \((\hat{\cdot})\) 表示后验分布，\((\bar{\cdot})\) 表示先验分布。<br>
　　卡尔曼滤波器首先通过(1)中的运动方程确定 \(x_k\) 的先验分布，即预测过程。将 \(k-1\) 时刻的分布通过运动方程传递，对于均值有： <span class="math display">\[\begin{align}
\bar{x}_k &amp;=E[x_k]=E[A_kx_{k-1}+u_k+w_k]\\
&amp;=A_kE[x_{k-1}]+u_k+E[w_k]\\
&amp;=A_k\hat{x}_{k-1}+u_k
\end{align}\]</span> 对于协方差有： <span class="math display">\[\begin{align}
\bar{P}_k &amp;=E\left[(x_k-E[x_k])(x_k-E[x_k])^T\right]\\
&amp;=E\left[(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)\cdot(A_kx_{k-1}+u_k+w_k-A_k\hat{x}_{k-1}-u_k)^T\right]\\
&amp;=A_kE\left[(x _{k-1}-\hat{x} _{k-1})\cdot(x _{k-1}-\hat{x} _{k-1})^T\right]A_k^T+E[w_kw_k^T]\\
&amp;=A_k\hat{P} _{k-1}A _{k-1}^T+Q _k
\end{align}\]</span></p>
<p>由此可得<strong>预测过程</strong>： <span class="math display">\[\begin{align}
&amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(A_k\hat{x}_{k-1}+u_k,A_k\hat{P}_{k-1}A_k^T+Q_k\right)\tag{8}\\
\iff &amp;公式 (2),(3)
\end{align}\]</span> 　　另一方面，通过(1)中的观测方程，可以得到在某个状态下观测数据应该为： <span class="math display">\[P(z_k\vert x_k)=N(C_kx_k,R)\tag{9}\]</span> 由公式(7)可知，状态的后验概率分布由预测量以及测量量融合得到，这个融合的过程是两个高斯状的概率分布进行相乘，即 \(x_k\) 的后验概率： <span class="math display">\[N(\hat{x}_k,\hat{P}_k)=N(C_kx_k,R)\cdot N(\bar{x}_k,\bar{P}_k)\tag{10}\]</span> 比较该式指数部分即可得到<strong>更新过程</strong>： <span class="math display">\[\begin{align}
&amp; (x_k-\hat{x}_k)^T\hat{P}_k^{-1}(x_k-\hat{x}_k)=(z_k-C_kx_k)^TR^{-1}(z_k-C_kx_k)+(x_k-\bar{x}_k)^T\bar{P}_k^{-1}(x_k-\bar{x}_k)\\
\iff &amp; 
\left\{\begin{array}{l}
二次项系数:\quad \hat{P}_k^{-1}=C_k^TR^{-1}C_k+\bar{P}_k^{-1}\\
一次项系数:\quad 2\hat{x}_k^T\hat{P}_k^{-1}x_k=2z_k^TR^{-1}C_kx_k+2\bar{x}_k^T\bar{P}_k^{-1}x_k
\end{array}\right. \tag{11} \\
\iff &amp; 
\left\{\begin{array}{l}
I=\hat{P}_kC_k^TR^{-1}C_k+\hat{P}_k\bar{P}_k^{-1}\\
\hat{x}_k=\hat{P}_kC_k^TR^{-1}z_k+\hat{P}_k\bar{P}_k^{-1}\bar{x}_k
\end{array}\right. 令 K=\hat{P}_kC_k^TR^{-1} \\
\iff &amp; 
\left\{\begin{array}{l}
I=KC_k+\hat{P}_k\bar{P}_k^{-1}\\
\hat{x}_k=Kz_k+(I-KC_k)\bar{x}_k
\end{array}\right. \\
\iff &amp; 式 (4),(5),(6)
\end{align}\]</span> 　　对于更新过程，<a href="#3" id="3ref">[3]</a>中提出了另一种更加形象的证明方法。如图1所示，容易得到小车模型的运动方程： <span class="math display">\[\begin{bmatrix}
x _k\\
\dot{x} _k\\
\end{bmatrix}=
\begin{bmatrix}
1 &amp; \Delta k\\
0 &amp; 1\\
\end{bmatrix}
\begin{bmatrix}
x _{k-1}\\
\dot{x} _{k-1}\\
\end{bmatrix}+
\begin{bmatrix}
\frac{(\Delta k)^2}{2}\\
\Delta k\\
\end{bmatrix}a_k
\]</span> 其中 \(a_k\) 为加速度输入量，对比式(1)也容易得到转移矩阵与控制矩阵。预测过程的证明方式与上述一致，下面简述其更新过程的证明，详见<a href="#3" id="3ref">[3]</a>。 <img src="/卡尔曼滤波详解/小车.png" width="100%" height="100%" title="图 1. 小车模型"> 　　如图1所示，红色区域代表预测量 \({x}_k\) 的概率分布高斯函数；蓝色代表测量量 \(z_k\) 概率分布的高斯函数，测量装置为左侧的 ToF 装置，单位为秒。绿色代表状态的后验概率分布 \(_k\)，由预测量的概率(先验)与测量量的概率(似然)相乘得到。由式(10)可知，两个高斯函数相乘还是高斯函数（但是是尺度变化的高斯函数，Scaled Gaussian<a href="#4" id="4ref"><sup>[4]</sup></a>），上面的证明过程直接比较二次项与一次项，这里是直接写出新的高斯分布均值方差与另两个高斯分布均值方差的关系，<strong>本质上都是比较自变量前面的系数</strong>，非系数是不相等的，还有 Scaled 项。由此可得到更新过程。要注意的是，高斯分布相乘时，要注意单位的转换(<strong>即需要满足式(10)的单位形式</strong>)，这里的观察矩阵就是基于测量装置的测量单位(秒)与状态单位(米，米/秒)的转换值。</p>
<h2 id="扩展卡尔曼滤波">2. 扩展卡尔曼滤波</h2>
<h3 id="非线性非高斯系统">2.1. 非线性非高斯系统</h3>
<p>　　通常系统（如 SLAM）的运动方程和观测方程是非线性函数，写成一般形式： <span class="math display">\[\left\{\begin{array}{l}
运动方程:\quad x_k=f(x_{k-1},u_k)+w_k\\
测量方程:\quad z_k=h(x_k)+v_k
\end{array}\tag{12}\right.\]</span> 扩展卡尔曼滤波估计非线性系统的状态与卡尔曼滤波类似，也分为两个步骤：</p>
<ol type="1">
<li><strong>预测（Predict）</strong> 计算先验： <span class="math display">\[\begin{align}
\bar{x} _k&amp;=f(\hat{x} _{k-1},u _k) \tag{13}\\
\bar{P} _k&amp;=F\hat{P} _kF^T+Q _k \tag{14}
\end{align}\]</span></li>
<li><strong>更新（Update）</strong> 先计算卡尔曼增益： <span class="math display">\[K_k=\bar{P}_kH_k^T(H_k\bar{P}_kH_k^T+R_k)^{-1} \tag{15}\]</span> 再计算后验概率分布： <span class="math display">\[\begin{align}
\hat{x}_k &amp;=\bar{x}_k+K(z_k-h(\bar{x})) \tag{16}\\
\hat{P}_k &amp;=(I-KH_k)\bar{P}_k \tag{17}
\end{align}\]</span></li>
</ol>
<h3 id="通过-map贝叶斯推断推导12">2.2. 通过 MAP/贝叶斯推断推导<a href="#1" id="1ref"><sup>[1]</sup></a><a href="#2" id="2ref"><sup>[2]</sup></a></h3>
<p>　　在某个点附件考虑运动方程与观测方程的一阶泰勒展开，只保留一阶项，即线性部分，然后按照线性系统进行推导。在 \(k\) 时刻，将运动方程和观测方程在 \(\hat{x}_ {k-1},\hat{P}_ {k-1}\) 处进行线性化： <span class="math display">\[\left\{\begin{array}{l}
运动方程:\quad x_k\approx f(\hat{x}_{k-1},u_k)+F(x_{k-1}-\hat{x}_{k-1})+w_k\\
测量方程:\quad z_k\approx h(\bar{x}_k)+H(x_k-\bar{x}_k)+v_k
\end{array}\tag{18}\right.\]</span> 其中 \(F=\left.\frac{\partial f}{\partial x_{k-1}}\right\arrowvert_{\hat{x}_ {k-1}}\)， \(H=\left.\frac{\partial h}{\partial x_k}\right\arrowvert_{\bar{x}_ k}\)。<br>
　　由此可得<strong>预测过程</strong>: <span class="math display">\[\begin{align}
&amp;P(x_k\vert x_0,u_{1:k},z_{1:k-1})=N\left(f(\hat{x}_{k-1},u_k),F\hat{P}_{k-1}F^T+Q_k\right)\tag{19}\\
\iff &amp;公式 (13),(14)
\end{align}\]</span> 　　另一方面，通过(18)中的观测方程，可以得到在某个状态下观测数据应该为： <span class="math display">\[P(z_k\vert x_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R)\tag{20}\]</span> 由贝叶斯公式，可得 \(x_k\) 的后验概率： <span class="math display">\[N(\hat{x}_k,\hat{P}_k)=N(h(\bar{x})+H(x_k-\bar{x}_k),R))\cdot N(\bar{x}_k,\bar{P}_k)\tag{21}\]</span> 类似卡尔曼推导过程，由此可得到更新过程式(15)，(16)，(17)。</p>
<p><a id="1" href="#1ref">[1]</a> 高翔, 张涛, 颜沁睿, 刘毅, 视觉SLAM十四讲：从理论到实践, 电子工业出版社, 2017<br>
<a id="2" href="#2ref">[2]</a> T. D. Barfoot. State Estimation for Robotics. Cambridge University Press, 2017.<br>
<a id="3" href="#3ref">[3]</a> Faragher, Ramsey. &quot;Understanding the basis of the Kalman filter via a simple and intuitive derivation.&quot; IEEE Signal processing magazine 29.5 (2012): 128-132.<br>
<a id="4" href="#4ref">[4]</a> Bromiley, Paul. &quot;Products and convolutions of Gaussian probability density functions.&quot; Tina-Vision Memo 3.4 (2003): 1.</p>
]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>MOT</tag>
      </tags>
  </entry>
</search>
